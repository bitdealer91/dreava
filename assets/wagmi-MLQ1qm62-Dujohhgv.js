var __typeError=e=>{throw TypeError(e)};var __accessCheck=(e,t,n)=>t.has(e)||__typeError("Cannot "+n);var __privateGet=(e,t,n)=>(__accessCheck(e,t,"read from private field"),n?n.call(e):t.get(e));var __privateAdd=(e,t,n)=>t.has(e)?__typeError("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n);var __privateSet=(e,t,n,s)=>(__accessCheck(e,t,"write to private field"),s?s.call(e,n):t.set(e,n),n);var __privateMethod=(e,t,n)=>(__accessCheck(e,t,"access private method"),n);var __privateWrapper=(e,t,n,s)=>({set _(s){__privateSet(e,t,s,n)},get _(){return __privateGet(e,t,s)}});var e,t,n,s,r,o,a,i,c,u,l,d,f,p,m,g,y,b,w,v,x,P,$,E,A,T,I,S,k,B,C,O,F,N,R,M,z,j,L,H,U,_,D,G,W,V,K,Q,Z,J,Y,X,ee,te,ne,se,re,oe,ae,ie,ce,ue,le,de,he,fe,pe,me,ge,ye,be,we,ve,xe,Pe;import{r as $e,g as Ee}from"./vendor-BkkZ95pQ.js";function _mergeNamespaces(e,t){for(var n=0;n<t.length;n++){const s=t[n];if("string"!=typeof s&&!Array.isArray(s))for(const t in s)if("default"!==t&&!(t in e)){const n=Object.getOwnPropertyDescriptor(s,t);n&&Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>s[t]})}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var Ae={exports:{}};var Te={};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ie;function requireReactJsxRuntime_production_min(){if(Ie)return Te;Ie=1;var e=$e(),t=Symbol.for("react.element"),n=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function q(e,n,a){var i,c={},u=null,l=null;void 0!==a&&(u=""+a);void 0!==n.key&&(u=""+n.key);void 0!==n.ref&&(l=n.ref);for(i in n)s.call(n,i)&&!o.hasOwnProperty(i)&&(c[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps,n)void 0===c[i]&&(c[i]=n[i]);return{$$typeof:t,type:e,key:u,ref:l,props:c,_owner:r.current}}Te.Fragment=n;Te.jsx=q;Te.jsxs=q;return Te}var Se;function requireJsxRuntime(){if(Se)return Ae.exports;Se=1;Ae.exports=requireReactJsxRuntime_production_min();return Ae.exports}var ke=requireJsxRuntime();var Be=$e();const Ce=Ee(Be);const Oe=_mergeNamespaces({__proto__:null,default:Ce},[Be]);const Fe="2.33.3";let Ne={getDocsUrl:({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,version:`viem@${Fe}`};let Re=class e extends Error{constructor(t,n={}){const s=(()=>n.cause instanceof e?n.cause.details:n.cause?.message?n.cause.message:n.details)();const r=(()=>n.cause instanceof e&&n.cause.docsPath||n.docsPath)();const o=Ne.getDocsUrl?.({...n,docsPath:r});const a=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...o?[`Docs: ${o}`]:[],...s?[`Details: ${s}`]:[],...Ne.version?[`Version: ${Ne.version}`]:[]].join("\n");super(a,n.cause?{cause:n.cause}:void 0);Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"});this.details=s;this.docsPath=r;this.metaMessages=n.metaMessages;this.name=n.name??this.name;this.shortMessage=t;this.version=Fe}walk(e){return walk$1(this,e)}};function walk$1(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e&&void 0!==e.cause?walk$1(e.cause,t):t?null:e}let Me=class extends Re{constructor({max:e,min:t,signed:n,size:s,value:r}){super(`Number "${r}" is not in safe ${s?`${8*s}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}};class ze extends Re{constructor(e){super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}class je extends Re{constructor(e){super(`Hex value "${e}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,{name:"InvalidHexBooleanError"})}}let qe=class extends Re{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}};let Le=class extends Re{constructor({offset:e,position:t,size:n}){super(`Slice ${"start"===t?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${n}).`,{name:"SliceOffsetOutOfBoundsError"})}};let He=class extends Re{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}};class Ue extends Re{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${t} ${n} long, but is ${e} ${n} long.`,{name:"InvalidBytesLengthError"})}}function pad$2(e,{dir:t,size:n=32}={}){return"string"==typeof e?padHex(e,{dir:t,size:n}):padBytes(e,{dir:t,size:n})}function padHex(e,{dir:t,size:n=32}={}){if(null===n)return e;const s=e.replace("0x","");if(s.length>2*n)throw new He({size:Math.ceil(s.length/2),targetSize:n,type:"hex"});return`0x${s["right"===t?"padEnd":"padStart"](2*n,"0")}`}function padBytes(e,{dir:t,size:n=32}={}){if(null===n)return e;if(e.length>n)throw new He({size:e.length,targetSize:n,type:"bytes"});const s=new Uint8Array(n);for(let r=0;r<n;r++){const o="right"===t;s[o?r:n-r-1]=e[o?r:e.length-r-1]}return s}function isHex(e,{strict:t=!0}={}){return!!e&&("string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")))}function size$4(e){return isHex(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}function trim(e,{dir:t="left"}={}){let n="string"==typeof e?e.replace("0x",""):e;let s=0;for(let r=0;r<n.length-1&&"0"===n["left"===t?r:n.length-r-1].toString();r++)s++;n="left"===t?n.slice(s):n.slice(0,n.length-s);if("string"==typeof e){1===n.length&&"right"===t&&(n=`${n}0`);return`0x${n.length%2==1?`0${n}`:n}`}return n}const _e=new TextEncoder;function toBytes$2(e,t={}){return"number"==typeof e||"bigint"==typeof e?numberToBytes(e,t):"boolean"==typeof e?boolToBytes(e,t):isHex(e)?hexToBytes$1(e,t):stringToBytes(e,t)}function boolToBytes(e,t={}){const n=new Uint8Array(1);n[0]=Number(e);if("number"==typeof t.size){assertSize$2(n,{size:t.size});return pad$2(n,{size:t.size})}return n}const De={zero:48,nine:57,A:65,F:70,a:97,f:102};function charCodeToBase16$1(e){return e>=De.zero&&e<=De.nine?e-De.zero:e>=De.A&&e<=De.F?e-(De.A-10):e>=De.a&&e<=De.f?e-(De.a-10):void 0}function hexToBytes$1(e,t={}){let n=e;if(t.size){assertSize$2(n,{size:t.size});n=pad$2(n,{dir:"right",size:t.size})}let s=n.slice(2);s.length%2&&(s=`0${s}`);const r=s.length/2;const o=new Uint8Array(r);for(let a=0,i=0;a<r;a++){const e=charCodeToBase16$1(s.charCodeAt(i++));const t=charCodeToBase16$1(s.charCodeAt(i++));if(void 0===e||void 0===t)throw new Re(`Invalid byte sequence ("${s[i-2]}${s[i-1]}" in "${s}").`);o[a]=16*e+t}return o}function numberToBytes(e,t){const n=numberToHex(e,t);return hexToBytes$1(n)}function stringToBytes(e,t={}){const n=_e.encode(e);if("number"==typeof t.size){assertSize$2(n,{size:t.size});return pad$2(n,{dir:"right",size:t.size})}return n}function assertSize$2(e,{size:t}){if(size$4(e)>t)throw new qe({givenSize:size$4(e),maxSize:t})}function hexToBigInt(e,t={}){const{signed:n}=t;t.size&&assertSize$2(e,{size:t.size});const s=BigInt(e);if(!n)return s;const r=(e.length-2)/2;const o=(1n<<8n*BigInt(r)-1n)-1n;return s<=o?s:s-BigInt(`0x${"f".padStart(2*r,"f")}`)-1n}function hexToBool(e,t={}){let n=e;if(t.size){assertSize$2(n,{size:t.size});n=trim(n)}if("0x00"===trim(n))return!1;if("0x01"===trim(n))return!0;throw new je(n)}function hexToNumber$1(e,t={}){return Number(hexToBigInt(e,t))}function hexToString(e,t={}){let n=hexToBytes$1(e);if(t.size){assertSize$2(n,{size:t.size});n=trim(n,{dir:"right"})}return(new TextDecoder).decode(n)}const Ge=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function toHex(e,t={}){return"number"==typeof e||"bigint"==typeof e?numberToHex(e,t):"string"==typeof e?stringToHex(e,t):"boolean"==typeof e?boolToHex(e,t):bytesToHex$1(e,t)}function boolToHex(e,t={}){const n=`0x${Number(e)}`;if("number"==typeof t.size){assertSize$2(n,{size:t.size});return pad$2(n,{size:t.size})}return n}function bytesToHex$1(e,t={}){let n="";for(let r=0;r<e.length;r++)n+=Ge[e[r]];const s=`0x${n}`;if("number"==typeof t.size){assertSize$2(s,{size:t.size});return pad$2(s,{dir:"right",size:t.size})}return s}function numberToHex(e,t={}){const{signed:n,size:s}=t;const r=BigInt(e);let o;s?o=n?(1n<<8n*BigInt(s)-1n)-1n:2n**(8n*BigInt(s))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const a="bigint"==typeof o&&n?-o-1n:0;if(o&&r>o||r<a){const t="bigint"==typeof e?"n":"";throw new Me({max:o?`${o}${t}`:void 0,min:`${a}${t}`,signed:n,size:s,value:`${e}${t}`})}const i=`0x${(n&&r<0?(1n<<BigInt(8*s))+BigInt(r):r).toString(16)}`;return s?pad$2(i,{size:s}):i}const We=new TextEncoder;function stringToHex(e,t={}){const n=We.encode(e);return bytesToHex$1(n,t)}function formatAbiItem$1(e,{includeName:t=!1}={}){if("function"!==e.type&&"event"!==e.type&&"error"!==e.type)throw new gt(e.type);return`${e.name}(${formatAbiParams(e.inputs,{includeName:t})})`}function formatAbiParams(e,{includeName:t=!1}={}){return e?e.map(e=>formatAbiParam(e,{includeName:t})).join(t?", ":","):""}function formatAbiParam(e,{includeName:t}){return e.type.startsWith("tuple")?`(${formatAbiParams(e.components,{includeName:t})})${e.type.slice(5)}`:e.type+(t&&e.name?` ${e.name}`:"")}class Ve extends Re{constructor({docsPath:e}){super(["A constructor was not found on the ABI.","Make sure you are using the correct ABI and that the constructor exists on it."].join("\n"),{docsPath:e,name:"AbiConstructorNotFoundError"})}}class Ke extends Re{constructor({docsPath:e}){super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.","Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join("\n"),{docsPath:e,name:"AbiConstructorParamsNotFoundError"})}}class Qe extends Re{constructor({data:e,params:t,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join("\n"),{metaMessages:[`Params: (${formatAbiParams(t,{includeName:!0})})`,`Data:   ${e} (${n} bytes)`],name:"AbiDecodingDataSizeTooSmallError"});Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.data=e;this.params=t;this.size=n}}class Ze extends Re{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}}class Je extends Re{constructor({expectedLength:e,givenLength:t,type:n}){super([`ABI encoding array length mismatch for type ${n}.`,`Expected length: ${e}`,`Given length: ${t}`].join("\n"),{name:"AbiEncodingArrayLengthMismatchError"})}}class Ye extends Re{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${size$4(t)}) does not match expected size (bytes${e}).`,{name:"AbiEncodingBytesSizeMismatchError"})}}class Xe extends Re{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${e}`,`Given length (values): ${t}`].join("\n"),{name:"AbiEncodingLengthMismatchError"})}}class et extends Re{constructor(e,{docsPath:t}){super([`Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,"Cannot encode error result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the inputs exist on it."].join("\n"),{docsPath:t,name:"AbiErrorInputsNotFoundError"})}}class tt extends Re{constructor(e,{docsPath:t}={}){super([`Error ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it."].join("\n"),{docsPath:t,name:"AbiErrorNotFoundError"})}}class nt extends Re{constructor(e,{docsPath:t}){super([`Encoded error signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiErrorSignatureNotFoundError"});Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.signature=e}}class st extends Re{constructor({docsPath:e}){super("Cannot extract event signature from empty topics.",{docsPath:e,name:"AbiEventSignatureEmptyTopicsError"})}}class rt extends Re{constructor(e,{docsPath:t}){super([`Encoded event signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiEventSignatureNotFoundError"})}}class ot extends Re{constructor(e,{docsPath:t}={}){super([`Event ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it."].join("\n"),{docsPath:t,name:"AbiEventNotFoundError"})}}class at extends Re{constructor(e,{docsPath:t}={}){super([`Function ${e?`"${e}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionNotFoundError"})}}class it extends Re{constructor(e,{docsPath:t}){super([`Function "${e}" does not contain any \`outputs\` on ABI.`,"Cannot decode function result without knowing what the parameter types are.","Make sure you are using the correct ABI and that the function exists on it."].join("\n"),{docsPath:t,name:"AbiFunctionOutputsNotFoundError"})}}class ct extends Re{constructor(e,{docsPath:t}){super([`Encoded function signature "${e}" not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"),{docsPath:t,name:"AbiFunctionSignatureNotFoundError"})}}class ut extends Re{constructor(e,t){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${e.type}\` in \`${formatAbiItem$1(e.abiItem)}\`, and`,`\`${t.type}\` in \`${formatAbiItem$1(t.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}}let lt=class extends Re{constructor({expectedSize:e,givenSize:t}){super(`Expected bytes${e}, got bytes${t}.`,{name:"BytesSizeMismatchError"})}};class dt extends Re{constructor({abiItem:e,data:t,params:n,size:s}){super([`Data size of ${s} bytes is too small for non-indexed event parameters.`].join("\n"),{metaMessages:[`Params: (${formatAbiParams(n,{includeName:!0})})`,`Data:   ${t} (${s} bytes)`],name:"DecodeLogDataMismatch"});Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.abiItem=e;this.data=t;this.params=n;this.size=s}}class ht extends Re{constructor({abiItem:e,param:t}){super([`Expected a topic for indexed event parameter${t.name?` "${t.name}"`:""} on event "${formatAbiItem$1(e,{includeName:!0})}".`].join("\n"),{name:"DecodeLogTopicsMismatch"});Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.abiItem=e}}class ft extends Re{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiEncodingType"})}}class pt extends Re{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid decoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t,name:"InvalidAbiDecodingType"})}}let mt=class extends Re{constructor(e){super([`Value "${e}" is not a valid array.`].join("\n"),{name:"InvalidArrayError"})}};class gt extends Re{constructor(e){super([`"${e}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join("\n"),{name:"InvalidDefinitionTypeError"})}}class yt extends Re{constructor(e){super(`Type "${e}" is not supported for packed encoding.`,{name:"UnsupportedPackedAbiType"})}}function concat$1(e){return"string"==typeof e[0]?concatHex(e):concatBytes$1(e)}function concatBytes$1(e){let t=0;for(const r of e)t+=r.length;const n=new Uint8Array(t);let s=0;for(const r of e){n.set(r,s);s+=r.length}return n}function concatHex(e){return`0x${e.reduce((e,t)=>e+t.replace("0x",""),"")}`}let bt=class extends Re{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}};let wt=class extends Map{constructor(e){super();Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.maxSize=e}get(e){const t=super.get(e);if(super.has(e)&&void 0!==t){this.delete(e);super.set(e,t)}return t}set(e,t){super.set(e,t);if(this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}};const vt=BigInt(2**32-1);const xt=BigInt(32);function fromBig$1(e,t=!1){return t?{h:Number(e&vt),l:Number(e>>xt&vt)}:{h:0|Number(e>>xt&vt),l:0|Number(e&vt)}}function split$1(e,t=!1){const n=e.length;let s=new Uint32Array(n);let r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:n,l:a}=fromBig$1(e[o],t);[s[o],r[o]]=[n,a]}return[s,r]}const rotlSH$1=(e,t,n)=>e<<n|t>>>32-n;const rotlSL$1=(e,t,n)=>t<<n|e>>>32-n;const rotlBH$1=(e,t,n)=>t<<n-32|e>>>64-n;const rotlBL$1=(e,t,n)=>e<<n-32|t>>>64-n;const Pt="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes$1(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function anumber$1(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function abytes$1(e,...t){if(!isBytes$1(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function ahash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.createHasher");anumber$1(e.outputLen);anumber$1(e.blockLen)}function aexists$1(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function aoutput$1(e,t){abytes$1(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function u32$1(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function clean$1(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function createView(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function rotr(e,t){return e<<32-t|e>>>t}const $t=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function byteSwap$1(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function byteSwap32$1(e){for(let t=0;t<e.length;t++)e[t]=byteSwap$1(e[t]);return e}const Et=$t?e=>e:byteSwap32$1;const At=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)();const Tt=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(e){abytes$1(e);if(At)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Tt[e[n]];return t}const It={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(e){return e>=It._0&&e<=It._9?e-It._0:e>=It.A&&e<=It.F?e-(It.A-10):e>=It.a&&e<=It.f?e-(It.a-10):void 0}function hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(At)return Uint8Array.fromHex(e);const t=e.length;const n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(n);for(let r=0,o=0;r<n;r++,o+=2){const t=asciiToBase16(e.charCodeAt(o));const n=asciiToBase16(e.charCodeAt(o+1));if(void 0===t||void 0===n){const t=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+o)}s[r]=16*t+n}return s}function utf8ToBytes$1(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}function toBytes$1(e){"string"==typeof e&&(e=utf8ToBytes$1(e));abytes$1(e);return e}function concatBytes(...e){let t=0;for(let s=0;s<e.length;s++){const n=e[s];abytes$1(n);t+=n.length}const n=new Uint8Array(t);for(let s=0,r=0;s<e.length;s++){const t=e[s];n.set(t,r);r+=t.length}return n}let St=class{};function createHasher$1(e){const hashC=t=>e().update(toBytes$1(t)).digest();const t=e();hashC.outputLen=t.outputLen;hashC.blockLen=t.blockLen;hashC.create=()=>e();return hashC}function randomBytes(e=32){if(Pt&&"function"==typeof Pt.getRandomValues)return Pt.getRandomValues(new Uint8Array(e));if(Pt&&"function"==typeof Pt.randomBytes)return Uint8Array.from(Pt.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}const kt=BigInt(0);const Bt=BigInt(1);const Ct=BigInt(2);const Ot=BigInt(7);const Ft=BigInt(256);const Nt=BigInt(113);const Rt=[];const Mt=[];const zt=[];for(let vc=0,xc=Bt,Pc=1,$c=0;vc<24;vc++){[Pc,$c]=[$c,(2*Pc+3*$c)%5];Rt.push(2*(5*$c+Pc));Mt.push((vc+1)*(vc+2)/2%64);let e=kt;for(let t=0;t<7;t++){xc=(xc<<Bt^(xc>>Ot)*Nt)%Ft;xc&Ct&&(e^=Bt<<(Bt<<BigInt(t))-Bt)}zt.push(e)}const jt=split$1(zt,!0);const qt=jt[0];const Lt=jt[1];const rotlH$1=(e,t,n)=>n>32?rotlBH$1(e,t,n):rotlSH$1(e,t,n);const rotlL$1=(e,t,n)=>n>32?rotlBL$1(e,t,n):rotlSL$1(e,t,n);function keccakP$1(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let s=0;s<10;s++)n[s]=e[s]^e[s+10]^e[s+20]^e[s+30]^e[s+40];for(let s=0;s<10;s+=2){const t=(s+8)%10;const r=(s+2)%10;const o=n[r];const a=n[r+1];const i=rotlH$1(o,a,1)^n[t];const c=rotlL$1(o,a,1)^n[t+1];for(let n=0;n<50;n+=10){e[s+n]^=i;e[s+n+1]^=c}}let t=e[2];let r=e[3];for(let n=0;n<24;n++){const s=Mt[n];const o=rotlH$1(t,r,s);const a=rotlL$1(t,r,s);const i=Rt[n];t=e[i];r=e[i+1];e[i]=o;e[i+1]=a}for(let s=0;s<50;s+=10){for(let t=0;t<10;t++)n[t]=e[s+t];for(let t=0;t<10;t++)e[s+t]^=~n[(t+2)%10]&n[(t+4)%10]}e[0]^=qt[s];e[1]^=Lt[s]}clean$1(n)}let Ht=class e extends St{constructor(e,t,n,s=!1,r=24){super();this.pos=0;this.posOut=0;this.finished=!1;this.destroyed=!1;this.enableXOF=!1;this.blockLen=e;this.suffix=t;this.outputLen=n;this.enableXOF=s;this.rounds=r;anumber$1(n);if(!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200);this.state32=u32$1(this.state)}clone(){return this._cloneInto()}keccak(){Et(this.state32);keccakP$1(this.state32,this.rounds);Et(this.state32);this.posOut=0;this.pos=0}update(e){aexists$1(this);e=toBytes$1(e);abytes$1(e);const{blockLen:t,state:n}=this;const s=e.length;for(let r=0;r<s;){const o=Math.min(t-this.pos,s-r);for(let t=0;t<o;t++)n[this.pos++]^=e[r++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t;128&t&&n===s-1&&this.keccak();e[s-1]^=128;this.keccak()}writeInto(e){aexists$1(this,!1);abytes$1(e);this.finish();const t=this.state;const{blockLen:n}=this;for(let s=0,r=e.length;s<r;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,r-s);e.set(t.subarray(this.posOut,this.posOut+o),s);this.posOut+=o;s+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){anumber$1(e);return this.xofInto(new Uint8Array(e))}digestInto(e){aoutput$1(e,this);if(this.finished)throw new Error("digest() was already called");this.writeInto(e);this.destroy();return e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0;clean$1(this.state)}_cloneInto(t){const{blockLen:n,suffix:s,outputLen:r,rounds:o,enableXOF:a}=this;t||(t=new e(n,s,r,a,o));t.state32.set(this.state32);t.pos=this.pos;t.posOut=this.posOut;t.finished=this.finished;t.rounds=o;t.suffix=s;t.outputLen=r;t.enableXOF=a;t.destroyed=this.destroyed;return t}};const gen$1=(e,t,n)=>createHasher$1(()=>new Ht(t,e,n));const Ut=(()=>gen$1(1,136,32))();function keccak256$1(e,t){const n=t||"hex";const s=Ut(isHex(e,{strict:!1})?toBytes$2(e):e);return"bytes"===n?s:toHex(s)}const _t=new wt(8192);function checksumAddress(e,t){if(_t.has(`${e}.${t}`))return _t.get(`${e}.${t}`);const n=t?`${t}${e.toLowerCase()}`:e.substring(2).toLowerCase();const s=keccak256$1(stringToBytes(n),"bytes");const r=(t?n.substring(`${t}0x`.length):n).split("");for(let a=0;a<40;a+=2){s[a>>1]>>4>=8&&r[a]&&(r[a]=r[a].toUpperCase());(15&s[a>>1])>=8&&r[a+1]&&(r[a+1]=r[a+1].toUpperCase())}const o=`0x${r.join("")}`;_t.set(`${e}.${t}`,o);return o}function getAddress(e,t){if(!isAddress(e,{strict:!1}))throw new bt({address:e});return checksumAddress(e,t)}const Dt=/^0x[a-fA-F0-9]{40}$/;const Gt=new wt(8192);function isAddress(e,t){const{strict:n=!0}=t??{};const s=`${e}.${n}`;if(Gt.has(s))return Gt.get(s);const r=(()=>!!Dt.test(e)&&(e.toLowerCase()===e||(!n||checksumAddress(e)===e)))();Gt.set(s,r);return r}function slice$1(e,t,n,{strict:s}={}){return isHex(e,{strict:!1})?sliceHex(e,t,n,{strict:s}):sliceBytes(e,t,n,{strict:s})}function assertStartOffset$1(e,t){if("number"==typeof t&&t>0&&t>size$4(e)-1)throw new Le({offset:t,position:"start",size:size$4(e)})}function assertEndOffset$1(e,t,n){if("number"==typeof t&&"number"==typeof n&&size$4(e)!==n-t)throw new Le({offset:n,position:"end",size:size$4(e)})}function sliceBytes(e,t,n,{strict:s}={}){assertStartOffset$1(e,t);const r=e.slice(t,n);s&&assertEndOffset$1(r,t,n);return r}function sliceHex(e,t,n,{strict:s}={}){assertStartOffset$1(e,t);const r=`0x${e.replace("0x","").slice(2*(t??0),2*(n??e.length))}`;s&&assertEndOffset$1(r,t,n);return r}const Wt=/^(.*)\[([0-9]*)\]$/;const Vt=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;const Kt=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function encodeAbiParameters(e,t){if(e.length!==t.length)throw new Xe({expectedLength:e.length,givenLength:t.length});const n=prepareParams({params:e,values:t});const s=encodeParams(n);return 0===s.length?"0x":s}function prepareParams({params:e,values:t}){const n=[];for(let s=0;s<e.length;s++)n.push(prepareParam({param:e[s],value:t[s]}));return n}function prepareParam({param:e,value:t}){const n=getArrayComponents$1(e.type);if(n){const[s,r]=n;return encodeArray$1(t,{length:s,param:{...e,type:r}})}if("tuple"===e.type)return encodeTuple$1(t,{param:e});if("address"===e.type)return encodeAddress$1(t);if("bool"===e.type)return encodeBool(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){const n=e.type.startsWith("int");const[,,s="256"]=Kt.exec(e.type)??[];return encodeNumber$1(t,{signed:n,size:Number(s)})}if(e.type.startsWith("bytes"))return encodeBytes$1(t,{param:e});if("string"===e.type)return encodeString$1(t);throw new ft(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function encodeParams(e){let t=0;for(let o=0;o<e.length;o++){const{dynamic:n,encoded:s}=e[o];t+=n?32:size$4(s)}const n=[];const s=[];let r=0;for(let o=0;o<e.length;o++){const{dynamic:a,encoded:i}=e[o];if(a){n.push(numberToHex(t+r,{size:32}));s.push(i);r+=size$4(i)}else n.push(i)}return concat$1([...n,...s])}function encodeAddress$1(e){if(!isAddress(e))throw new bt({address:e});return{dynamic:!1,encoded:padHex(e.toLowerCase())}}function encodeArray$1(e,{length:t,param:n}){const s=null===t;if(!Array.isArray(e))throw new mt(e);if(!s&&e.length!==t)throw new Je({expectedLength:t,givenLength:e.length,type:`${n.type}[${t}]`});let r=!1;const o=[];for(let a=0;a<e.length;a++){const t=prepareParam({param:n,value:e[a]});t.dynamic&&(r=!0);o.push(t)}if(s||r){const e=encodeParams(o);if(s){const t=numberToHex(o.length,{size:32});return{dynamic:!0,encoded:o.length>0?concat$1([t,e]):t}}if(r)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:concat$1(o.map(({encoded:e})=>e))}}function encodeBytes$1(e,{param:t}){const[,n]=t.type.split("bytes");const s=size$4(e);if(!n){let t=e;s%32!=0&&(t=padHex(t,{dir:"right",size:32*Math.ceil((e.length-2)/2/32)}));return{dynamic:!0,encoded:concat$1([padHex(numberToHex(s,{size:32})),t])}}if(s!==Number.parseInt(n))throw new Ye({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:padHex(e,{dir:"right"})}}function encodeBool(e){if("boolean"!=typeof e)throw new Re(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:padHex(boolToHex(e))}}function encodeNumber$1(e,{signed:t,size:n=256}){if("number"==typeof n){const s=2n**(BigInt(n)-(t?1n:0n))-1n;const r=t?-s-1n:0n;if(e>s||e<r)throw new Me({max:s.toString(),min:r.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:numberToHex(e,{size:32,signed:t})}}function encodeString$1(e){const t=stringToHex(e);const n=Math.ceil(size$4(t)/32);const s=[];for(let r=0;r<n;r++)s.push(padHex(slice$1(t,32*r,32*(r+1)),{dir:"right"}));return{dynamic:!0,encoded:concat$1([padHex(numberToHex(size$4(t),{size:32})),...s])}}function encodeTuple$1(e,{param:t}){let n=!1;const s=[];for(let r=0;r<t.components.length;r++){const o=t.components[r];const a=Array.isArray(e)?r:o.name;const i=prepareParam({param:o,value:e[a]});s.push(i);i.dynamic&&(n=!0)}return{dynamic:n,encoded:n?encodeParams(s):concat$1(s.map(({encoded:e})=>e))}}function getArrayComponents$1(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}const Qt="/docs/contract/encodeDeployData";function encodeDeployData(e){const{abi:t,args:n,bytecode:s}=e;if(!n||0===n.length)return s;const r=t.find(e=>"type"in e&&"constructor"===e.type);if(!r)throw new Ve({docsPath:Qt});if(!("inputs"in r))throw new Ke({docsPath:Qt});if(!r.inputs||0===r.inputs.length)throw new Ke({docsPath:Qt});const o=encodeAbiParameters(r.inputs,n);return concatHex([s,o])}function parseAccount(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}class Zt extends Re{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join("\n"),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class Jt extends Re{constructor({docsPath:e,metaMessages:t,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:t,name:"AccountTypeNotSupportedError"})}}function publicKeyToAddress(e){const t=keccak256$1(`0x${e.substring(4)}`).substring(26);return checksumAddress(`0x${t}`)}const Yt="modulepreload";const assetsURL=function(e){return"/"+e};const Xt={};const __vitePreload=function(e,t,n){let s=Promise.resolve();if(t&&t.length>0){let allSettled2=function(e){return Promise.all(e.map(e=>Promise.resolve(e).then(e=>({status:"fulfilled",value:e}),e=>({status:"rejected",reason:e}))))};document.getElementsByTagName("link");const e=document.querySelector("meta[property=csp-nonce]");const n=e?.nonce||e?.getAttribute("nonce");s=allSettled2(t.map(e=>{e=assetsURL(e);if(e in Xt)return;Xt[e]=!0;const t=e.endsWith(".css");const s=t?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${e}"]${s}`))return;const r=document.createElement("link");r.rel=t?"stylesheet":Yt;t||(r.as="script");r.crossOrigin="";r.href=e;n&&r.setAttribute("nonce",n);document.head.appendChild(r);return t?new Promise((t,n)=>{r.addEventListener("load",t);r.addEventListener("error",()=>n(new Error(`Unable to preload CSS for ${e}`)))}):void 0}))}function handlePreloadError(e){const t=new Event("vite:preloadError",{cancelable:!0});t.payload=e;window.dispatchEvent(t);if(!t.defaultPrevented)throw e}return s.then(t=>{for(const e of t||[])"rejected"===e.status&&handlePreloadError(e.reason);return e().catch(handlePreloadError)})};async function recoverPublicKey({hash:e,signature:t}){const n=isHex(e)?e:toHex(e);const{secp256k1:s}=await __vitePreload(async()=>{const{secp256k1:e}=await Promise.resolve().then(()=>ai);return{secp256k1:e}},void 0);const r=(()=>{if("object"==typeof t&&"r"in t&&"s"in t){const{r:e,s:n,v:r,yParity:o}=t;const a=Number(o??r);const i=toRecoveryBit(a);return new s.Signature(hexToBigInt(e),hexToBigInt(n)).addRecoveryBit(i)}const e=isHex(t)?t:toHex(t);if(65!==size$4(e))throw new Error("invalid signature length");const n=hexToNumber$1(`0x${e.slice(130)}`);const r=toRecoveryBit(n);return s.Signature.fromCompact(e.substring(2,130)).addRecoveryBit(r)})();const o=r.recoverPublicKey(n.substring(2)).toHex(!1);return`0x${o}`}function toRecoveryBit(e){if(0===e||1===e)return e;if(27===e)return 0;if(28===e)return 1;throw new Error("Invalid yParityOrV value")}async function recoverAddress({hash:e,signature:t}){return publicKeyToAddress(await recoverPublicKey({hash:e,signature:t}))}class en extends Re{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class tn extends Re{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,{name:"PositionOutOfBoundsError"})}}class nn extends Re{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,{name:"RecursiveReadLimitExceededError"})}}const sn={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new nn({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new tn({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new en({offset:e});const t=this.position-e;this.assertPosition(t);this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new en({offset:e});const t=this.position+e;this.assertPosition(t);this.position=t},inspectByte(e){const t=e??this.position;this.assertPosition(t);return this.bytes[t]},inspectBytes(e,t){const n=t??this.position;this.assertPosition(n+e-1);return this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;this.assertPosition(t);return this.bytes[t]},inspectUint16(e){const t=e??this.position;this.assertPosition(t+1);return this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;this.assertPosition(t+2);return(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;this.assertPosition(t+3);return this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position);this.bytes[this.position]=e;this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1);this.bytes.set(e,this.position);this.position+=e.length},pushUint8(e){this.assertPosition(this.position);this.bytes[this.position]=e;this.position++},pushUint16(e){this.assertPosition(this.position+1);this.dataView.setUint16(this.position,e);this.position+=2},pushUint24(e){this.assertPosition(this.position+2);this.dataView.setUint16(this.position,e>>8);this.dataView.setUint8(this.position+2,255&e);this.position+=3},pushUint32(e){this.assertPosition(this.position+3);this.dataView.setUint32(this.position,e);this.position+=4},readByte(){this.assertReadLimit();this._touch();const e=this.inspectByte();this.position++;return e},readBytes(e,t){this.assertReadLimit();this._touch();const n=this.inspectBytes(e);this.position+=t??e;return n},readUint8(){this.assertReadLimit();this._touch();const e=this.inspectUint8();this.position+=1;return e},readUint16(){this.assertReadLimit();this._touch();const e=this.inspectUint16();this.position+=2;return e},readUint24(){this.assertReadLimit();this._touch();const e=this.inspectUint24();this.position+=3;return e},readUint32(){this.assertReadLimit();this._touch();const e=this.inspectUint32();this.position+=4;return e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;this.assertPosition(e);this.position=e;return()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1);e>0&&this.recursiveReadCount++}};function createCursor(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(sn);n.bytes=e;n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength);n.positionReadCount=new Map;n.recursiveReadLimit=t;return n}function toRlp(e,t="hex"){const n=getEncodable(e);const s=createCursor(new Uint8Array(n.length));n.encode(s);return"hex"===t?bytesToHex$1(s.bytes):s.bytes}function getEncodable(e){return Array.isArray(e)?getEncodableList(e.map(e=>getEncodable(e))):getEncodableBytes(e)}function getEncodableList(e){const t=e.reduce((e,t)=>e+t.length,0);const n=getSizeOfLength(t);const s=(()=>t<=55?1+t:1+n+t)();return{length:s,encode(s){if(t<=55)s.pushByte(192+t);else{s.pushByte(247+n);1===n?s.pushUint8(t):2===n?s.pushUint16(t):3===n?s.pushUint24(t):s.pushUint32(t)}for(const{encode:t}of e)t(s)}}}function getEncodableBytes(e){const t="string"==typeof e?hexToBytes$1(e):e;const n=getSizeOfLength(t.length);const s=(()=>1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length)();return{length:s,encode(e){if(1===t.length&&t[0]<128)e.pushBytes(t);else if(t.length<=55){e.pushByte(128+t.length);e.pushBytes(t)}else{e.pushByte(183+n);1===n?e.pushUint8(t.length):2===n?e.pushUint16(t.length):3===n?e.pushUint24(t.length):e.pushUint32(t.length);e.pushBytes(t)}}}}function getSizeOfLength(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new Re("Length is too large.")}function hashAuthorization(e){const{chainId:t,nonce:n,to:s}=e;const r=e.contractAddress??e.address;const o=keccak256$1(concatHex(["0x05",toRlp([t?numberToHex(t):"0x",r,n?numberToHex(n):"0x"])]));return"bytes"===s?hexToBytes$1(o):o}async function recoverAuthorizationAddress(e){const{authorization:t,signature:n}=e;return recoverAddress({hash:hashAuthorization(t),signature:n??t})}class rn extends Re{constructor({blockNumber:e,chain:t,contract:n}){super(`Chain "${t.name}" does not support contract "${n.name}".`,{metaMessages:["This could be due to any of the following:",...e&&n.blockCreated&&n.blockCreated>e?[`- The contract "${n.name}" was not deployed until block ${n.blockCreated} (current block ${e}).`]:[`- The chain does not have the contract "${n.name}" configured.`]],name:"ChainDoesNotSupportContract"})}}class on extends Re{constructor({chain:e,currentChainId:t}){super(`The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e.id} – ${e.name}`],name:"ChainMismatchError"})}}class an extends Re{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n"),{name:"ChainNotFoundError"})}}class cn extends Re{constructor(){super("No chain was provided to the Client.",{name:"ClientChainNotConfiguredError"})}}function assertCurrentChain({chain:e,currentChainId:t}){if(!e)throw new an;if(t!==e.id)throw new on({chain:e,currentChainId:t})}const un={gwei:9,wei:18};const ln={ether:-9,wei:9};const dn={ether:-18,gwei:-9};function formatUnits(e,t){let n=e.toString();const s=n.startsWith("-");s&&(n=n.slice(1));n=n.padStart(t,"0");let[r,o]=[n.slice(0,n.length-t),n.slice(n.length-t)];o=o.replace(/(0+)$/,"");return`${s?"-":""}${r||"0"}${o?`.${o}`:""}`}function formatGwei(e,t="wei"){return formatUnits(e,ln[t])}class hn extends Re{constructor({cause:e,message:t}={}){const n=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`,{cause:e,name:"ExecutionRevertedError"})}}Object.defineProperty(hn,"code",{enumerable:!0,configurable:!0,writable:!0,value:3});Object.defineProperty(hn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class pn extends Re{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${formatGwei(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e,name:"FeeCapTooHighError"})}}Object.defineProperty(pn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class mn extends Re{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${formatGwei(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e,name:"FeeCapTooLowError"})}}Object.defineProperty(mn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class gn extends Re{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e,name:"NonceTooHighError"})}}Object.defineProperty(gn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class yn extends Re{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e,name:"NonceTooLowError"})}}Object.defineProperty(yn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class bn extends Re{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e,name:"NonceMaxValueError"})}}Object.defineProperty(bn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class wn extends Re{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(wn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class vn extends Re{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(vn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class xn extends Re{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(xn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class Pn extends Re{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(Pn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class $n extends Re{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:n}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${formatGwei(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${formatGwei(n)} gwei`:""}).`].join("\n"),{cause:e,name:"TipAboveFeeCapError"})}}Object.defineProperty($n,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class En extends Re{constructor({cause:e}){super(`An error occurred while executing: ${e?.shortMessage}`,{cause:e,name:"UnknownNodeError"})}}function formatEther(e,t="wei"){return formatUnits(e,un[t])}function prettyPrint(e){const t=Object.entries(e).map(([e,t])=>void 0===t||!1===t?null:[e,t]).filter(Boolean);const n=t.reduce((e,[t])=>Math.max(e,t.length),0);return t.map(([e,t])=>`  ${`${e}:`.padEnd(n+1)}  ${t}`).join("\n")}class An extends Re{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n"),{name:"FeeConflictError"})}}class Tn extends Re{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",prettyPrint(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}class In extends Re{constructor(e,{account:t,docsPath:n,chain:s,data:r,gas:o,gasPrice:a,maxFeePerGas:i,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const f=prettyPrint({chain:s&&`${s?.name} (id: ${s?.id})`,from:t?.address,to:l,value:"undefined"!=typeof d&&`${formatEther(d)} ${s?.nativeCurrency?.symbol||"ETH"}`,data:r,gas:o,gasPrice:"undefined"!=typeof a&&`${formatGwei(a)} gwei`,maxFeePerGas:"undefined"!=typeof i&&`${formatGwei(i)} gwei`,maxPriorityFeePerGas:"undefined"!=typeof c&&`${formatGwei(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Request Arguments:",f].filter(Boolean),name:"TransactionExecutionError"});Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.cause=e}}class Sn extends Re{constructor({blockHash:e,blockNumber:t,blockTag:n,hash:s,index:r}){let o="Transaction";n&&void 0!==r&&(o=`Transaction at block time "${n}" at index "${r}"`);e&&void 0!==r&&(o=`Transaction at block hash "${e}" at index "${r}"`);t&&void 0!==r&&(o=`Transaction at block number "${t}" at index "${r}"`);s&&(o=`Transaction with hash "${s}"`);super(`${o} could not be found.`,{name:"TransactionNotFoundError"})}}class kn extends Re{constructor({hash:e}){super(`Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class Bn extends Re{constructor({hash:e}){super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}const stringify$1=(e,t,n)=>JSON.stringify(e,(e,t)=>{const n="bigint"==typeof t?t.toString():t;return n},n);const getContractAddress=e=>e;const getUrl=e=>e;class Cn extends Re{constructor({body:e,cause:t,details:n,headers:s,status:r,url:o}){super("HTTP request failed.",{cause:t,details:n,metaMessages:[r&&`Status: ${r}`,`URL: ${getUrl(o)}`,e&&`Request body: ${stringify$1(e)}`].filter(Boolean),name:"HttpRequestError"});Object.defineProperty(this,"body",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.body=e;this.headers=s;this.status=r;this.url=o}}class On extends Re{constructor({body:e,error:t,url:n}){super("RPC Request failed.",{cause:t,details:t.message,metaMessages:[`URL: ${getUrl(n)}`,`Request body: ${stringify$1(e)}`],name:"RpcRequestError"});Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.code=t.code;this.data=t.data}}class Fn extends Re{constructor({body:e,url:t}){super("The request took too long to respond.",{details:"The request timed out.",metaMessages:[`URL: ${getUrl(t)}`,`Request body: ${stringify$1(e)}`],name:"TimeoutError"})}}const Nn=-1;class Rn extends Re{constructor(e,{code:t,docsPath:n,metaMessages:s,name:r,shortMessage:o}){super(o,{cause:e,docsPath:n,metaMessages:s||e?.metaMessages,name:r||"RpcError"});Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.name=r||e.name;this.code=e instanceof On?e.code:t??Nn}}class Mn extends Rn{constructor(e,t){super(e,t);Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.data=t.data}}class zn extends Rn{constructor(e){super(e,{code:zn.code,name:"ParseRpcError",shortMessage:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."})}}Object.defineProperty(zn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32700});class jn extends Rn{constructor(e){super(e,{code:jn.code,name:"InvalidRequestRpcError",shortMessage:"JSON is not a valid request object."})}}Object.defineProperty(jn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32600});class qn extends Rn{constructor(e,{method:t}={}){super(e,{code:qn.code,name:"MethodNotFoundRpcError",shortMessage:`The method${t?` "${t}"`:""} does not exist / is not available.`})}}Object.defineProperty(qn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32601});class Ln extends Rn{constructor(e){super(e,{code:Ln.code,name:"InvalidParamsRpcError",shortMessage:["Invalid parameters were provided to the RPC method.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Ln,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32602});class Hn extends Rn{constructor(e){super(e,{code:Hn.code,name:"InternalRpcError",shortMessage:"An internal error was received."})}}Object.defineProperty(Hn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32603});class Un extends Rn{constructor(e){super(e,{code:Un.code,name:"InvalidInputRpcError",shortMessage:["Missing or invalid parameters.","Double check you have provided the correct parameters."].join("\n")})}}Object.defineProperty(Un,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32e3});class _n extends Rn{constructor(e){super(e,{code:_n.code,name:"ResourceNotFoundRpcError",shortMessage:"Requested resource not found."});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ResourceNotFoundRpcError"})}}Object.defineProperty(_n,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32001});class Dn extends Rn{constructor(e){super(e,{code:Dn.code,name:"ResourceUnavailableRpcError",shortMessage:"Requested resource not available."})}}Object.defineProperty(Dn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32002});class Gn extends Rn{constructor(e){super(e,{code:Gn.code,name:"TransactionRejectedRpcError",shortMessage:"Transaction creation failed."})}}Object.defineProperty(Gn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32003});class Wn extends Rn{constructor(e,{method:t}={}){super(e,{code:Wn.code,name:"MethodNotSupportedRpcError",shortMessage:`Method${t?` "${t}"`:""} is not supported.`})}}Object.defineProperty(Wn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32004});class Vn extends Rn{constructor(e){super(e,{code:Vn.code,name:"LimitExceededRpcError",shortMessage:"Request exceeds defined limit."})}}Object.defineProperty(Vn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32005});class Kn extends Rn{constructor(e){super(e,{code:Kn.code,name:"JsonRpcVersionUnsupportedError",shortMessage:"Version of JSON-RPC protocol is not supported."})}}Object.defineProperty(Kn,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32006});class Qn extends Mn{constructor(e){super(e,{code:Qn.code,name:"UserRejectedRequestError",shortMessage:"User rejected the request."})}}Object.defineProperty(Qn,"code",{enumerable:!0,configurable:!0,writable:!0,value:4001});class Zn extends Mn{constructor(e){super(e,{code:Zn.code,name:"UnauthorizedProviderError",shortMessage:"The requested method and/or account has not been authorized by the user."})}}Object.defineProperty(Zn,"code",{enumerable:!0,configurable:!0,writable:!0,value:4100});class Jn extends Mn{constructor(e,{method:t}={}){super(e,{code:Jn.code,name:"UnsupportedProviderMethodError",shortMessage:`The Provider does not support the requested method${t?` " ${t}"`:""}.`})}}Object.defineProperty(Jn,"code",{enumerable:!0,configurable:!0,writable:!0,value:4200});class Yn extends Mn{constructor(e){super(e,{code:Yn.code,name:"ProviderDisconnectedError",shortMessage:"The Provider is disconnected from all chains."})}}Object.defineProperty(Yn,"code",{enumerable:!0,configurable:!0,writable:!0,value:4900});class Xn extends Mn{constructor(e){super(e,{code:Xn.code,name:"ChainDisconnectedError",shortMessage:"The Provider is not connected to the requested chain."})}}Object.defineProperty(Xn,"code",{enumerable:!0,configurable:!0,writable:!0,value:4901});class es extends Mn{constructor(e){super(e,{code:es.code,name:"SwitchChainError",shortMessage:"An error occurred when attempting to switch chain."})}}Object.defineProperty(es,"code",{enumerable:!0,configurable:!0,writable:!0,value:4902});class ts extends Mn{constructor(e){super(e,{code:ts.code,name:"UnsupportedNonOptionalCapabilityError",shortMessage:"This Wallet does not support a capability that was not marked as optional."})}}Object.defineProperty(ts,"code",{enumerable:!0,configurable:!0,writable:!0,value:5700});class ns extends Mn{constructor(e){super(e,{code:ns.code,name:"UnsupportedChainIdError",shortMessage:"This Wallet does not support the requested chain ID."})}}Object.defineProperty(ns,"code",{enumerable:!0,configurable:!0,writable:!0,value:5710});class ss extends Mn{constructor(e){super(e,{code:ss.code,name:"DuplicateIdError",shortMessage:"There is already a bundle submitted with this ID."})}}Object.defineProperty(ss,"code",{enumerable:!0,configurable:!0,writable:!0,value:5720});class rs extends Mn{constructor(e){super(e,{code:rs.code,name:"UnknownBundleIdError",shortMessage:"This bundle id is unknown / has not been submitted"})}}Object.defineProperty(rs,"code",{enumerable:!0,configurable:!0,writable:!0,value:5730});class os extends Mn{constructor(e){super(e,{code:os.code,name:"BundleTooLargeError",shortMessage:"The call bundle is too large for the Wallet to process."})}}Object.defineProperty(os,"code",{enumerable:!0,configurable:!0,writable:!0,value:5740});class as extends Mn{constructor(e){super(e,{code:as.code,name:"AtomicReadyWalletRejectedUpgradeError",shortMessage:"The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."})}}Object.defineProperty(as,"code",{enumerable:!0,configurable:!0,writable:!0,value:5750});class cs extends Mn{constructor(e){super(e,{code:cs.code,name:"AtomicityNotSupportedError",shortMessage:"The wallet does not support atomic execution but the request requires it."})}}Object.defineProperty(cs,"code",{enumerable:!0,configurable:!0,writable:!0,value:5760});class us extends Rn{constructor(e){super(e,{name:"UnknownRpcError",shortMessage:"An unknown RPC error occurred."})}}function getNodeError(e,t){const n=(e.details||"").toLowerCase();const s=e instanceof Re?e.walk(e=>e?.code===hn.code):e;return s instanceof Re?new hn({cause:e,message:s.details}):hn.nodeMessage.test(n)?new hn({cause:e,message:e.details}):pn.nodeMessage.test(n)?new pn({cause:e,maxFeePerGas:t?.maxFeePerGas}):mn.nodeMessage.test(n)?new mn({cause:e,maxFeePerGas:t?.maxFeePerGas}):gn.nodeMessage.test(n)?new gn({cause:e,nonce:t?.nonce}):yn.nodeMessage.test(n)?new yn({cause:e,nonce:t?.nonce}):bn.nodeMessage.test(n)?new bn({cause:e,nonce:t?.nonce}):wn.nodeMessage.test(n)?new wn({cause:e}):vn.nodeMessage.test(n)?new vn({cause:e,gas:t?.gas}):xn.nodeMessage.test(n)?new xn({cause:e,gas:t?.gas}):Pn.nodeMessage.test(n)?new Pn({cause:e}):$n.nodeMessage.test(n)?new $n({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new En({cause:e})}function getTransactionError(e,{docsPath:t,...n}){const s=(()=>{const t=getNodeError(e,n);return t instanceof En?e:t})();return new In(s,{docsPath:t,...n})}function extract(e,{format:t}){if(!t)return{};const n={};function extract_(t){const s=Object.keys(t);for(const r of s){r in e&&(n[r]=e[r]);t[r]&&"object"==typeof t[r]&&!Array.isArray(t[r])&&extract_(t[r])}}const s=t(e||{});extract_(s);return n}const ls={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function formatTransactionRequest(e){const t={};"undefined"!=typeof e.authorizationList&&(t.authorizationList=formatAuthorizationList$1(e.authorizationList));"undefined"!=typeof e.accessList&&(t.accessList=e.accessList);"undefined"!=typeof e.blobVersionedHashes&&(t.blobVersionedHashes=e.blobVersionedHashes);"undefined"!=typeof e.blobs&&("string"!=typeof e.blobs[0]?t.blobs=e.blobs.map(e=>bytesToHex$1(e)):t.blobs=e.blobs);"undefined"!=typeof e.data&&(t.data=e.data);"undefined"!=typeof e.from&&(t.from=e.from);"undefined"!=typeof e.gas&&(t.gas=numberToHex(e.gas));"undefined"!=typeof e.gasPrice&&(t.gasPrice=numberToHex(e.gasPrice));"undefined"!=typeof e.maxFeePerBlobGas&&(t.maxFeePerBlobGas=numberToHex(e.maxFeePerBlobGas));"undefined"!=typeof e.maxFeePerGas&&(t.maxFeePerGas=numberToHex(e.maxFeePerGas));"undefined"!=typeof e.maxPriorityFeePerGas&&(t.maxPriorityFeePerGas=numberToHex(e.maxPriorityFeePerGas));"undefined"!=typeof e.nonce&&(t.nonce=numberToHex(e.nonce));"undefined"!=typeof e.to&&(t.to=e.to);"undefined"!=typeof e.type&&(t.type=ls[e.type]);"undefined"!=typeof e.value&&(t.value=numberToHex(e.value));return t}function formatAuthorizationList$1(e){return e.map(e=>({address:e.address,r:e.r?numberToHex(BigInt(e.r)):e.r,s:e.s?numberToHex(BigInt(e.s)):e.s,chainId:numberToHex(e.chainId),nonce:numberToHex(e.nonce),..."undefined"!=typeof e.yParity?{yParity:numberToHex(e.yParity)}:{},..."undefined"!=typeof e.v&&"undefined"==typeof e.yParity?{v:numberToHex(e.v)}:{}}))}function getAction$1(e,t,n){const s=e[t.name];if("function"==typeof s)return s;const r=e[n];return"function"==typeof r?r:n=>t(e,n)}const ds=2n**256n-1n;function assertRequest(e){const{account:t,gasPrice:n,maxFeePerGas:s,maxPriorityFeePerGas:r,to:o}=e;const a=t?parseAccount(t):void 0;if(a&&!isAddress(a.address))throw new bt({address:a.address});if(o&&!isAddress(o))throw new bt({address:o});if("undefined"!=typeof n&&("undefined"!=typeof s||"undefined"!=typeof r))throw new An;if(s&&s>ds)throw new pn({maxFeePerGas:s});if(r&&s&&r>s)throw new $n({maxFeePerGas:s,maxPriorityFeePerGas:r})}async function getChainId$1(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return hexToNumber$1(t)}class hs extends Re{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class fs extends Re{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class ps extends Re{constructor({maxPriorityFeePerGas:e}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(e)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class ms extends Re{constructor({blockHash:e,blockNumber:t}){let n="Block";e&&(n=`Block at hash "${e}"`);t&&(n=`Block at number "${t}"`);super(`${n} could not be found.`,{name:"BlockNotFoundError"})}}const gs={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function formatTransaction(e){const t={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?hexToNumber$1(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?hexToNumber$1(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?gs[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};e.authorizationList&&(t.authorizationList=formatAuthorizationList(e.authorizationList));t.yParity=(()=>{if(e.yParity)return Number(e.yParity);if("bigint"==typeof t.v){if(0n===t.v||27n===t.v)return 0;if(1n===t.v||28n===t.v)return 1;if(t.v>=35n)return t.v%2n==0n?1:0}})();if("legacy"===t.type){delete t.accessList;delete t.maxFeePerBlobGas;delete t.maxFeePerGas;delete t.maxPriorityFeePerGas;delete t.yParity}if("eip2930"===t.type){delete t.maxFeePerBlobGas;delete t.maxFeePerGas;delete t.maxPriorityFeePerGas}"eip1559"===t.type&&delete t.maxFeePerBlobGas;return t}function formatAuthorizationList(e){return e.map(e=>({address:e.address,chainId:Number(e.chainId),nonce:Number(e.nonce),r:e.r,s:e.s,yParity:Number(e.yParity)}))}function formatBlock(e){const t=(e.transactions??[]).map(e=>"string"==typeof e?e:formatTransaction(e));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:t,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function getBlock(e,{blockHash:t,blockNumber:n,blockTag:s=e.experimental_blockTag??"latest",includeTransactions:r}={}){const o=r??!1;const a=void 0!==n?numberToHex(n):void 0;let i=null;i=t?await e.request({method:"eth_getBlockByHash",params:[t,o]},{dedupe:!0}):await e.request({method:"eth_getBlockByNumber",params:[a||s,o]},{dedupe:Boolean(a)});if(!i)throw new ms({blockHash:t,blockNumber:n});const c=e.chain?.formatters?.block?.format||formatBlock;return c(i)}async function getGasPrice(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function estimateMaxPriorityFeePerGas(e,t){return internal_estimateMaxPriorityFeePerGas(e,t)}async function internal_estimateMaxPriorityFeePerGas(e,t){const{block:n,chain:s=e.chain,request:r}=t||{};try{const t=s?.fees?.maxPriorityFeePerGas??s?.fees?.defaultPriorityFee;if("function"==typeof t){const s=n||await getAction$1(e,getBlock,"getBlock")({});const o=await t({block:s,client:e,request:r});if(null===o)throw new Error;return o}if("undefined"!=typeof t)return t;const o=await e.request({method:"eth_maxPriorityFeePerGas"});return hexToBigInt(o)}catch{const[t,s]=await Promise.all([n?Promise.resolve(n):getAction$1(e,getBlock,"getBlock")({}),getAction$1(e,getGasPrice,"getGasPrice")({})]);if("bigint"!=typeof t.baseFeePerGas)throw new fs;const r=s-t.baseFeePerGas;return r<0n?0n:r}}async function estimateFeesPerGas(e,t){return internal_estimateFeesPerGas(e,t)}async function internal_estimateFeesPerGas(e,t){const{block:n,chain:s=e.chain,request:r,type:o="eip1559"}=t||{};const a=await(async()=>"function"==typeof s?.fees?.baseFeeMultiplier?s.fees.baseFeeMultiplier({block:n,client:e,request:r}):s?.fees?.baseFeeMultiplier??1.2)();if(a<1)throw new hs;const i=a.toString().split(".")[1]?.length??0;const c=10**i;const multiply=e=>e*BigInt(Math.ceil(a*c))/BigInt(c);const u=n||await getAction$1(e,getBlock,"getBlock")({});if("function"==typeof s?.fees?.estimateFeesPerGas){const t=await s.fees.estimateFeesPerGas({block:n,client:e,multiply:multiply,request:r,type:o});if(null!==t)return t}if("eip1559"===o){if("bigint"!=typeof u.baseFeePerGas)throw new fs;const t="bigint"==typeof r?.maxPriorityFeePerGas?r.maxPriorityFeePerGas:await internal_estimateMaxPriorityFeePerGas(e,{block:u,chain:s,request:r});const n=multiply(u.baseFeePerGas);const o=r?.maxFeePerGas??n+t;return{maxFeePerGas:o,maxPriorityFeePerGas:t}}const l=r?.gasPrice??multiply(await getAction$1(e,getGasPrice,"getGasPrice")({}));return{gasPrice:l}}class ys extends Re{constructor(e,{account:t,docsPath:n,chain:s,data:r,gas:o,gasPrice:a,maxFeePerGas:i,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const f=prettyPrint({from:t?.address,to:l,value:"undefined"!=typeof d&&`${formatEther(d)} ${s?.nativeCurrency?.symbol||"ETH"}`,data:r,gas:o,gasPrice:"undefined"!=typeof a&&`${formatGwei(a)} gwei`,maxFeePerGas:"undefined"!=typeof i&&`${formatGwei(i)} gwei`,maxPriorityFeePerGas:"undefined"!=typeof c&&`${formatGwei(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Estimate Gas Arguments:",f].filter(Boolean),name:"EstimateGasExecutionError"});Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.cause=e}}function getEstimateGasError(e,{docsPath:t,...n}){const s=(()=>{const t=getNodeError(e,n);return t instanceof En?e:t})();return new ys(s,{docsPath:t,...n})}class bs extends Re{constructor({address:e}){super(`State for account "${e}" is set multiple times.`,{name:"AccountStateConflictError"})}}class ws extends Re{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function prettyStateMapping(e){return e.reduce((e,{slot:t,value:n})=>`${e}        ${t}: ${n}\n`,"")}function prettyStateOverride(e){return e.reduce((e,{address:t,...n})=>{let s=`${e}    ${t}:\n`;n.nonce&&(s+=`      nonce: ${n.nonce}\n`);n.balance&&(s+=`      balance: ${n.balance}\n`);n.code&&(s+=`      code: ${n.code}\n`);if(n.state){s+="      state:\n";s+=prettyStateMapping(n.state)}if(n.stateDiff){s+="      stateDiff:\n";s+=prettyStateMapping(n.stateDiff)}return s},"  State Override:\n").slice(0,-1)}function serializeStateMapping(e){if(e&&0!==e.length)return e.reduce((e,{slot:t,value:n})=>{if(66!==t.length)throw new Ue({size:t.length,targetSize:66,type:"hex"});if(66!==n.length)throw new Ue({size:n.length,targetSize:66,type:"hex"});e[t]=n;return e},{})}function serializeAccountStateOverride(e){const{balance:t,nonce:n,state:s,stateDiff:r,code:o}=e;const a={};void 0!==o&&(a.code=o);void 0!==t&&(a.balance=numberToHex(t));void 0!==n&&(a.nonce=numberToHex(n));void 0!==s&&(a.state=serializeStateMapping(s));if(void 0!==r){if(a.state)throw new ws;a.stateDiff=serializeStateMapping(r)}return a}function serializeStateOverride(e){if(!e)return;const t={};for(const{address:n,...s}of e){if(!isAddress(n,{strict:!1}))throw new bt({address:n});if(t[n])throw new bs({address:n});t[n]=serializeAccountStateOverride(s)}return t}async function getBalance$1(e,{address:t,blockNumber:n,blockTag:s=e.experimental_blockTag??"latest"}){const r="bigint"==typeof n?numberToHex(n):void 0;const o=await e.request({method:"eth_getBalance",params:[t,r||s]});return BigInt(o)}async function estimateGas$1(e,t){const{account:n=e.account}=t;const s=n?parseAccount(n):void 0;try{let estimateGas_rpc=function(t){const{block:n,request:s,rpcStateOverride:r}=t;return e.request({method:"eth_estimateGas",params:r?[s,n??e.experimental_blockTag??"latest",r]:n?[s,n]:[s]})};const{accessList:n,authorizationList:r,blobs:o,blobVersionedHashes:a,blockNumber:i,blockTag:c,data:u,gas:l,gasPrice:d,maxFeePerBlobGas:f,maxFeePerGas:p,maxPriorityFeePerGas:m,nonce:g,value:y,stateOverride:b,...w}=await prepareTransactionRequest$1(e,{...t,parameters:"local"===s?.type?void 0:["blobVersionedHashes"]});const v="bigint"==typeof i?numberToHex(i):void 0;const x=v||c;const P=serializeStateOverride(b);const $=await(async()=>w.to?w.to:r&&r.length>0?await recoverAuthorizationAddress({authorization:r[0]}).catch(()=>{throw new Re("`to` is required. Could not infer from `authorizationList`")}):void 0)();assertRequest(t);const E=e.chain?.formatters?.transactionRequest?.format;const A=E||formatTransactionRequest;const T=A({...extract(w,{format:E}),from:s?.address,accessList:n,authorizationList:r,blobs:o,blobVersionedHashes:a,data:u,gas:l,gasPrice:d,maxFeePerBlobGas:f,maxFeePerGas:p,maxPriorityFeePerGas:m,nonce:g,to:$,value:y});let I=BigInt(await estimateGas_rpc({block:x,request:T,rpcStateOverride:P}));if(r){const t=await getBalance$1(e,{address:T.from});const n=await Promise.all(r.map(async e=>{const{address:n}=e;const r=await estimateGas_rpc({block:x,request:{authorizationList:void 0,data:u,from:s?.address,to:n,value:numberToHex(t)},rpcStateOverride:P}).catch(()=>100000n);return 2n*BigInt(r)}));I+=n.reduce((e,t)=>e+t,0n)}return I}catch(r){throw getEstimateGasError(r,{...t,account:s,chain:e.chain})}}async function getTransactionCount(e,{address:t,blockTag:n="latest",blockNumber:s}){const r=await e.request({method:"eth_getTransactionCount",params:[t,"bigint"==typeof s?numberToHex(s):n]},{dedupe:Boolean(s)});return hexToNumber$1(r)}function blobsToCommitments(e){const{kzg:t}=e;const n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes");const s="string"==typeof e.blobs[0]?e.blobs.map(e=>hexToBytes$1(e)):e.blobs;const r=[];for(const o of s)r.push(Uint8Array.from(t.blobToKzgCommitment(o)));return"bytes"===n?r:r.map(e=>bytesToHex$1(e))}function blobsToProofs(e){const{kzg:t}=e;const n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes");const s="string"==typeof e.blobs[0]?e.blobs.map(e=>hexToBytes$1(e)):e.blobs;const r="string"==typeof e.commitments[0]?e.commitments.map(e=>hexToBytes$1(e)):e.commitments;const o=[];for(let a=0;a<s.length;a++){const e=s[a];const n=r[a];o.push(Uint8Array.from(t.computeBlobKzgProof(e,n)))}return"bytes"===n?o:o.map(e=>bytesToHex$1(e))}function setBigUint64(e,t,n,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,s);const r=BigInt(32);const o=BigInt(4294967295);const a=Number(n>>r&o);const i=Number(n&o);const c=s?4:0;const u=s?0:4;e.setUint32(t+c,a,s);e.setUint32(t+u,i,s)}function Chi(e,t,n){return e&t^~e&n}function Maj(e,t,n){return e&t^e&n^t&n}class vs extends St{constructor(e,t,n,s){super();this.finished=!1;this.length=0;this.pos=0;this.destroyed=!1;this.blockLen=e;this.outputLen=t;this.padOffset=n;this.isLE=s;this.buffer=new Uint8Array(e);this.view=createView(this.buffer)}update(e){aexists$1(this);e=toBytes$1(e);abytes$1(e);const{view:t,buffer:n,blockLen:s}=this;const r=e.length;for(let o=0;o<r;){const a=Math.min(s-this.pos,r-o);if(a===s){const t=createView(e);for(;s<=r-o;o+=s)this.process(t,o);continue}n.set(e.subarray(o,o+a),this.pos);this.pos+=a;o+=a;if(this.pos===s){this.process(t,0);this.pos=0}}this.length+=e.length;this.roundClean();return this}digestInto(e){aexists$1(this);aoutput$1(e,this);this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:r}=this;let{pos:o}=this;t[o++]=128;clean$1(this.buffer.subarray(o));if(this.padOffset>s-o){this.process(n,0);o=0}for(let l=o;l<s;l++)t[l]=0;setBigUint64(n,s-8,BigInt(8*this.length),r);this.process(n,0);const a=createView(e);const i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=i/4;const u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<c;l++)a.setUint32(4*l,u[l],r)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);this.destroy();return n}_cloneInto(e){e||(e=new this.constructor);e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:r,destroyed:o,pos:a}=this;e.destroyed=o;e.finished=r;e.length=s;e.pos=a;s%t&&e.buffer.set(n);return e}clone(){return this._cloneInto()}}const xs=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const Ps=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const $s=new Uint32Array(64);class Es extends vs{constructor(e=32){super(64,e,8,!1);this.A=0|xs[0];this.B=0|xs[1];this.C=0|xs[2];this.D=0|xs[3];this.E=0|xs[4];this.F=0|xs[5];this.G=0|xs[6];this.H=0|xs[7]}get(){const{A:e,B:t,C:n,D:s,E:r,F:o,G:a,H:i}=this;return[e,t,n,s,r,o,a,i]}set(e,t,n,s,r,o,a,i){this.A=0|e;this.B=0|t;this.C=0|n;this.D=0|s;this.E=0|r;this.F=0|o;this.G=0|a;this.H=0|i}process(e,t){for(let l=0;l<16;l++,t+=4)$s[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){const e=$s[l-15];const t=$s[l-2];const n=rotr(e,7)^rotr(e,18)^e>>>3;const s=rotr(t,17)^rotr(t,19)^t>>>10;$s[l]=s+$s[l-7]+n+$s[l-16]|0}let{A:n,B:s,C:r,D:o,E:a,F:i,G:c,H:u}=this;for(let l=0;l<64;l++){const e=rotr(a,6)^rotr(a,11)^rotr(a,25);const t=u+e+Chi(a,i,c)+Ps[l]+$s[l]|0;const d=rotr(n,2)^rotr(n,13)^rotr(n,22);const f=d+Maj(n,s,r)|0;u=c;c=i;i=a;a=o+t|0;o=r;r=s;s=n;n=t+f|0}n=n+this.A|0;s=s+this.B|0;r=r+this.C|0;o=o+this.D|0;a=a+this.E|0;i=i+this.F|0;c=c+this.G|0;u=u+this.H|0;this.set(n,s,r,o,a,i,c,u)}roundClean(){clean$1($s)}destroy(){this.set(0,0,0,0,0,0,0,0);clean$1(this.buffer)}}const As=createHasher$1(()=>new Es);const Ts=As;function sha256(e,t){const n=Ts(isHex(e,{strict:!1})?toBytes$2(e):e);return n}function commitmentToVersionedHash(e){const{commitment:t,version:n=1}=e;const s=e.to??("string"==typeof t?"hex":"bytes");const r=sha256(t);r.set([n],0);return"bytes"===s?r:bytesToHex$1(r)}function commitmentsToVersionedHashes(e){const{commitments:t,version:n}=e;const s=e.to;const r=[];for(const o of t)r.push(commitmentToVersionedHash({commitment:o,to:s,version:n}));return r}const Is=6;const Ss=32;const ks=4096;const Bs=Ss*ks;const Cs=Bs*Is-1-1*ks*Is;class Os extends Re{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`],name:"BlobSizeTooLargeError"})}}class Fs extends Re{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}function toBlobs(e){const t="string"==typeof e.data?hexToBytes$1(e.data):e.data;const n=size$4(t);if(!n)throw new Fs;if(n>Cs)throw new Os({maxSize:Cs,size:n});const s=[];let r=!0;let o=0;for(;r;){const e=createCursor(new Uint8Array(Bs));let n=0;for(;n<ks;){const s=t.slice(o,o+(Ss-1));e.pushByte(0);e.pushBytes(s);if(s.length<31){e.pushByte(128);r=!1;break}n++;o+=31}s.push(e)}return s.map(e=>bytesToHex$1(e.bytes))}function toBlobSidecars(e){const{data:t,kzg:n,to:s}=e;const r=e.blobs??toBlobs({data:t});const o=e.commitments??blobsToCommitments({blobs:r,kzg:n,to:s});const a=e.proofs??blobsToProofs({blobs:r,commitments:o,kzg:n,to:s});const i=[];for(let c=0;c<r.length;c++)i.push({blob:r[c],commitment:o[c],proof:a[c]});return i}function getTransactionType(e){if(e.type)return e.type;if("undefined"!=typeof e.authorizationList)return"eip7702";if("undefined"!=typeof e.blobs||"undefined"!=typeof e.blobVersionedHashes||"undefined"!=typeof e.maxFeePerBlobGas||"undefined"!=typeof e.sidecars)return"eip4844";if("undefined"!=typeof e.maxFeePerGas||"undefined"!=typeof e.maxPriorityFeePerGas)return"eip1559";if("undefined"!=typeof e.gasPrice)return"undefined"!=typeof e.accessList?"eip2930":"legacy";throw new Tn({transaction:e})}const Ns=["blobVersionedHashes","chainId","fees","gas","nonce","type"];const Rs=new Map;async function prepareTransactionRequest$1(e,t){const{account:n=e.account,blobs:s,chain:r,gas:o,kzg:a,nonce:i,nonceManager:c,parameters:u=Ns,type:l}=t;const d=n?parseAccount(n):n;const f={...t,...d?{from:d?.address}:{}};let p;async function getBlock$1(){if(p)return p;p=await getAction$1(e,getBlock,"getBlock")({blockTag:"latest"});return p}let m;async function getChainId2(){if(m)return m;if(r)return r.id;if("undefined"!=typeof t.chainId)return t.chainId;const n=await getAction$1(e,getChainId$1,"getChainId")({});m=n;return m}if(u.includes("nonce")&&"undefined"==typeof i&&d)if(c){const t=await getChainId2();f.nonce=await c.consume({address:d.address,chainId:t,client:e})}else f.nonce=await getAction$1(e,getTransactionCount,"getTransactionCount")({address:d.address,blockTag:"pending"});if((u.includes("blobVersionedHashes")||u.includes("sidecars"))&&s&&a){const e=blobsToCommitments({blobs:s,kzg:a});if(u.includes("blobVersionedHashes")){const t=commitmentsToVersionedHashes({commitments:e,to:"hex"});f.blobVersionedHashes=t}if(u.includes("sidecars")){const t=blobsToProofs({blobs:s,commitments:e,kzg:a});const n=toBlobSidecars({blobs:s,commitments:e,proofs:t,to:"hex"});f.sidecars=n}}u.includes("chainId")&&(f.chainId=await getChainId2());if((u.includes("fees")||u.includes("type"))&&"undefined"==typeof l)try{f.type=getTransactionType(f)}catch{let t=Rs.get(e.uid);if("undefined"==typeof t){const n=await getBlock$1();t="bigint"==typeof n?.baseFeePerGas;Rs.set(e.uid,t)}f.type=t?"eip1559":"legacy"}if(u.includes("fees"))if("legacy"!==f.type&&"eip2930"!==f.type){if("undefined"==typeof f.maxFeePerGas||"undefined"==typeof f.maxPriorityFeePerGas){const n=await getBlock$1();const{maxFeePerGas:s,maxPriorityFeePerGas:o}=await internal_estimateFeesPerGas(e,{block:n,chain:r,request:f});if("undefined"==typeof t.maxPriorityFeePerGas&&t.maxFeePerGas&&t.maxFeePerGas<o)throw new ps({maxPriorityFeePerGas:o});f.maxPriorityFeePerGas=o;f.maxFeePerGas=s}}else{if("undefined"!=typeof t.maxFeePerGas||"undefined"!=typeof t.maxPriorityFeePerGas)throw new fs;if("undefined"==typeof t.gasPrice){const t=await getBlock$1();const{gasPrice:n}=await internal_estimateFeesPerGas(e,{block:t,chain:r,request:f,type:"legacy"});f.gasPrice=n}}u.includes("gas")&&"undefined"==typeof o&&(f.gas=await getAction$1(e,estimateGas$1,"estimateGas")({...f,account:d?{address:d.address,type:"json-rpc"}:d}));assertRequest(f);delete f.parameters;return f}async function sendRawTransaction(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const Ms=new wt(128);async function sendTransaction$1(e,t){const{account:n=e.account,chain:s=e.chain,accessList:r,authorizationList:o,blobs:a,data:i,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:f,nonce:p,type:m,value:g,...y}=t;if("undefined"==typeof n)throw new Zt({docsPath:"/docs/actions/wallet/sendTransaction"});const b=n?parseAccount(n):null;try{assertRequest(t);const n=await(async()=>t.to?t.to:null!==t.to&&o&&o.length>0?await recoverAuthorizationAddress({authorization:o[0]}).catch(()=>{throw new Re("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if("json-rpc"===b?.type||null===b){let t;if(null!==s){t=await getAction$1(e,getChainId$1,"getChainId")({});assertCurrentChain({currentChainId:t,chain:s})}const v=e.chain?.formatters?.transactionRequest?.format;const x=v||formatTransactionRequest;const P=x({...extract(y,{format:v}),accessList:r,authorizationList:o,blobs:a,chainId:t,data:i,from:b?.address,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:f,nonce:p,to:n,type:m,value:g});const $=Ms.get(e.uid);const E=$?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:E,params:[P]},{retryCount:0})}catch(w){if(!1===$)throw w;const t=w;if("InvalidInputRpcError"===t.name||"InvalidParamsRpcError"===t.name||"MethodNotFoundRpcError"===t.name||"MethodNotSupportedRpcError"===t.name)return await e.request({method:"wallet_sendTransaction",params:[P]},{retryCount:0}).then(t=>{Ms.set(e.uid,!0);return t}).catch(n=>{const s=n;if("MethodNotFoundRpcError"===s.name||"MethodNotSupportedRpcError"===s.name){Ms.set(e.uid,!1);throw t}throw s});throw t}}if("local"===b?.type){const t=await getAction$1(e,prepareTransactionRequest$1,"prepareTransactionRequest")({account:b,accessList:r,authorizationList:o,blobs:a,chain:s,data:i,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:f,nonce:p,nonceManager:b.nonceManager,parameters:[...Ns,"sidecars"],type:m,value:g,...y,to:n});const w=s?.serializers?.transaction;const v=await b.signTransaction(t,{serializer:w});return await getAction$1(e,sendRawTransaction,"sendRawTransaction")({serializedTransaction:v})}if("smart"===b?.type)throw new Jt({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new Jt({docsPath:"/docs/actions/wallet/sendTransaction",type:b?.type})}catch(v){if(v instanceof Jt)throw v;throw getTransactionError(v,{...t,account:b,chain:t.chain||void 0})}}const zs=[{inputs:[{components:[{name:"target",type:"address"},{name:"allowFailure",type:"bool"},{name:"callData",type:"bytes"}],name:"calls",type:"tuple[]"}],name:"aggregate3",outputs:[{components:[{name:"success",type:"bool"},{name:"returnData",type:"bytes"}],name:"returnData",type:"tuple[]"}],stateMutability:"view",type:"function"}];const js=[{name:"query",type:"function",stateMutability:"view",inputs:[{type:"tuple[]",name:"queries",components:[{type:"address",name:"sender"},{type:"string[]",name:"urls"},{type:"bytes",name:"data"}]}],outputs:[{type:"bool[]",name:"failures"},{type:"bytes[]",name:"responses"}]},{name:"HttpError",type:"error",inputs:[{type:"uint16",name:"status"},{type:"string",name:"message"}]}];const qs=[{inputs:[],name:"ResolverNotFound",type:"error"},{inputs:[],name:"ResolverWildcardNotSupported",type:"error"},{inputs:[],name:"ResolverNotContract",type:"error"},{inputs:[{name:"returnData",type:"bytes"}],name:"ResolverError",type:"error"},{inputs:[{components:[{name:"status",type:"uint16"},{name:"message",type:"string"}],name:"errors",type:"tuple[]"}],name:"HttpError",type:"error"}];const Ls=[...qs,{name:"resolve",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes"},{name:"data",type:"bytes"}],outputs:[{name:"",type:"bytes"},{name:"address",type:"address"}]},{name:"resolve",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes"},{name:"data",type:"bytes"},{name:"gateways",type:"string[]"}],outputs:[{name:"",type:"bytes"},{name:"address",type:"address"}]}];const Hs=[...qs,{name:"reverse",type:"function",stateMutability:"view",inputs:[{type:"bytes",name:"reverseName"}],outputs:[{type:"string",name:"resolvedName"},{type:"address",name:"resolvedAddress"},{type:"address",name:"reverseResolver"},{type:"address",name:"resolver"}]},{name:"reverse",type:"function",stateMutability:"view",inputs:[{type:"bytes",name:"reverseName"},{type:"string[]",name:"gateways"}],outputs:[{type:"string",name:"resolvedName"},{type:"address",name:"resolvedAddress"},{type:"address",name:"reverseResolver"},{type:"address",name:"resolver"}]}];const Us=[{name:"text",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"},{name:"key",type:"string"}],outputs:[{name:"",type:"string"}]}];const _s=[{name:"addr",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"}],outputs:[{name:"",type:"address"}]},{name:"addr",type:"function",stateMutability:"view",inputs:[{name:"name",type:"bytes32"},{name:"coinType",type:"uint256"}],outputs:[{name:"",type:"bytes"}]}];const Ds=[{inputs:[{name:"_signer",type:"address"},{name:"_hash",type:"bytes32"},{name:"_signature",type:"bytes"}],stateMutability:"nonpayable",type:"constructor"},{inputs:[{name:"_signer",type:"address"},{name:"_hash",type:"bytes32"},{name:"_signature",type:"bytes"}],outputs:[{type:"bool"}],stateMutability:"nonpayable",type:"function",name:"isValidSig"}];const Gs=[{type:"event",name:"Approval",inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}]},{type:"event",name:"Transfer",inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}]},{type:"function",name:"allowance",stateMutability:"view",inputs:[{name:"owner",type:"address"},{name:"spender",type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"approve",stateMutability:"nonpayable",inputs:[{name:"spender",type:"address"},{name:"amount",type:"uint256"}],outputs:[{type:"bool"}]},{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{name:"account",type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"name",stateMutability:"view",inputs:[],outputs:[{type:"string"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:"string"}]},{type:"function",name:"totalSupply",stateMutability:"view",inputs:[],outputs:[{type:"uint256"}]},{type:"function",name:"transfer",stateMutability:"nonpayable",inputs:[{name:"recipient",type:"address"},{name:"amount",type:"uint256"}],outputs:[{type:"bool"}]},{type:"function",name:"transferFrom",stateMutability:"nonpayable",inputs:[{name:"sender",type:"address"},{name:"recipient",type:"address"},{name:"amount",type:"uint256"}],outputs:[{type:"bool"}]}];function bytesToBigInt(e,t={}){"undefined"!=typeof t.size&&assertSize$2(e,{size:t.size});const n=bytesToHex$1(e,t);return hexToBigInt(n,t)}function bytesToBool(e,t={}){let n=e;if("undefined"!=typeof t.size){assertSize$2(n,{size:t.size});n=trim(n)}if(n.length>1||n[0]>1)throw new ze(n);return Boolean(n[0])}function bytesToNumber(e,t={}){"undefined"!=typeof t.size&&assertSize$2(e,{size:t.size});const n=bytesToHex$1(e,t);return hexToNumber$1(n,t)}function bytesToString(e,t={}){let n=e;if("undefined"!=typeof t.size){assertSize$2(n,{size:t.size});n=trim(n,{dir:"right"})}return(new TextDecoder).decode(n)}function decodeAbiParameters(e,t){const n="string"==typeof t?hexToBytes$1(t):t;const s=createCursor(n);if(0===size$4(n)&&e.length>0)throw new Ze;if(size$4(t)&&size$4(t)<32)throw new Qe({data:"string"==typeof t?t:bytesToHex$1(t),params:e,size:size$4(t)});let r=0;const o=[];for(let a=0;a<e.length;++a){const t=e[a];s.setPosition(r);const[n,i]=decodeParameter(s,t,{staticPosition:0});r+=i;o.push(n)}return o}function decodeParameter(e,t,{staticPosition:n}){const s=getArrayComponents$1(t.type);if(s){const[r,o]=s;return decodeArray(e,{...t,type:o},{length:r,staticPosition:n})}if("tuple"===t.type)return decodeTuple(e,t,{staticPosition:n});if("address"===t.type)return decodeAddress(e);if("bool"===t.type)return decodeBool(e);if(t.type.startsWith("bytes"))return decodeBytes(e,t,{staticPosition:n});if(t.type.startsWith("uint")||t.type.startsWith("int"))return decodeNumber(e,t);if("string"===t.type)return decodeString(e,{staticPosition:n});throw new pt(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const Ws=32;const Vs=32;function decodeAddress(e){const t=e.readBytes(32);return[checksumAddress(bytesToHex$1(sliceBytes(t,-20))),32]}function decodeArray(e,t,{length:n,staticPosition:s}){if(!n){const n=bytesToNumber(e.readBytes(Vs));const r=s+n;const o=r+Ws;e.setPosition(r);const a=bytesToNumber(e.readBytes(Ws));const i=hasDynamicChild(t);let c=0;const u=[];for(let s=0;s<a;++s){e.setPosition(o+(i?32*s:c));const[n,r]=decodeParameter(e,t,{staticPosition:o});c+=r;u.push(n)}e.setPosition(s+32);return[u,32]}if(hasDynamicChild(t)){const r=bytesToNumber(e.readBytes(Vs));const o=s+r;const a=[];for(let s=0;s<n;++s){e.setPosition(o+32*s);const[n]=decodeParameter(e,t,{staticPosition:o});a.push(n)}e.setPosition(s+32);return[a,32]}let r=0;const o=[];for(let a=0;a<n;++a){const[n,a]=decodeParameter(e,t,{staticPosition:s+r});r+=a;o.push(n)}return[o,r]}function decodeBool(e){return[bytesToBool(e.readBytes(32),{size:32}),32]}function decodeBytes(e,t,{staticPosition:n}){const[s,r]=t.type.split("bytes");if(!r){const t=bytesToNumber(e.readBytes(32));e.setPosition(n+t);const s=bytesToNumber(e.readBytes(32));if(0===s){e.setPosition(n+32);return["0x",32]}const r=e.readBytes(s);e.setPosition(n+32);return[bytesToHex$1(r),32]}const o=bytesToHex$1(e.readBytes(Number.parseInt(r),32));return[o,32]}function decodeNumber(e,t){const n=t.type.startsWith("int");const s=Number.parseInt(t.type.split("int")[1]||"256");const r=e.readBytes(32);return[s>48?bytesToBigInt(r,{signed:n}):bytesToNumber(r,{signed:n}),32]}function decodeTuple(e,t,{staticPosition:n}){const s=0===t.components.length||t.components.some(({name:e})=>!e);const r=s?[]:{};let o=0;if(hasDynamicChild(t)){const a=bytesToNumber(e.readBytes(Vs));const i=n+a;for(let n=0;n<t.components.length;++n){const a=t.components[n];e.setPosition(i+o);const[c,u]=decodeParameter(e,a,{staticPosition:i});o+=u;r[s?n:a?.name]=c}e.setPosition(n+32);return[r,32]}for(let a=0;a<t.components.length;++a){const i=t.components[a];const[c,u]=decodeParameter(e,i,{staticPosition:n});r[s?a:i?.name]=c;o+=u}return[r,o]}function decodeString(e,{staticPosition:t}){const n=bytesToNumber(e.readBytes(32));const s=t+n;e.setPosition(s);const r=bytesToNumber(e.readBytes(32));if(0===r){e.setPosition(t+32);return["",32]}const o=e.readBytes(r,32);const a=bytesToString(trim(o));e.setPosition(t+32);return[a,32]}function hasDynamicChild(e){const{type:t}=e;if("string"===t)return!0;if("bytes"===t)return!0;if(t.endsWith("[]"))return!0;if("tuple"===t)return e.components?.some(hasDynamicChild);const n=getArrayComponents$1(e.type);return!(!n||!hasDynamicChild({...e,type:n[1]}))}const hash=e=>keccak256$1(toBytes$2(e));function hashSignature(e){return hash(e)}const Ks="1.0.8";let Qs=class e extends Error{constructor(t,n={}){const s=n.cause instanceof e?n.cause.details:n.cause?.message?n.cause.message:n.details;const r=n.cause instanceof e&&n.cause.docsPath||n.docsPath;const o=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...r?[`Docs: https://abitype.dev${r}`]:[],...s?[`Details: ${s}`]:[],`Version: abitype@${Ks}`].join("\n");super(o);Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"});n.cause&&(this.cause=n.cause);this.details=s;this.docsPath=r;this.metaMessages=n.metaMessages;this.shortMessage=t}};function execTyped(e,t){const n=e.exec(t);return n?.groups}const Zs=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;const Js=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;const Ys=/^\(.+?\).*?$/;const Xs=/^tuple(?<array>(\[(\d*)\])*)$/;function formatAbiParameter(e){let t=e.type;if(Xs.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let r=0;r<n;r++){const s=e.components[r];t+=formatAbiParameter(s);r<n-1&&(t+=", ")}const s=execTyped(Xs,e.type);t+=`)${s?.array??""}`;return formatAbiParameter({...e,type:t})}"indexed"in e&&e.indexed&&(t=`${t} indexed`);return e.name?`${t} ${e.name}`:t}function formatAbiParameters(e){let t="";const n=e.length;for(let s=0;s<n;s++){const r=e[s];t+=formatAbiParameter(r);s!==n-1&&(t+=", ")}return t}function formatAbiItem(e){return"function"===e.type?`function ${e.name}(${formatAbiParameters(e.inputs)})${e.stateMutability&&"nonpayable"!==e.stateMutability?` ${e.stateMutability}`:""}${e.outputs?.length?` returns (${formatAbiParameters(e.outputs)})`:""}`:"event"===e.type?`event ${e.name}(${formatAbiParameters(e.inputs)})`:"error"===e.type?`error ${e.name}(${formatAbiParameters(e.inputs)})`:"constructor"===e.type?`constructor(${formatAbiParameters(e.inputs)})${"payable"===e.stateMutability?" payable":""}`:"fallback"===e.type?"fallback() external"+("payable"===e.stateMutability?" payable":""):"receive() external payable"}const er=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function isErrorSignature(e){return er.test(e)}function execErrorSignature(e){return execTyped(er,e)}const tr=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function isEventSignature(e){return tr.test(e)}function execEventSignature(e){return execTyped(tr,e)}const nr=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;function isFunctionSignature(e){return nr.test(e)}function execFunctionSignature(e){return execTyped(nr,e)}const sr=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function isStructSignature(e){return sr.test(e)}function execStructSignature(e){return execTyped(sr,e)}const rr=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;function isConstructorSignature(e){return rr.test(e)}function execConstructorSignature(e){return execTyped(rr,e)}const or=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;function isFallbackSignature(e){return or.test(e)}function execFallbackSignature(e){return execTyped(or,e)}const ar=/^receive\(\) external payable$/;function isReceiveSignature(e){return ar.test(e)}const ir=new Set(["indexed"]);const cr=new Set(["calldata","memory","storage"]);class ur extends Qs{constructor({signature:e}){super("Failed to parse ABI item.",{details:`parseAbiItem(${JSON.stringify(e,null,2)})`,docsPath:"/api/human#parseabiitem-1"});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiItemError"})}}class lr extends Qs{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class dr extends Qs{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type.`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}class hr extends Qs{constructor({param:e}){super("Invalid ABI parameter.",{details:e});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class fr extends Qs{constructor({param:e,name:t}){super("Invalid ABI parameter.",{details:e,metaMessages:[`"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class pr extends Qs{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class mr extends Qs{constructor({param:e,type:t,modifier:n}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${n}" not allowed${t?` in "${t}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${n}" was given.`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class gr extends Qs{constructor({abiParameter:e}){super("Invalid ABI parameter.",{details:JSON.stringify(e,null,2),metaMessages:["ABI parameter type is invalid."]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}class yr extends Qs{constructor({signature:e,type:t}){super(`Invalid ${t} signature.`,{details:e});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class br extends Qs{constructor({signature:e}){super("Unknown signature.",{details:e});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class wr extends Qs{constructor({signature:e}){super("Invalid struct signature.",{details:e,metaMessages:["No properties exist."]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class vr extends Qs{constructor({type:e}){super("Circular reference detected.",{metaMessages:[`Struct "${e}" is a circular reference.`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class xr extends Qs{constructor({current:e,depth:t}){super("Unbalanced parentheses.",{metaMessages:[`"${e.trim()}" has too many ${t>0?"opening":"closing"} parentheses.`],details:`Depth "${t}"`});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}function getParameterCacheKey(e,t,n){let s="";if(n)for(const r of Object.entries(n)){if(!r)continue;let e="";for(const t of r[1])e+=`[${t.type}${t.name?`:${t.name}`:""}]`;s+=`(${r[0]}{${e}})`}return t?`${t}:${e}${s}`:e}const Pr=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);function parseSignature$1(e,t={}){if(isFunctionSignature(e))return parseFunctionSignature(e,t);if(isEventSignature(e))return parseEventSignature(e,t);if(isErrorSignature(e))return parseErrorSignature(e,t);if(isConstructorSignature(e))return parseConstructorSignature(e,t);if(isFallbackSignature(e))return parseFallbackSignature(e);if(isReceiveSignature(e))return{type:"receive",stateMutability:"payable"};throw new br({signature:e})}function parseFunctionSignature(e,t={}){const n=execFunctionSignature(e);if(!n)throw new yr({signature:e,type:"function"});const s=splitParameters(n.parameters);const r=[];const o=s.length;for(let i=0;i<o;i++)r.push(parseAbiParameter(s[i],{modifiers:cr,structs:t,type:"function"}));const a=[];if(n.returns){const e=splitParameters(n.returns);const s=e.length;for(let n=0;n<s;n++)a.push(parseAbiParameter(e[n],{modifiers:cr,structs:t,type:"function"}))}return{name:n.name,type:"function",stateMutability:n.stateMutability??"nonpayable",inputs:r,outputs:a}}function parseEventSignature(e,t={}){const n=execEventSignature(e);if(!n)throw new yr({signature:e,type:"event"});const s=splitParameters(n.parameters);const r=[];const o=s.length;for(let a=0;a<o;a++)r.push(parseAbiParameter(s[a],{modifiers:ir,structs:t,type:"event"}));return{name:n.name,type:"event",inputs:r}}function parseErrorSignature(e,t={}){const n=execErrorSignature(e);if(!n)throw new yr({signature:e,type:"error"});const s=splitParameters(n.parameters);const r=[];const o=s.length;for(let a=0;a<o;a++)r.push(parseAbiParameter(s[a],{structs:t,type:"error"}));return{name:n.name,type:"error",inputs:r}}function parseConstructorSignature(e,t={}){const n=execConstructorSignature(e);if(!n)throw new yr({signature:e,type:"constructor"});const s=splitParameters(n.parameters);const r=[];const o=s.length;for(let a=0;a<o;a++)r.push(parseAbiParameter(s[a],{structs:t,type:"constructor"}));return{type:"constructor",stateMutability:n.stateMutability??"nonpayable",inputs:r}}function parseFallbackSignature(e){const t=execFallbackSignature(e);if(!t)throw new yr({signature:e,type:"fallback"});return{type:"fallback",stateMutability:t.stateMutability??"nonpayable"}}const $r=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;const Er=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;const Ar=/^u?int$/;function parseAbiParameter(e,t){const n=getParameterCacheKey(e,t?.type,t?.structs);if(Pr.has(n))return Pr.get(n);const s=Ys.test(e);const r=execTyped(s?Er:$r,e);if(!r)throw new hr({param:e});if(r.name&&isSolidityKeyword(r.name))throw new fr({param:e,name:r.name});const o=r.name?{name:r.name}:{};const a="indexed"===r.modifier?{indexed:!0}:{};const i=t?.structs??{};let c;let u={};if(s){c="tuple";const e=splitParameters(r.type);const t=[];const n=e.length;for(let s=0;s<n;s++)t.push(parseAbiParameter(e[s],{structs:i}));u={components:t}}else if(r.type in i){c="tuple";u={components:i[r.type]}}else if(Ar.test(r.type))c=`${r.type}256`;else{c=r.type;if("struct"!==t?.type&&!isSolidityType(c))throw new dr({type:c})}if(r.modifier){if(!t?.modifiers?.has?.(r.modifier))throw new pr({param:e,type:t?.type,modifier:r.modifier});if(cr.has(r.modifier)&&!isValidDataLocation(c,!!r.array))throw new mr({param:e,type:t?.type,modifier:r.modifier})}const l={type:`${c}${r.array??""}`,...o,...a,...u};Pr.set(n,l);return l}function splitParameters(e,t=[],n="",s=0){const r=e.trim().length;for(let o=0;o<r;o++){const r=e[o];const a=e.slice(o+1);switch(r){case",":return 0===s?splitParameters(a,[...t,n.trim()]):splitParameters(a,t,`${n}${r}`,s);case"(":return splitParameters(a,t,`${n}${r}`,s+1);case")":return splitParameters(a,t,`${n}${r}`,s-1);default:return splitParameters(a,t,`${n}${r}`,s)}}if(""===n)return t;if(0!==s)throw new xr({current:n,depth:s});t.push(n.trim());return t}function isSolidityType(e){return"address"===e||"bool"===e||"function"===e||"string"===e||Zs.test(e)||Js.test(e)}const Tr=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;function isSolidityKeyword(e){return"address"===e||"bool"===e||"function"===e||"string"===e||"tuple"===e||Zs.test(e)||Js.test(e)||Tr.test(e)}function isValidDataLocation(e,t){return t||"bytes"===e||"string"===e||"tuple"===e}function parseStructs(e){const t={};const n=e.length;for(let a=0;a<n;a++){const n=e[a];if(!isStructSignature(n))continue;const s=execStructSignature(n);if(!s)throw new yr({signature:n,type:"struct"});const r=s.properties.split(";");const o=[];const i=r.length;for(let e=0;e<i;e++){const t=r[e];const n=t.trim();if(!n)continue;const s=parseAbiParameter(n,{type:"struct"});o.push(s)}if(!o.length)throw new wr({signature:n});t[s.name]=o}const s={};const r=Object.entries(t);const o=r.length;for(let a=0;a<o;a++){const[e,n]=r[a];s[e]=resolveStructs(n,t)}return s}const Ir=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function resolveStructs(e,t,n=new Set){const s=[];const r=e.length;for(let o=0;o<r;o++){const r=e[o];const a=Ys.test(r.type);if(a)s.push(r);else{const e=execTyped(Ir,r.type);if(!e?.type)throw new gr({abiParameter:r});const{array:o,type:a}=e;if(a in t){if(n.has(a))throw new vr({type:a});s.push({...r,type:`tuple${o??""}`,components:resolveStructs(t[a]??[],t,new Set([...n,a]))})}else{if(!isSolidityType(a))throw new lr({type:a});s.push(r)}}}return s}function parseAbi(e){const t=parseStructs(e);const n=[];const s=e.length;for(let r=0;r<s;r++){const s=e[r];isStructSignature(s)||n.push(parseSignature$1(s,t))}return n}function parseAbiItem(e){let t;if("string"==typeof e)t=parseSignature$1(e);else{const n=parseStructs(e);const s=e.length;for(let r=0;r<s;r++){const s=e[r];if(!isStructSignature(s)){t=parseSignature$1(s,n);break}}}if(!t)throw new ur({signature:e});return t}function normalizeSignature$1(e){let t=!0;let n="";let s=0;let r="";let o=!1;for(let a=0;a<e.length;a++){const i=e[a];["(",")",","].includes(i)&&(t=!0);"("===i&&s++;")"===i&&s--;if(t)if(0!==s){if(" "!==i){r+=i;n+=i}else if(","!==e[a-1]&&","!==n&&",("!==n){n="";t=!1}}else if(" "===i&&["event","function",""].includes(r))r="";else{r+=i;if(")"===i){o=!0;break}}}if(!o)throw new Re("Unable to normalize signature.");return r}const toSignature=e=>{const t=(()=>"string"==typeof e?e:formatAbiItem(e))();return normalizeSignature$1(t)};function toSignatureHash(e){return hashSignature(toSignature(e))}const Sr=toSignatureHash;const toFunctionSelector=e=>slice$1(toSignatureHash(e),0,4);function getAbiItem(e){const{abi:t,args:n=[],name:s}=e;const r=isHex(s,{strict:!1});const o=t.filter(e=>r?"function"===e.type?toFunctionSelector(e)===s:"event"===e.type&&Sr(e)===s:"name"in e&&e.name===s);if(0===o.length)return;if(1===o.length)return o[0];let a;for(const i of o){if(!("inputs"in i))continue;if(!n||0===n.length){if(!i.inputs||0===i.inputs.length)return i;continue}if(!i.inputs)continue;if(0===i.inputs.length)continue;if(i.inputs.length!==n.length)continue;const e=n.every((e,t)=>{const n="inputs"in i&&i.inputs[t];return!!n&&isArgOfType$1(e,n)});if(e){if(a&&"inputs"in a&&a.inputs){const e=getAmbiguousTypes$1(i.inputs,a.inputs,n);if(e)throw new ut({abiItem:i,type:e[0]},{abiItem:a,type:e[1]})}a=i}}return a||o[0]}function isArgOfType$1(e,t){const n=typeof e;const s=t.type;switch(s){case"address":return isAddress(e,{strict:!1});case"bool":return"boolean"===n;case"function":case"string":return"string"===n;default:return"tuple"===s&&"components"in t?Object.values(t.components).every((t,n)=>isArgOfType$1(Object.values(e)[n],t)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?"number"===n||"bigint"===n:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?"string"===n||e instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)&&(Array.isArray(e)&&e.every(e=>isArgOfType$1(e,{...t,type:s.replace(/(\[[0-9]{0,}\])$/,"")})))}}function getAmbiguousTypes$1(e,t,n){for(const s in e){const r=e[s];const o=t[s];if("tuple"===r.type&&"tuple"===o.type&&"components"in r&&"components"in o)return getAmbiguousTypes$1(r.components,o.components,n[s]);const a=[r.type,o.type];const i=(()=>!(!a.includes("address")||!a.includes("bytes20"))||(a.includes("address")&&a.includes("string")||!(!a.includes("address")||!a.includes("bytes")))&&isAddress(n[s],{strict:!1}))();if(i)return a}}const kr="/docs/contract/decodeFunctionResult";function decodeFunctionResult(e){const{abi:t,args:n,functionName:s,data:r}=e;let o=t[0];if(s){const e=getAbiItem({abi:t,args:n,name:s});if(!e)throw new at(s,{docsPath:kr});o=e}if("function"!==o.type)throw new at(void 0,{docsPath:kr});if(!o.outputs)throw new it(o.name,{docsPath:kr});const a=decodeAbiParameters(o.outputs,r);return a&&a.length>1?a:a&&1===a.length?a[0]:void 0}const Br="/docs/contract/encodeFunctionData";function prepareEncodeFunctionData(e){const{abi:t,args:n,functionName:s}=e;let r=t[0];if(s){const e=getAbiItem({abi:t,args:n,name:s});if(!e)throw new at(s,{docsPath:Br});r=e}if("function"!==r.type)throw new at(void 0,{docsPath:Br});return{abi:[r],functionName:toFunctionSelector(formatAbiItem$1(r))}}function encodeFunctionData(e){const{args:t}=e;const{abi:n,functionName:s}=(()=>1===e.abi.length&&e.functionName?.startsWith("0x")?e:prepareEncodeFunctionData(e))();const r=n[0];const o=s;const a="inputs"in r&&r.inputs?encodeAbiParameters(r.inputs,t??[]):void 0;return concatHex([o,a??"0x"])}function getChainContractAddress({blockNumber:e,chain:t,contract:n}){const s=t?.contracts?.[n];if(!s)throw new rn({chain:t,contract:{name:n}});if(e&&s.blockCreated&&s.blockCreated>e)throw new rn({blockNumber:e,chain:t,contract:{name:n,blockCreated:s.blockCreated}});return s.address}const Cr={1:"An `assert` condition failed.",17:"Arithmetic operation resulted in underflow or overflow.",18:"Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",33:"Attempted to convert to an invalid type.",34:"Attempted to access a storage byte array that is incorrectly encoded.",49:"Performed `.pop()` on an empty array",50:"Array index is out of bounds.",65:"Allocated too much memory or created an array which is too large.",81:"Attempted to call a zero-initialized variable of internal function type."};const Or={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"};const Fr={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};function decodeErrorResult(e){const{abi:t,data:n}=e;const s=slice$1(n,0,4);if("0x"===s)throw new Ze;const r=[...t||[],Or,Fr];const o=r.find(e=>"error"===e.type&&s===toFunctionSelector(formatAbiItem$1(e)));if(!o)throw new nt(s,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:o,args:"inputs"in o&&o.inputs&&o.inputs.length>0?decodeAbiParameters(o.inputs,slice$1(n,4)):void 0,errorName:o.name}}function formatAbiItemWithArgs({abiItem:e,args:t,includeFunctionName:n=!0,includeName:s=!1}){if("name"in e&&"inputs"in e&&e.inputs)return`${n?e.name:""}(${e.inputs.map((e,n)=>`${s&&e.name?`${e.name}: `:""}${"object"==typeof t[n]?stringify$1(t[n]):t[n]}`).join(", ")})`}class Nr extends Re{constructor(e,{account:t,docsPath:n,chain:s,data:r,gas:o,gasPrice:a,maxFeePerGas:i,maxPriorityFeePerGas:c,nonce:u,to:l,value:d,stateOverride:f}){const p=t?parseAccount(t):void 0;let m=prettyPrint({from:p?.address,to:l,value:"undefined"!=typeof d&&`${formatEther(d)} ${s?.nativeCurrency?.symbol||"ETH"}`,data:r,gas:o,gasPrice:"undefined"!=typeof a&&`${formatGwei(a)} gwei`,maxFeePerGas:"undefined"!=typeof i&&`${formatGwei(i)} gwei`,maxPriorityFeePerGas:"undefined"!=typeof c&&`${formatGwei(c)} gwei`,nonce:u});f&&(m+=`\n${prettyStateOverride(f)}`);super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Raw Call Arguments:",m].filter(Boolean),name:"CallExecutionError"});Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.cause=e}}class Rr extends Re{constructor(e,{abi:t,args:n,contractAddress:s,docsPath:r,functionName:o,sender:a}){const i=getAbiItem({abi:t,args:n,name:o});const c=i?formatAbiItemWithArgs({abiItem:i,args:n,includeFunctionName:!1,includeName:!1}):void 0;const u=i?formatAbiItem$1(i,{includeName:!0}):void 0;const l=prettyPrint({address:s&&getContractAddress(s),function:u,args:c&&"()"!==c&&`${[...Array(o?.length??0).keys()].map(()=>" ").join("")}${c}`,sender:a});super(e.shortMessage||`An unknown error occurred while executing the contract function "${o}".`,{cause:e,docsPath:r,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],l&&"Contract Call:",l].filter(Boolean),name:"ContractFunctionExecutionError"});Object.defineProperty(this,"abi",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"args",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"contractAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"formattedArgs",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"functionName",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"sender",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.abi=t;this.args=n;this.cause=e;this.contractAddress=s;this.functionName=o;this.sender=a}}class Mr extends Re{constructor({abi:e,data:t,functionName:n,message:s}){let r;let o;let a;let i;if(t&&"0x"!==t)try{o=decodeErrorResult({abi:e,data:t});const{abiItem:n,errorName:s,args:r}=o;if("Error"===s)i=r[0];else if("Panic"===s){const[e]=r;i=Cr[e]}else{const e=n?formatAbiItem$1(n,{includeName:!0}):void 0;const t=n&&r?formatAbiItemWithArgs({abiItem:n,args:r,includeFunctionName:!1,includeName:!1}):void 0;a=[e?`Error: ${e}`:"",t&&"()"!==t?`       ${[...Array(s?.length??0).keys()].map(()=>" ").join("")}${t}`:""]}}catch(u){r=u}else s&&(i=s);let c;if(r instanceof nt){c=r.signature;a=[`Unable to decode signature "${c}" as it was not found on the provided ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${c}.`]}super(i&&"execution reverted"!==i||c?[`The contract function "${n}" reverted with the following ${c?"signature":"reason"}:`,i||c].join("\n"):`The contract function "${n}" reverted.`,{cause:r,metaMessages:a,name:"ContractFunctionRevertedError"});Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"raw",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"reason",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.data=o;this.raw=t;this.reason=i;this.signature=c}}class zr extends Re{constructor({functionName:e}){super(`The contract function "${e}" returned no data ("0x").`,{metaMessages:["This could be due to any of the following:",`  - The contract does not have the function "${e}",`,"  - The parameters passed to the contract function may be invalid, or","  - The address is not a contract."],name:"ContractFunctionZeroDataError"})}}class jr extends Re{constructor({factory:e}){super("Deployment for counterfactual contract call failed"+(e?` for factory "${e}".`:""),{metaMessages:["Please ensure:","- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).","- The `factoryData` is a valid encoded function call for contract deployment function on the factory."],name:"CounterfactualDeploymentFailedError"})}}class qr extends Re{constructor({data:e,message:t}){super(t||"",{name:"RawContractError"});Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:3});Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.data=e}}function isNullUniversalResolverError(e,t){if(!(e instanceof Re))return!1;const n=e.walk(e=>e instanceof Mr);return n instanceof Mr&&("ResolverNotFound"===n.data?.errorName||("ResolverWildcardNotSupported"===n.data?.errorName||("ResolverNotContract"===n.data?.errorName||("ResolverError"===n.data?.errorName||("HttpError"===n.data?.errorName||(!!n.reason?.includes("Wildcard on non-extended resolvers is not supported")||"reverse"===t&&n.reason===Cr[50]))))))}function decodeFunctionData(e){const{abi:t,data:n}=e;const s=slice$1(n,0,4);const r=t.find(e=>"function"===e.type&&s===toFunctionSelector(formatAbiItem$1(e)));if(!r)throw new ct(s,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:r.name,args:"inputs"in r&&r.inputs&&r.inputs.length>0?decodeAbiParameters(r.inputs,slice$1(n,4)):void 0}}const Lr="/docs/contract/encodeErrorResult";function encodeErrorResult(e){const{abi:t,errorName:n,args:s}=e;let r=t[0];if(n){const e=getAbiItem({abi:t,args:s,name:n});if(!e)throw new tt(n,{docsPath:Lr});r=e}if("error"!==r.type)throw new tt(void 0,{docsPath:Lr});const o=formatAbiItem$1(r);const a=toFunctionSelector(o);let i="0x";if(s&&s.length>0){if(!r.inputs)throw new et(r.name,{docsPath:Lr});i=encodeAbiParameters(r.inputs,s)}return concatHex([a,i])}const Hr="/docs/contract/encodeFunctionResult";function encodeFunctionResult(e){const{abi:t,functionName:n,result:s}=e;let r=t[0];if(n){const e=getAbiItem({abi:t,name:n});if(!e)throw new at(n,{docsPath:Hr});r=e}if("function"!==r.type)throw new at(void 0,{docsPath:Hr});if(!r.outputs)throw new it(r.name,{docsPath:Hr});const o=(()=>{if(0===r.outputs.length)return[];if(1===r.outputs.length)return[s];if(Array.isArray(s))return s;throw new mt(s)})();return encodeAbiParameters(r.outputs,o)}const Ur="x-batch-gateway:true";async function localBatchGatewayRequest(e){const{data:t,ccipRequest:n}=e;const{args:[s]}=decodeFunctionData({abi:js,data:t});const r=[];const o=[];await Promise.all(s.map(async(e,t)=>{try{o[t]=e.urls.includes(Ur)?await localBatchGatewayRequest({data:e.data,ccipRequest:n}):await n(e);r[t]=!1}catch(s){r[t]=!0;o[t]=encodeError(s)}}));return encodeFunctionResult({abi:js,functionName:"query",result:[r,o]})}function encodeError(e){return"HttpRequestError"===e.name&&e.status?encodeErrorResult({abi:js,errorName:"HttpError",args:[e.status,e.shortMessage]}):encodeErrorResult({abi:[Or],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}function encodedLabelToLabelhash(e){if(66!==e.length)return null;if(0!==e.indexOf("["))return null;if(65!==e.indexOf("]"))return null;const t=`0x${e.slice(1,65)}`;return isHex(t)?t:null}function namehash(e){let t=new Uint8Array(32).fill(0);if(!e)return bytesToHex$1(t);const n=e.split(".");for(let s=n.length-1;s>=0;s-=1){const e=encodedLabelToLabelhash(n[s]);const r=e?toBytes$2(e):keccak256$1(stringToBytes(n[s]),"bytes");t=keccak256$1(concat$1([t,r]),"bytes")}return bytesToHex$1(t)}function encodeLabelhash(e){return`[${e.slice(2)}]`}function labelhash(e){const t=new Uint8Array(32).fill(0);return e?encodedLabelToLabelhash(e)||keccak256$1(stringToBytes(e)):bytesToHex$1(t)}function packetToBytes(e){const t=e.replace(/^\.|\.$/gm,"");if(0===t.length)return new Uint8Array(1);const n=new Uint8Array(stringToBytes(t).byteLength+2);let s=0;const r=t.split(".");for(let o=0;o<r.length;o++){let e=stringToBytes(r[o]);e.byteLength>255&&(e=stringToBytes(encodeLabelhash(labelhash(r[o]))));n[s]=e.length;n.set(e,s+1);s+=e.length+1}return n.byteLength!==s+1?n.slice(0,s+1):n}const _r=3;function getContractError(e,{abi:t,address:n,args:s,docsPath:r,functionName:o,sender:a}){const i=e instanceof qr?e:e instanceof Re?e.walk(e=>"data"in e)||e.walk():{};const{code:c,data:u,details:l,message:d,shortMessage:f}=i;const p=(()=>e instanceof Ze?new zr({functionName:o}):[_r,Hn.code].includes(c)&&(u||l||d||f)?new Mr({abi:t,data:"object"==typeof u?u.data:u,functionName:o,message:i instanceof On?l:f??d}):e)();return new Rr(p,{abi:t,args:s,contractAddress:n,docsPath:r,functionName:o,sender:a})}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function anumber(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function abytes(e,...t){if(!isBytes(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function aexists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function aoutput(e,t){abytes(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function u32(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function clean(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Dr=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function byteSwap(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function byteSwap32(e){for(let t=0;t<e.length;t++)e[t]=byteSwap(e[t]);return e}const Gr=Dr?e=>e:byteSwap32;function utf8ToBytes(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){"string"==typeof e&&(e=utf8ToBytes(e));abytes(e);return e}class Wr{}function createHasher(e){const hashC=t=>e().update(toBytes(t)).digest();const t=e();hashC.outputLen=t.outputLen;hashC.blockLen=t.blockLen;hashC.create=()=>e();return hashC}const Vr="0.1.1";function getVersion$2(){return Vr}let Kr=class e extends Error{constructor(t,n={}){const s=(()=>{if(n.cause instanceof e){if(n.cause.details)return n.cause.details;if(n.cause.shortMessage)return n.cause.shortMessage}return n.cause&&"details"in n.cause&&"string"==typeof n.cause.details?n.cause.details:n.cause?.message?n.cause.message:n.details})();const r=(()=>n.cause instanceof e&&n.cause.docsPath||n.docsPath)();const o="https://oxlib.sh";const a=`${o}${r??""}`;const i=[t||"An error occurred.",...n.metaMessages?["",...n.metaMessages]:[],...s||r?["",s?`Details: ${s}`:void 0,r?`See: ${a}`:void 0]:[]].filter(e=>"string"==typeof e).join("\n");super(i,n.cause?{cause:n.cause}:void 0);Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"docs",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"});Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:`ox@${getVersion$2()}`});this.cause=n.cause;this.details=s;this.docs=a;this.docsPath=r;this.shortMessage=t}walk(e){return walk(this,e)}};function walk(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e&&e.cause?walk(e.cause,t):t?null:e}const Qr="#__bigint";function stringify(e,t,n){return JSON.stringify(e,(e,t)=>"bigint"==typeof t?t.toString()+Qr:t,n)}function assertSize$1(e,t){if(size$3(e)>t)throw new Yr({givenSize:size$3(e),maxSize:t})}const Zr={zero:48,nine:57,A:65,F:70,a:97,f:102};function charCodeToBase16(e){return e>=Zr.zero&&e<=Zr.nine?e-Zr.zero:e>=Zr.A&&e<=Zr.F?e-(Zr.A-10):e>=Zr.a&&e<=Zr.f?e-(Zr.a-10):void 0}function pad$1(e,t={}){const{dir:n,size:s=32}=t;if(0===s)return e;if(e.length>s)throw new Xr({size:e.length,targetSize:s,type:"Bytes"});const r=new Uint8Array(s);for(let o=0;o<s;o++){const t="right"===n;r[t?o:s-o-1]=e[t?o:e.length-o-1]}return r}function assertSize(e,t){if(size$2(e)>t)throw new oo({givenSize:size$2(e),maxSize:t})}function assertStartOffset(e,t){if("number"==typeof t&&t>0&&t>size$2(e)-1)throw new ao({offset:t,position:"start",size:size$2(e)})}function assertEndOffset(e,t,n){if("number"==typeof t&&"number"==typeof n&&size$2(e)!==n-t)throw new ao({offset:n,position:"end",size:size$2(e)})}function pad(e,t={}){const{dir:n,size:s=32}=t;if(0===s)return e;const r=e.replace("0x","");if(r.length>2*s)throw new io({size:Math.ceil(r.length/2),targetSize:s,type:"Hex"});return`0x${r["right"===n?"padEnd":"padStart"](2*s,"0")}`}const Jr=new TextEncoder;function from$3(e){return e instanceof Uint8Array?e:"string"==typeof e?fromHex(e):fromArray(e)}function fromArray(e){return e instanceof Uint8Array?e:new Uint8Array(e)}function fromHex(e,t={}){const{size:n}=t;let s=e;if(n){assertSize(e,n);s=padRight(e,n)}let r=s.slice(2);r.length%2&&(r=`0${r}`);const o=r.length/2;const a=new Uint8Array(o);for(let i=0,c=0;i<o;i++){const e=charCodeToBase16(r.charCodeAt(c++));const t=charCodeToBase16(r.charCodeAt(c++));if(void 0===e||void 0===t)throw new Kr(`Invalid byte sequence ("${r[c-2]}${r[c-1]}" in "${r}").`);a[i]=16*e+t}return a}function fromString$1(e,t={}){const{size:n}=t;const s=Jr.encode(e);if("number"==typeof n){assertSize$1(s,n);return padRight$1(s,n)}return s}function padRight$1(e,t){return pad$1(e,{dir:"right",size:t})}function size$3(e){return e.length}let Yr=class extends Kr{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}};let Xr=class extends Kr{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}};const eo=new TextEncoder;const to=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function assert$1(e,t={}){const{strict:n=!1}=t;if(!e)throw new so(e);if("string"!=typeof e)throw new so(e);if(n&&!/^0x[0-9a-fA-F]*$/.test(e))throw new ro(e);if(!e.startsWith("0x"))throw new ro(e)}function concat(...e){return`0x${e.reduce((e,t)=>e+t.replace("0x",""),"")}`}function fromBoolean(e,t={}){const n=`0x${Number(e)}`;if("number"==typeof t.size){assertSize(n,t.size);return padLeft(n,t.size)}return n}function fromBytes(e,t={}){let n="";for(let r=0;r<e.length;r++)n+=to[e[r]];const s=`0x${n}`;if("number"==typeof t.size){assertSize(s,t.size);return padRight(s,t.size)}return s}function fromNumber(e,t={}){const{signed:n,size:s}=t;const r=BigInt(e);let o;s?o=n?(1n<<8n*BigInt(s)-1n)-1n:2n**(8n*BigInt(s))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const a="bigint"==typeof o&&n?-o-1n:0;if(o&&r>o||r<a){const t="bigint"==typeof e?"n":"";throw new no({max:o?`${o}${t}`:void 0,min:`${a}${t}`,signed:n,size:s,value:`${e}${t}`})}const i=(n&&r<0?(1n<<BigInt(8*s))+BigInt(r):r).toString(16);const c=`0x${i}`;return s?padLeft(c,s):c}function fromString(e,t={}){return fromBytes(eo.encode(e),t)}function padLeft(e,t){return pad(e,{dir:"left",size:t})}function padRight(e,t){return pad(e,{dir:"right",size:t})}function slice(e,t,n,s={}){const{strict:r}=s;assertStartOffset(e,t);const o=`0x${e.replace("0x","").slice(2*(t??0),2*(n??e.length))}`;r&&assertEndOffset(o,t,n);return o}function size$2(e){return Math.ceil((e.length-2)/2)}function validate$1(e,t={}){const{strict:n=!1}=t;try{assert$1(e,{strict:n});return!0}catch{return!1}}class no extends Kr{constructor({max:e,min:t,signed:n,size:s,value:r}){super(`Number \`${r}\` is not in safe${s?` ${8*s}-bit`:""}${n?" signed":" unsigned"} integer range ${e?`(\`${t}\` to \`${e}\`)`:`(above \`${t}\`)`}`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.IntegerOutOfRangeError"})}}class so extends Kr{constructor(e){super(`Value \`${"object"==typeof e?stringify(e):e}\` of type \`${typeof e}\` is an invalid hex type.`,{metaMessages:['Hex types must be represented as `"0x${string}"`.']});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexTypeError"})}}class ro extends Kr{constructor(e){super(`Value \`${e}\` is an invalid hex value.`,{metaMessages:['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.InvalidHexValueError"})}}class oo extends Kr{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeOverflowError"})}}class ao extends Kr{constructor({offset:e,position:t,size:n}){super(`Slice ${"start"===t?"starting":"ending"} at offset \`${e}\` is out-of-bounds (size: \`${n}\`).`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SliceOffsetOutOfBoundsError"})}}class io extends Kr{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Hex.SizeExceedsPaddingSizeError"})}}function toRpc$1(e){return{address:e.address,amount:fromNumber(e.amount),index:fromNumber(e.index),validatorIndex:fromNumber(e.validatorIndex)}}function toRpc(e){return{..."bigint"==typeof e.baseFeePerGas&&{baseFeePerGas:fromNumber(e.baseFeePerGas)},..."bigint"==typeof e.blobBaseFee&&{blobBaseFee:fromNumber(e.blobBaseFee)},..."string"==typeof e.feeRecipient&&{feeRecipient:e.feeRecipient},..."bigint"==typeof e.gasLimit&&{gasLimit:fromNumber(e.gasLimit)},..."bigint"==typeof e.number&&{number:fromNumber(e.number)},..."bigint"==typeof e.prevRandao&&{prevRandao:fromNumber(e.prevRandao)},..."bigint"==typeof e.time&&{time:fromNumber(e.time)},...e.withdrawals&&{withdrawals:e.withdrawals.map(toRpc$1)}}}const co="0x82ad56cb";const uo="0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe";const lo="0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";const ho="0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";function getCallError(e,{docsPath:t,...n}){const s=(()=>{const t=getNodeError(e,n);return t instanceof En?e:t})();return new Nr(s,{docsPath:t,...n})}function withResolvers(){let resolve=()=>{};let reject=()=>{};const e=new Promise((e,t)=>{resolve=e;reject=t});return{promise:e,resolve:resolve,reject:reject}}const fo=new Map;function createBatchScheduler({fn:e,id:t,shouldSplitBatch:n,wait:s=0,sort:r}){const exec=async()=>{const t=getScheduler();flush();const n=t.map(({args:e})=>e);0!==n.length&&e(n).then(e=>{r&&Array.isArray(e)&&e.sort(r);for(let n=0;n<t.length;n++){const{resolve:s}=t[n];s?.([e[n],e])}}).catch(e=>{for(let n=0;n<t.length;n++){const{reject:s}=t[n];s?.(e)}})};const flush=()=>fo.delete(t);const getBatchedArgs=()=>getScheduler().map(({args:e})=>e);const getScheduler=()=>fo.get(t)||[];const setScheduler=e=>fo.set(t,[...getScheduler(),e]);return{flush:flush,async schedule(e){const{promise:t,resolve:r,reject:o}=withResolvers();const a=n?.([...getBatchedArgs(),e]);a&&exec();const i=getScheduler().length>0;if(i){setScheduler({args:e,resolve:r,reject:o});return t}setScheduler({args:e,resolve:r,reject:o});setTimeout(exec,s);return t}}}async function call(e,t){const{account:n=e.account,authorizationList:s,batch:r=Boolean(e.batch?.multicall),blockNumber:o,blockTag:a=e.experimental_blockTag??"latest",accessList:i,blobs:c,blockOverrides:u,code:l,data:d,factory:f,factoryData:p,gas:m,gasPrice:g,maxFeePerBlobGas:y,maxFeePerGas:b,maxPriorityFeePerGas:w,nonce:v,to:x,value:P,stateOverride:$,...E}=t;const A=n?parseAccount(n):void 0;if(l&&(f||p))throw new Re("Cannot provide both `code` & `factory`/`factoryData` as parameters.");if(l&&x)throw new Re("Cannot provide both `code` & `to` as parameters.");const T=l&&d;const I=f&&p&&x&&d;const S=T||I;const k=(()=>T?toDeploylessCallViaBytecodeData({code:l,data:d}):I?toDeploylessCallViaFactoryData({data:d,factory:f,factoryData:p,to:x}):d)();try{assertRequest(t);const n="bigint"==typeof o?numberToHex(o):void 0;const l=n||a;const d=u?toRpc(u):void 0;const f=serializeStateOverride($);const p=e.chain?.formatters?.transactionRequest?.format;const T=p||formatTransactionRequest;const I=T({...extract(E,{format:p}),from:A?.address,accessList:i,authorizationList:s,blobs:c,data:k,gas:m,gasPrice:g,maxFeePerBlobGas:y,maxFeePerGas:b,maxPriorityFeePerGas:w,nonce:v,to:S?void 0:x,value:P});if(r&&shouldPerformMulticall({request:I})&&!f&&!d)try{return await scheduleMulticall(e,{...I,blockNumber:o,blockTag:a})}catch(B){if(!(B instanceof cn||B instanceof rn))throw B}const C=(()=>{const e=[I,l];return f&&d?[...e,f,d]:f?[...e,f]:d?[...e,{},d]:e})();const O=await e.request({method:"eth_call",params:C});return"0x"===O?{data:void 0}:{data:O}}catch(B){const n=getRevertErrorData(B);const{offchainLookup:s,offchainLookupSignature:r}=await __vitePreload(async()=>{const{offchainLookup:e,offchainLookupSignature:t}=await Promise.resolve().then(()=>ya);return{offchainLookup:e,offchainLookupSignature:t}},void 0);if(!1!==e.ccipRead&&n?.slice(0,10)===r&&x)return{data:await s(e,{data:n,to:x})};if(S&&"0x101bb98d"===n?.slice(0,10))throw new jr({factory:f});throw getCallError(B,{...t,account:A,chain:e.chain})}}function shouldPerformMulticall({request:e}){const{data:t,to:n,...s}=e;return!!t&&(!t.startsWith(co)&&(!!n&&!(Object.values(s).filter(e=>"undefined"!=typeof e).length>0)))}async function scheduleMulticall(e,t){const{batchSize:n=1024,wait:s=0}="object"==typeof e.batch?.multicall?e.batch.multicall:{};const{blockNumber:r,blockTag:o=e.experimental_blockTag??"latest",data:a,multicallAddress:i,to:c}=t;let u=i;if(!u){if(!e.chain)throw new cn;u=getChainContractAddress({blockNumber:r,chain:e.chain,contract:"multicall3"})}const l="bigint"==typeof r?numberToHex(r):void 0;const d=l||o;const{schedule:f}=createBatchScheduler({id:`${e.uid}.${d}`,wait:s,shouldSplitBatch(e){const t=e.reduce((e,{data:t})=>e+(t.length-2),0);return t>2*n},fn:async t=>{const n=t.map(e=>({allowFailure:!0,callData:e.data,target:e.to}));const s=encodeFunctionData({abi:zs,args:[n],functionName:"aggregate3"});const r=await e.request({method:"eth_call",params:[{data:s,to:u},d]});return decodeFunctionResult({abi:zs,args:[n],functionName:"aggregate3",data:r||"0x"})}});const[{returnData:p,success:m}]=await f({data:a,to:c});if(!m)throw new qr({data:p});return"0x"===p?{data:void 0}:{data:p}}function toDeploylessCallViaBytecodeData(e){const{code:t,data:n}=e;return encodeDeployData({abi:parseAbi(["constructor(bytes, bytes)"]),bytecode:uo,args:[t,n]})}function toDeploylessCallViaFactoryData(e){const{data:t,factory:n,factoryData:s,to:r}=e;return encodeDeployData({abi:parseAbi(["constructor(address, bytes, address, bytes)"]),bytecode:lo,args:[r,t,n,s]})}function getRevertErrorData(e){if(!(e instanceof Re))return;const t=e.walk();return"object"==typeof t?.data?t.data?.data:t.data}async function readContract$1(e,t){const{abi:n,address:s,args:r,functionName:o,...a}=t;const i=encodeFunctionData({abi:n,args:r,functionName:o});try{const{data:t}=await getAction$1(e,call,"call")({...a,data:i,to:s});return decodeFunctionResult({abi:n,args:r,functionName:o,data:t||"0x"})}catch(c){throw getContractError(c,{abi:n,address:s,args:r,docsPath:"/docs/contract/readContract",functionName:o})}}async function getEnsAddress(e,t){const{blockNumber:n,blockTag:s,coinType:r,name:o,gatewayUrls:a,strict:i}=t;const{chain:c}=e;const u=(()=>{if(t.universalResolverAddress)return t.universalResolverAddress;if(!c)throw new Error("client chain not configured. universalResolverAddress is required.");return getChainContractAddress({blockNumber:n,chain:c,contract:"ensUniversalResolver"})})();const l=c?.ensTlds;if(l&&!l.some(e=>o.endsWith(e)))return null;try{const t=encodeFunctionData({abi:_s,functionName:"addr",...null!=r?{args:[namehash(o),BigInt(r)]}:{args:[namehash(o)]}});const i={address:u,abi:Ls,functionName:"resolve",args:[toHex(packetToBytes(o)),t,a??[Ur]],blockNumber:n,blockTag:s};const c=getAction$1(e,readContract$1,"readContract");const l=await c(i);if("0x"===l[0])return null;const d=decodeFunctionResult({abi:_s,args:null!=r?[namehash(o),BigInt(r)]:void 0,functionName:"addr",data:l[0]});return"0x"===d||"0x00"===trim(d)?null:d}catch(d){if(i)throw d;if(isNullUniversalResolverError(d,"resolve"))return null;throw d}}class po extends Re{constructor({data:e}){super("Unable to extract image from metadata. The metadata may be malformed or invalid.",{metaMessages:["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.","",`Provided data: ${JSON.stringify(e)}`],name:"EnsAvatarInvalidMetadataError"})}}class mo extends Re{constructor({reason:e}){super(`ENS NFT avatar URI is invalid. ${e}`,{name:"EnsAvatarInvalidNftUriError"})}}class go extends Re{constructor({uri:e}){super(`Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`,{name:"EnsAvatarUriResolutionError"})}}class yo extends Re{constructor({namespace:e}){super(`ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`,{name:"EnsAvatarUnsupportedNamespaceError"})}}const bo=/(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;const wo=/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;const vo=/^data:([a-zA-Z\-/+]*);base64,([^"].*)/;const xo=/^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;async function isImageUri(e){try{const t=await fetch(e,{method:"HEAD"});if(200===t.status){const e=t.headers.get("content-type");return e?.startsWith("image/")}return!1}catch(t){return("object"!=typeof t||"undefined"==typeof t.response)&&(!!globalThis.hasOwnProperty("Image")&&new Promise(t=>{const n=new Image;n.onload=()=>{t(!0)};n.onerror=()=>{t(!1)};n.src=e}))}}function getGateway(e,t){return e?e.endsWith("/")?e.slice(0,-1):e:t}function resolveAvatarUri({uri:e,gatewayUrls:t}){const n=vo.test(e);if(n)return{uri:e,isOnChain:!0,isEncoded:n};const s=getGateway(t?.ipfs,"https://ipfs.io");const r=getGateway(t?.arweave,"https://arweave.net");const o=e.match(bo);const{protocol:a,subpath:i,target:c,subtarget:u=""}=o?.groups||{};const l="ipns:/"===a||"ipns/"===i;const d="ipfs:/"===a||"ipfs/"===i||wo.test(e);if(e.startsWith("http")&&!l&&!d){let n=e;t?.arweave&&(n=e.replace(/https:\/\/arweave.net/g,t?.arweave));return{uri:n,isOnChain:!1,isEncoded:!1}}if((l||d)&&c)return{uri:`${s}/${l?"ipns":"ipfs"}/${c}${u}`,isOnChain:!1,isEncoded:!1};if("ar:/"===a&&c)return{uri:`${r}/${c}${u||""}`,isOnChain:!1,isEncoded:!1};let f=e.replace(xo,"");f.startsWith("<svg")&&(f=`data:image/svg+xml;base64,${btoa(f)}`);if(f.startsWith("data:")||f.startsWith("{"))return{uri:f,isOnChain:!0,isEncoded:!1};throw new go({uri:e})}function getJsonImage(e){if("object"!=typeof e||!("image"in e)&&!("image_url"in e)&&!("image_data"in e))throw new po({data:e});return e.image||e.image_url||e.image_data}async function getMetadataAvatarUri({gatewayUrls:e,uri:t}){try{const n=await fetch(t).then(e=>e.json());const s=await parseAvatarUri({gatewayUrls:e,uri:getJsonImage(n)});return s}catch{throw new go({uri:t})}}async function parseAvatarUri({gatewayUrls:e,uri:t}){const{uri:n,isOnChain:s}=resolveAvatarUri({uri:t,gatewayUrls:e});if(s)return n;const r=await isImageUri(n);if(r)return n;throw new go({uri:t})}function parseNftUri(e){let t=e;t.startsWith("did:nft:")&&(t=t.replace("did:nft:","").replace(/_/g,"/"));const[n,s,r]=t.split("/");const[o,a]=n.split(":");const[i,c]=s.split(":");if(!o||"eip155"!==o.toLowerCase())throw new mo({reason:"Only EIP-155 supported"});if(!a)throw new mo({reason:"Chain ID not found"});if(!c)throw new mo({reason:"Contract address not found"});if(!r)throw new mo({reason:"Token ID not found"});if(!i)throw new mo({reason:"ERC namespace not found"});return{chainID:Number.parseInt(a),namespace:i.toLowerCase(),contractAddress:c,tokenID:r}}async function getNftTokenUri(e,{nft:t}){if("erc721"===t.namespace)return readContract$1(e,{address:t.contractAddress,abi:[{name:"tokenURI",type:"function",stateMutability:"view",inputs:[{name:"tokenId",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"tokenURI",args:[BigInt(t.tokenID)]});if("erc1155"===t.namespace)return readContract$1(e,{address:t.contractAddress,abi:[{name:"uri",type:"function",stateMutability:"view",inputs:[{name:"_id",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"uri",args:[BigInt(t.tokenID)]});throw new yo({namespace:t.namespace})}async function parseAvatarRecord(e,{gatewayUrls:t,record:n}){return/eip155:/i.test(n)?parseNftAvatarUri(e,{gatewayUrls:t,record:n}):parseAvatarUri({uri:n,gatewayUrls:t})}async function parseNftAvatarUri(e,{gatewayUrls:t,record:n}){const s=parseNftUri(n);const r=await getNftTokenUri(e,{nft:s});const{uri:o,isOnChain:a,isEncoded:i}=resolveAvatarUri({uri:r,gatewayUrls:t});if(a&&(o.includes("data:application/json;base64,")||o.startsWith("{"))){const e=i?atob(o.replace("data:application/json;base64,","")):o;const n=JSON.parse(e);return parseAvatarUri({uri:getJsonImage(n),gatewayUrls:t})}let c=s.tokenID;"erc1155"===s.namespace&&(c=c.replace("0x","").padStart(64,"0"));return getMetadataAvatarUri({gatewayUrls:t,uri:o.replace(/(?:0x)?{id}/,c)})}async function getEnsText(e,t){const{blockNumber:n,blockTag:s,key:r,name:o,gatewayUrls:a,strict:i}=t;const{chain:c}=e;const u=(()=>{if(t.universalResolverAddress)return t.universalResolverAddress;if(!c)throw new Error("client chain not configured. universalResolverAddress is required.");return getChainContractAddress({blockNumber:n,chain:c,contract:"ensUniversalResolver"})})();const l=c?.ensTlds;if(l&&!l.some(e=>o.endsWith(e)))return null;try{const t={address:u,abi:Ls,functionName:"resolve",args:[toHex(packetToBytes(o)),encodeFunctionData({abi:Us,functionName:"text",args:[namehash(o),r]}),a??[Ur]],blockNumber:n,blockTag:s};const i=getAction$1(e,readContract$1,"readContract");const c=await i(t);if("0x"===c[0])return null;const l=decodeFunctionResult({abi:Us,functionName:"text",data:c[0]});return""===l?null:l}catch(d){if(i)throw d;if(isNullUniversalResolverError(d,"resolve"))return null;throw d}}async function getEnsAvatar(e,{blockNumber:t,blockTag:n,assetGatewayUrls:s,name:r,gatewayUrls:o,strict:a,universalResolverAddress:i}){const c=await getAction$1(e,getEnsText,"getEnsText")({blockNumber:t,blockTag:n,key:"avatar",name:r,universalResolverAddress:i,gatewayUrls:o,strict:a});if(!c)return null;try{return await parseAvatarRecord(e,{record:c,gatewayUrls:s})}catch{return null}}async function getEnsName(e,{address:t,blockNumber:n,blockTag:s,gatewayUrls:r,strict:o,universalResolverAddress:a}){let i=a;if(!i){if(!e.chain)throw new Error("client chain not configured. universalResolverAddress is required.");i=getChainContractAddress({blockNumber:n,chain:e.chain,contract:"ensUniversalResolver"})}const c=`${t.toLowerCase().substring(2)}.addr.reverse`;try{const o={address:i,abi:Hs,functionName:"reverse",args:[toHex(packetToBytes(c))],blockNumber:n,blockTag:s};const a=getAction$1(e,readContract$1,"readContract");const[u,l]=r?await a({...o,args:[...o.args,r]}):await a(o);return t.toLowerCase()!==l.toLowerCase()?null:u}catch(u){if(o)throw u;if(isNullUniversalResolverError(u,"reverse"))return null;throw u}}async function getEnsResolver(e,t){const{blockNumber:n,blockTag:s,name:r}=t;const{chain:o}=e;const a=(()=>{if(t.universalResolverAddress)return t.universalResolverAddress;if(!o)throw new Error("client chain not configured. universalResolverAddress is required.");return getChainContractAddress({blockNumber:n,chain:o,contract:"ensUniversalResolver"})})();const i=o?.ensTlds;if(i&&!i.some(e=>r.endsWith(e)))throw new Error(`${r} is not a valid ENS TLD (${i?.join(", ")}) for chain "${o.name}" (id: ${o.id}).`);const[c]=await getAction$1(e,readContract$1,"readContract")({address:a,abi:[{inputs:[{type:"bytes"}],name:"findResolver",outputs:[{type:"address"},{type:"bytes32"}],stateMutability:"view",type:"function"}],functionName:"findResolver",args:[toHex(packetToBytes(r))],blockNumber:n,blockTag:s});return c}async function createAccessList(e,t){const{account:n=e.account,blockNumber:s,blockTag:r="latest",blobs:o,data:a,gas:i,gasPrice:c,maxFeePerBlobGas:u,maxFeePerGas:l,maxPriorityFeePerGas:d,to:f,value:p,...m}=t;const g=n?parseAccount(n):void 0;try{assertRequest(t);const n="bigint"==typeof s?numberToHex(s):void 0;const y=n||r;const b=e.chain?.formatters?.transactionRequest?.format;const w=b||formatTransactionRequest;const v=w({...extract(m,{format:b}),from:g?.address,blobs:o,data:a,gas:i,gasPrice:c,maxFeePerBlobGas:u,maxFeePerGas:l,maxPriorityFeePerGas:d,to:f,value:p});const x=await e.request({method:"eth_createAccessList",params:[v,y]});return{accessList:x.accessList,gasUsed:BigInt(x.gasUsed)}}catch(y){throw getCallError(y,{...t,account:g,chain:e.chain})}}function createFilterRequestScope(e,{method:t}){const n={};"fallback"===e.transport.type&&e.transport.onResponse?.(({method:e,response:s,status:r,transport:o})=>{"success"===r&&t===e&&(n[s]=o.request)});return t=>n[t]||e.request}async function createBlockFilter(e){const t=createFilterRequestScope(e,{method:"eth_newBlockFilter"});const n=await e.request({method:"eth_newBlockFilter"});return{id:n,request:t(n),type:"block"}}class Po extends Re{constructor(e){super(`Filter type "${e}" is not supported.`,{name:"FilterTypeNotSupportedError"})}}const $o="/docs/contract/encodeEventTopics";function encodeEventTopics(e){const{abi:t,eventName:n,args:s}=e;let r=t[0];if(n){const e=getAbiItem({abi:t,name:n});if(!e)throw new ot(n,{docsPath:$o});r=e}if("event"!==r.type)throw new ot(void 0,{docsPath:$o});const o=formatAbiItem$1(r);const a=Sr(o);let i=[];if(s&&"inputs"in r){const e=r.inputs?.filter(e=>"indexed"in e&&e.indexed);const t=Array.isArray(s)?s:Object.values(s).length>0?e?.map(e=>s[e.name])??[]:[];t.length>0&&(i=e?.map((e,n)=>Array.isArray(t[n])?t[n].map((s,r)=>encodeArg({param:e,value:t[n][r]})):"undefined"!=typeof t[n]&&null!==t[n]?encodeArg({param:e,value:t[n]}):null)??[])}return[a,...i]}function encodeArg({param:e,value:t}){if("string"===e.type||"bytes"===e.type)return keccak256$1(toBytes$2(t));if("tuple"===e.type||e.type.match(/^(.*)\[(\d+)?\]$/))throw new Po(e.type);return encodeAbiParameters([e],[t])}async function createContractEventFilter(e,t){const{address:n,abi:s,args:r,eventName:o,fromBlock:a,strict:i,toBlock:c}=t;const u=createFilterRequestScope(e,{method:"eth_newFilter"});const l=o?encodeEventTopics({abi:s,args:r,eventName:o}):void 0;const d=await e.request({method:"eth_newFilter",params:[{address:n,fromBlock:"bigint"==typeof a?numberToHex(a):a,toBlock:"bigint"==typeof c?numberToHex(c):c,topics:l}]});return{abi:s,args:r,eventName:o,id:d,request:u(d),strict:Boolean(i),type:"event"}}async function createEventFilter(e,{address:t,args:n,event:s,events:r,fromBlock:o,strict:a,toBlock:i}={}){const c=r??(s?[s]:void 0);const u=createFilterRequestScope(e,{method:"eth_newFilter"});let l=[];if(c){const e=c.flatMap(e=>encodeEventTopics({abi:[e],eventName:e.name,args:n}));l=[e];s&&(l=l[0])}const d=await e.request({method:"eth_newFilter",params:[{address:t,fromBlock:"bigint"==typeof o?numberToHex(o):o,toBlock:"bigint"==typeof i?numberToHex(i):i,...l.length?{topics:l}:{}}]});return{abi:c,args:n,eventName:s?s.name:void 0,fromBlock:o,id:d,request:u(d),strict:Boolean(a),toBlock:i,type:"event"}}async function createPendingTransactionFilter(e){const t=createFilterRequestScope(e,{method:"eth_newPendingTransactionFilter"});const n=await e.request({method:"eth_newPendingTransactionFilter"});return{id:n,request:t(n),type:"transaction"}}async function estimateContractGas(e,t){const{abi:n,address:s,args:r,functionName:o,dataSuffix:a,...i}=t;const c=encodeFunctionData({abi:n,args:r,functionName:o});try{const t=await getAction$1(e,estimateGas$1,"estimateGas")({data:`${c}${a?a.replace("0x",""):""}`,to:s,...i});return t}catch(u){const e=i.account?parseAccount(i.account):void 0;throw getContractError(u,{abi:n,address:s,args:r,docsPath:"/docs/contract/estimateContractGas",functionName:o,sender:e?.address})}}async function getBlobBaseFee(e){const t=await e.request({method:"eth_blobBaseFee"});return BigInt(t)}const Eo=new Map;const Ao=new Map;function getCache(e){const buildCache=(e,t)=>({clear:()=>t.delete(e),get:()=>t.get(e),set:n=>t.set(e,n)});const t=buildCache(e,Eo);const n=buildCache(e,Ao);return{clear:()=>{t.clear();n.clear()},promise:t,response:n}}async function withCache(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const s=getCache(t);const r=s.response.get();if(r&&n>0){const e=(new Date).getTime()-r.created.getTime();if(e<n)return r.data}let o=s.promise.get();if(!o){o=e();s.promise.set(o)}try{const e=await o;s.response.set({created:new Date,data:e});return e}finally{s.promise.clear()}}const cacheKey=e=>`blockNumber.${e}`;async function getBlockNumber(e,{cacheTime:t=e.cacheTime}={}){const n=await withCache(()=>e.request({method:"eth_blockNumber"}),{cacheKey:cacheKey(e.uid),cacheTime:t});return BigInt(n)}async function getBlockTransactionCount(e,{blockHash:t,blockNumber:n,blockTag:s="latest"}={}){const r=void 0!==n?numberToHex(n):void 0;let o;o=t?await e.request({method:"eth_getBlockTransactionCountByHash",params:[t]},{dedupe:!0}):await e.request({method:"eth_getBlockTransactionCountByNumber",params:[r||s]},{dedupe:Boolean(r)});return hexToNumber$1(o)}async function getCode(e,{address:t,blockNumber:n,blockTag:s="latest"}){const r=void 0!==n?numberToHex(n):void 0;const o=await e.request({method:"eth_getCode",params:[t,r||s]},{dedupe:Boolean(r)});if("0x"!==o)return o}function isAddressEqual(e,t){if(!isAddress(e,{strict:!1}))throw new bt({address:e});if(!isAddress(t,{strict:!1}))throw new bt({address:t});return e.toLowerCase()===t.toLowerCase()}const To="/docs/contract/decodeEventLog";function decodeEventLog(e){const{abi:t,data:n,strict:s,topics:r}=e;const o=s??!0;const[a,...i]=r;if(!a)throw new st({docsPath:To});const c=t.find(e=>"event"===e.type&&a===Sr(formatAbiItem$1(e)));if(!c||!("name"in c)||"event"!==c.type)throw new rt(a,{docsPath:To});const{name:u,inputs:l}=c;const d=l?.some(e=>!("name"in e&&e.name));const f=d?[]:{};const p=l.map((e,t)=>[e,t]).filter(([e])=>"indexed"in e&&e.indexed);for(let y=0;y<p.length;y++){const[e,t]=p[y];const n=i[y];if(!n)throw new ht({abiItem:c,param:e});f[d?t:e.name||t]=decodeTopic({param:e,value:n})}const m=l.filter(e=>!("indexed"in e&&e.indexed));if(m.length>0)if(n&&"0x"!==n)try{const e=decodeAbiParameters(m,n);if(e)if(d)for(let t=0;t<l.length;t++)f[t]=f[t]??e.shift();else for(let t=0;t<m.length;t++)f[m[t].name]=e[t]}catch(g){if(o){if(g instanceof Qe||g instanceof tn)throw new dt({abiItem:c,data:n,params:m,size:size$4(n)});throw g}}else if(o)throw new dt({abiItem:c,data:"0x",params:m,size:0});return{eventName:u,args:Object.values(f).length>0?f:void 0}}function decodeTopic({param:e,value:t}){if("string"===e.type||"bytes"===e.type||"tuple"===e.type||e.type.match(/^(.*)\[(\d+)?\]$/))return t;const n=decodeAbiParameters([e],t)||[];return n[0]}function parseEventLogs(e){const{abi:t,args:n,logs:s,strict:r=!0}=e;const o=(()=>{if(e.eventName)return Array.isArray(e.eventName)?e.eventName:[e.eventName]})();return s.map(e=>{try{const s=t.find(t=>"event"===t.type&&e.topics[0]===Sr(t));if(!s)return null;const a=decodeEventLog({...e,abi:[s],strict:r});return o&&!o.includes(a.eventName)?null:includesArgs({args:a.args,inputs:s.inputs,matchArgs:n})?{...a,...e}:null}catch(s){let t;let n;if(s instanceof rt)return null;if(s instanceof dt||s instanceof ht){if(r)return null;t=s.abiItem.name;n=s.abiItem.inputs?.some(e=>!("name"in e&&e.name))}return{...e,args:n?[]:{},eventName:t}}}).filter(Boolean)}function includesArgs(e){const{args:t,inputs:n,matchArgs:s}=e;if(!s)return!0;if(!t)return!1;function isEqual(e,t,n){try{return"address"===e.type?isAddressEqual(t,n):"string"===e.type||"bytes"===e.type?keccak256$1(toBytes$2(t))===n:t===n}catch{return!1}}return Array.isArray(t)&&Array.isArray(s)?s.every((e,s)=>{if(null==e)return!0;const r=n[s];if(!r)return!1;const o=Array.isArray(e)?e:[e];return o.some(e=>isEqual(r,e,t[s]))}):"object"==typeof t&&!Array.isArray(t)&&"object"==typeof s&&!Array.isArray(s)&&Object.entries(s).every(([e,s])=>{if(null==s)return!0;const r=n.find(t=>t.name===e);if(!r)return!1;const o=Array.isArray(s)?s:[s];return o.some(n=>isEqual(r,n,t[e]))})}function formatLog(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}async function getLogs(e,{address:t,blockHash:n,fromBlock:s,toBlock:r,event:o,events:a,args:i,strict:c}={}){const u=c??!1;const l=a??(o?[o]:void 0);let d=[];if(l){const e=l.flatMap(e=>encodeEventTopics({abi:[e],eventName:e.name,args:a?void 0:i}));d=[e];o&&(d=d[0])}let f;f=n?await e.request({method:"eth_getLogs",params:[{address:t,topics:d,blockHash:n}]}):await e.request({method:"eth_getLogs",params:[{address:t,topics:d,fromBlock:"bigint"==typeof s?numberToHex(s):s,toBlock:"bigint"==typeof r?numberToHex(r):r}]});const p=f.map(e=>formatLog(e));return l?parseEventLogs({abi:l,args:i,logs:p,strict:u}):p}async function getContractEvents(e,t){const{abi:n,address:s,args:r,blockHash:o,eventName:a,fromBlock:i,toBlock:c,strict:u}=t;const l=a?getAbiItem({abi:n,name:a}):void 0;const d=l?void 0:n.filter(e=>"event"===e.type);return getAction$1(e,getLogs,"getLogs")({address:s,args:r,blockHash:o,event:l,events:d,fromBlock:i,toBlock:c,strict:u})}class Io extends Re{constructor({address:e}){super(`No EIP-712 domain found on contract "${e}".`,{metaMessages:["Ensure that:",`- The contract is deployed at the address "${e}".`,"- `eip712Domain()` function exists on the contract.","- `eip712Domain()` function matches signature to ERC-5267 specification."],name:"Eip712DomainNotFoundError"})}}async function getEip712Domain(e,t){const{address:n,factory:s,factoryData:r}=t;try{const[t,o,a,i,c,u,l]=await getAction$1(e,readContract$1,"readContract")({abi:So,address:n,functionName:"eip712Domain",factory:s,factoryData:r});return{domain:{name:o,version:a,chainId:Number(i),verifyingContract:c,salt:u},extensions:l,fields:t}}catch(o){const e=o;if("ContractFunctionExecutionError"===e.name&&"ContractFunctionZeroDataError"===e.cause.name)throw new Io({address:n});throw e}}const So=[{inputs:[],name:"eip712Domain",outputs:[{name:"fields",type:"bytes1"},{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"},{name:"salt",type:"bytes32"},{name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function"}];function formatFeeHistory(e){return{baseFeePerGas:e.baseFeePerGas.map(e=>BigInt(e)),gasUsedRatio:e.gasUsedRatio,oldestBlock:BigInt(e.oldestBlock),reward:e.reward?.map(e=>e.map(e=>BigInt(e)))}}async function getFeeHistory(e,{blockCount:t,blockNumber:n,blockTag:s="latest",rewardPercentiles:r}){const o="bigint"==typeof n?numberToHex(n):void 0;const a=await e.request({method:"eth_feeHistory",params:[numberToHex(t),o||s,r]},{dedupe:Boolean(o)});return formatFeeHistory(a)}async function getFilterChanges(e,{filter:t}){const n="strict"in t&&t.strict;const s=await t.request({method:"eth_getFilterChanges",params:[t.id]});if("string"==typeof s[0])return s;const r=s.map(e=>formatLog(e));return"abi"in t&&t.abi?parseEventLogs({abi:t.abi,logs:r,strict:n}):r}async function getFilterLogs(e,{filter:t}){const n=t.strict??!1;const s=await t.request({method:"eth_getFilterLogs",params:[t.id]});const r=s.map(e=>formatLog(e));return t.abi?parseEventLogs({abi:t.abi,logs:r,strict:n}):r}async function getStorageAt(e,{address:t,blockNumber:n,blockTag:s="latest",slot:r}){const o=void 0!==n?numberToHex(n):void 0;const a=await e.request({method:"eth_getStorageAt",params:[t,r,o||s]});return a}async function getTransaction(e,{blockHash:t,blockNumber:n,blockTag:s,hash:r,index:o}){const a=s||"latest";const i=void 0!==n?numberToHex(n):void 0;let c=null;c=r?await e.request({method:"eth_getTransactionByHash",params:[r]},{dedupe:!0}):t?await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,numberToHex(o)]},{dedupe:!0}):await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[i||a,numberToHex(o)]},{dedupe:Boolean(i)});if(!c)throw new Sn({blockHash:t,blockNumber:n,blockTag:a,hash:r,index:o});const u=e.chain?.formatters?.transaction?.format||formatTransaction;return u(c)}async function getTransactionConfirmations(e,{hash:t,transactionReceipt:n}){const[s,r]=await Promise.all([getAction$1(e,getBlockNumber,"getBlockNumber")({}),t?getAction$1(e,getTransaction,"getTransaction")({hash:t}):void 0]);const o=n?.blockNumber||r?.blockNumber;return o?s-o+1n:0n}const ko={"0x0":"reverted","0x1":"success"};function formatTransactionReceipt(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(e=>formatLog(e)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?hexToNumber$1(e.transactionIndex):null,status:e.status?ko[e.status]:null,type:e.type?gs[e.type]||e.type:null};e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice));e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed));return t}async function getTransactionReceipt(e,{hash:t}){const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new kn({hash:t});const s=e.chain?.formatters?.transactionReceipt?.format||formatTransactionReceipt;return s(n)}async function multicall$1(e,t){const{account:n,allowFailure:s=!0,batchSize:r,blockNumber:o,blockTag:a,multicallAddress:i,stateOverride:c}=t;const u=t.contracts;const l=r??("object"==typeof e.batch?.multicall&&e.batch.multicall.batchSize||1024);let d=i;if(!d){if(!e.chain)throw new Error("client chain not configured. multicallAddress is required.");d=getChainContractAddress({blockNumber:o,chain:e.chain,contract:"multicall3"})}const f=[[]];let p=0;let m=0;for(let w=0;w<u.length;w++){const{abi:e,address:t,args:r,functionName:o}=u[w];try{const n=encodeFunctionData({abi:e,args:r,functionName:o});m+=(n.length-2)/2;if(l>0&&m>l&&f[p].length>0){p++;m=(n.length-2)/2;f[p]=[]}f[p]=[...f[p],{allowFailure:!0,callData:n,target:t}]}catch(b){const a=getContractError(b,{abi:e,address:t,args:r,docsPath:"/docs/contract/multicall",functionName:o,sender:n});if(!s)throw a;f[p]=[...f[p],{allowFailure:!0,callData:"0x",target:t}]}}const g=await Promise.allSettled(f.map(t=>getAction$1(e,readContract$1,"readContract")({abi:zs,account:n,address:d,args:[t],blockNumber:o,blockTag:a,functionName:"aggregate3",stateOverride:c})));const y=[];for(let w=0;w<g.length;w++){const e=g[w];if("rejected"===e.status){if(!s)throw e.reason;for(let t=0;t<f[w].length;t++)y.push({status:"failure",error:e.reason,result:void 0});continue}const t=e.value;for(let n=0;n<t.length;n++){const{returnData:e,success:r}=t[n];const{callData:o}=f[w][n];const{abi:a,address:i,functionName:c,args:l}=u[y.length];try{if("0x"===o)throw new Ze;if(!r)throw new qr({data:e});const t=decodeFunctionResult({abi:a,args:l,data:e,functionName:c});y.push(s?{result:t,status:"success"}:t)}catch(b){const e=getContractError(b,{abi:a,address:i,args:l,docsPath:"/docs/contract/multicall",functionName:c});if(!s)throw e;y.push({error:e,result:void 0,status:"failure"})}}}if(y.length!==u.length)throw new Re("multicall results mismatch");return y}async function simulateBlocks(e,t){const{blockNumber:n,blockTag:s=e.experimental_blockTag??"latest",blocks:r,returnFullTransactions:o,traceTransfers:a,validation:i}=t;try{const t=[];for(const e of r){const n=e.blockOverrides?toRpc(e.blockOverrides):void 0;const s=e.calls.map(e=>{const t=e;const n=t.account?parseAccount(t.account):void 0;const s=t.abi?encodeFunctionData(t):t.data;const r={...t,data:t.dataSuffix?concat$1([s||"0x",t.dataSuffix]):s,from:t.from??n?.address};assertRequest(r);return formatTransactionRequest(r)});const r=e.stateOverrides?serializeStateOverride(e.stateOverrides):void 0;t.push({blockOverrides:n,calls:s,stateOverrides:r})}const c="bigint"==typeof n?numberToHex(n):void 0;const u=c||s;const l=await e.request({method:"eth_simulateV1",params:[{blockStateCalls:t,returnFullTransactions:o,traceTransfers:a,validation:i},u]});return l.map((e,t)=>({...formatBlock(e),calls:e.calls.map((e,n)=>{const{abi:s,args:o,functionName:a,to:i}=r[t].calls[n];const c=e.error?.data??e.returnData;const u=BigInt(e.gasUsed);const l=e.logs?.map(e=>formatLog(e));const d="0x1"===e.status?"success":"failure";const f=s&&"success"===d&&"0x"!==c?decodeFunctionResult({abi:s,data:c,functionName:a}):null;const p=(()=>{if("success"===d)return;let t;"0x"===e.error?.data?t=new Ze:e.error&&(t=new qr(e.error));return t?getContractError(t,{abi:s??[],address:i??"0x",args:o,functionName:a??"<unknown>"}):void 0})();return{data:c,gasUsed:u,logs:l,status:d,..."success"===d?{result:f}:{error:p}}})}))}catch(c){const e=c;const t=getNodeError(e,{});if(t instanceof En)throw e;throw t}}const Bo=BigInt(2**32-1);const Co=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&Bo),l:Number(e>>Co&Bo)}:{h:0|Number(e>>Co&Bo),l:0|Number(e&Bo)}}function split(e,t=!1){const n=e.length;let s=new Uint32Array(n);let r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:n,l:a}=fromBig(e[o],t);[s[o],r[o]]=[n,a]}return[s,r]}const rotlSH=(e,t,n)=>e<<n|t>>>32-n;const rotlSL=(e,t,n)=>t<<n|e>>>32-n;const rotlBH=(e,t,n)=>t<<n-32|e>>>64-n;const rotlBL=(e,t,n)=>e<<n-32|t>>>64-n;const Oo=BigInt(0);const Fo=BigInt(1);const No=BigInt(2);const Ro=BigInt(7);const Mo=BigInt(256);const zo=BigInt(113);const jo=[];const qo=[];const Lo=[];for(let vc=0,xc=Fo,Pc=1,$c=0;vc<24;vc++){[Pc,$c]=[$c,(2*Pc+3*$c)%5];jo.push(2*(5*$c+Pc));qo.push((vc+1)*(vc+2)/2%64);let e=Oo;for(let t=0;t<7;t++){xc=(xc<<Fo^(xc>>Ro)*zo)%Mo;xc&No&&(e^=Fo<<(Fo<<BigInt(t))-Fo)}Lo.push(e)}const Ho=split(Lo,!0);const Uo=Ho[0];const _o=Ho[1];const rotlH=(e,t,n)=>n>32?rotlBH(e,t,n):rotlSH(e,t,n);const rotlL=(e,t,n)=>n>32?rotlBL(e,t,n):rotlSL(e,t,n);function keccakP(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let s=0;s<10;s++)n[s]=e[s]^e[s+10]^e[s+20]^e[s+30]^e[s+40];for(let s=0;s<10;s+=2){const t=(s+8)%10;const r=(s+2)%10;const o=n[r];const a=n[r+1];const i=rotlH(o,a,1)^n[t];const c=rotlL(o,a,1)^n[t+1];for(let n=0;n<50;n+=10){e[s+n]^=i;e[s+n+1]^=c}}let t=e[2];let r=e[3];for(let n=0;n<24;n++){const s=qo[n];const o=rotlH(t,r,s);const a=rotlL(t,r,s);const i=jo[n];t=e[i];r=e[i+1];e[i]=o;e[i+1]=a}for(let s=0;s<50;s+=10){for(let t=0;t<10;t++)n[t]=e[s+t];for(let t=0;t<10;t++)e[s+t]^=~n[(t+2)%10]&n[(t+4)%10]}e[0]^=Uo[s];e[1]^=_o[s]}clean(n)}class Do extends Wr{constructor(e,t,n,s=!1,r=24){super();this.pos=0;this.posOut=0;this.finished=!1;this.destroyed=!1;this.enableXOF=!1;this.blockLen=e;this.suffix=t;this.outputLen=n;this.enableXOF=s;this.rounds=r;anumber(n);if(!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200);this.state32=u32(this.state)}clone(){return this._cloneInto()}keccak(){Gr(this.state32);keccakP(this.state32,this.rounds);Gr(this.state32);this.posOut=0;this.pos=0}update(e){aexists(this);e=toBytes(e);abytes(e);const{blockLen:t,state:n}=this;const s=e.length;for(let r=0;r<s;){const o=Math.min(t-this.pos,s-r);for(let t=0;t<o;t++)n[this.pos++]^=e[r++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:s}=this;e[n]^=t;128&t&&n===s-1&&this.keccak();e[s-1]^=128;this.keccak()}writeInto(e){aexists(this,!1);abytes(e);this.finish();const t=this.state;const{blockLen:n}=this;for(let s=0,r=e.length;s<r;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,r-s);e.set(t.subarray(this.posOut,this.posOut+o),s);this.posOut+=o;s+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){anumber(e);return this.xofInto(new Uint8Array(e))}digestInto(e){aoutput(e,this);if(this.finished)throw new Error("digest() was already called");this.writeInto(e);this.destroy();return e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0;clean(this.state)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:s,rounds:r,enableXOF:o}=this;e||(e=new Do(t,n,s,o,r));e.state32.set(this.state32);e.pos=this.pos;e.posOut=this.posOut;e.finished=this.finished;e.rounds=r;e.suffix=n;e.outputLen=s;e.enableXOF=o;e.destroyed=this.destroyed;return e}}const gen=(e,t,n)=>createHasher(()=>new Do(t,e,n));const Go=(()=>gen(1,136,32))();function keccak256(e,t={}){const{as:n=("string"==typeof e?"Hex":"Bytes")}=t;const s=Go(from$3(e));return"Bytes"===n?s:fromBytes(s)}class Wo extends Map{constructor(e){super();Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.maxSize=e}get(e){const t=super.get(e);if(super.has(e)&&void 0!==t){this.delete(e);super.set(e,t)}return t}set(e,t){super.set(e,t);if(this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}}const Vo={checksum:new Wo(8192)};const Ko=Vo.checksum;const Qo=/^0x[a-fA-F0-9]{40}$/;function assert(e,t={}){const{strict:n=!0}=t;if(!Qo.test(e))throw new Zo({address:e,cause:new Jo});if(n){if(e.toLowerCase()===e)return;if(checksum(e)!==e)throw new Zo({address:e,cause:new Yo})}}function checksum(e){if(Ko.has(e))return Ko.get(e);assert(e,{strict:!1});const t=e.substring(2).toLowerCase();const n=keccak256(fromString$1(t),{as:"Bytes"});const s=t.split("");for(let o=0;o<40;o+=2){n[o>>1]>>4>=8&&s[o]&&(s[o]=s[o].toUpperCase());(15&n[o>>1])>=8&&s[o+1]&&(s[o+1]=s[o+1].toUpperCase())}const r=`0x${s.join("")}`;Ko.set(e,r);return r}function validate(e,t={}){const{strict:n=!0}=t??{};try{assert(e,{strict:n});return!0}catch{return!1}}class Zo extends Kr{constructor({address:e,cause:t}){super(`Address "${e}" is invalid.`,{cause:t});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class Jo extends Kr{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class Yo extends Kr{constructor(){super("Address does not match its checksum counterpart.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}function normalizeSignature(e){let t=!0;let n="";let s=0;let r="";let o=!1;for(let a=0;a<e.length;a++){const i=e[a];["(",")",","].includes(i)&&(t=!0);"("===i&&s++;")"===i&&s--;if(t)if(0!==s){if(" "!==i){r+=i;n+=i}else if(","!==e[a-1]&&","!==n&&",("!==n){n="";t=!1}}else if(" "===i&&["event","function","error",""].includes(r))r="";else{r+=i;if(")"===i){o=!0;break}}}if(!o)throw new Kr("Unable to normalize signature.");return r}function isArgOfType(e,t){const n=typeof e;const s=t.type;switch(s){case"address":return validate(e,{strict:!1});case"bool":return"boolean"===n;case"function":case"string":return"string"===n;default:return"tuple"===s&&"components"in t?Object.values(t.components).every((t,n)=>isArgOfType(Object.values(e)[n],t)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?"number"===n||"bigint"===n:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?"string"===n||e instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)&&(Array.isArray(e)&&e.every(e=>isArgOfType(e,{...t,type:s.replace(/(\[[0-9]{0,}\])$/,"")})))}}function getAmbiguousTypes(e,t,n){for(const s in e){const r=e[s];const o=t[s];if("tuple"===r.type&&"tuple"===o.type&&"components"in r&&"components"in o)return getAmbiguousTypes(r.components,o.components,n[s]);const a=[r.type,o.type];const i=(()=>!(!a.includes("address")||!a.includes("bytes20"))||(a.includes("address")&&a.includes("string")||!(!a.includes("address")||!a.includes("bytes")))&&validate(n[s],{strict:!1}))();if(i)return a}}function from$2(e,t={}){const{prepare:n=!0}=t;const s=(()=>Array.isArray(e)||"string"==typeof e?parseAbiItem(e):e)();return{...s,...n?{hash:getSignatureHash(s)}:{}}}function fromAbi$1(e,t,n){const{args:s=[],prepare:r=!0}=n??{};const o=validate$1(t,{strict:!1});const a=e.filter(e=>o?"function"===e.type||"error"===e.type?getSelector$1(e)===slice(t,0,4):"event"===e.type&&getSignatureHash(e)===t:"name"in e&&e.name===t);if(0===a.length)throw new ea({name:t});if(1===a.length)return{...a[0],...r?{hash:getSignatureHash(a[0])}:{}};let i;for(const u of a){if(!("inputs"in u))continue;if(!s||0===s.length){if(!u.inputs||0===u.inputs.length)return{...u,...r?{hash:getSignatureHash(u)}:{}};continue}if(!u.inputs)continue;if(0===u.inputs.length)continue;if(u.inputs.length!==s.length)continue;const e=s.every((e,t)=>{const n="inputs"in u&&u.inputs[t];return!!n&&isArgOfType(e,n)});if(e){if(i&&"inputs"in i&&i.inputs){const e=getAmbiguousTypes(u.inputs,i.inputs,s);if(e)throw new Xo({abiItem:u,type:e[0]},{abiItem:i,type:e[1]})}i=u}}const c=(()=>{if(i)return i;const[e,...t]=a;return{...e,overloads:t}})();if(!c)throw new ea({name:t});return{...c,...r?{hash:getSignatureHash(c)}:{}}}function getSelector$1(e){return slice(getSignatureHash(e),0,4)}function getSignature(e){const t=(()=>"string"==typeof e?e:formatAbiItem(e))();return normalizeSignature(t)}function getSignatureHash(e){return"string"!=typeof e&&"hash"in e&&e.hash?e.hash:keccak256(fromString(getSignature(e)))}class Xo extends Kr{constructor(e,t){super("Found ambiguous types in overloaded ABI Items.",{metaMessages:[`\`${e.type}\` in \`${normalizeSignature(formatAbiItem(e.abiItem))}\`, and`,`\`${t.type}\` in \`${normalizeSignature(formatAbiItem(t.abiItem))}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.AmbiguityError"})}}class ea extends Kr{constructor({name:e,data:t,type:n="item"}){const s=(()=>e?` with name "${e}"`:t?` with data "${t}"`:"")();super(`ABI ${n}${s} not found.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.NotFoundError"})}}const ta=/^(.*)\[([0-9]*)\]$/;const na=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;const sa=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function prepareParameters({checksumAddress:e,parameters:t,values:n}){const s=[];for(let r=0;r<t.length;r++)s.push(prepareParameter({checksumAddress:e,parameter:t[r],value:n[r]}));return s}function prepareParameter({checksumAddress:e=!1,parameter:t,value:n}){const s=t;const r=getArrayComponents(s.type);if(r){const[t,o]=r;return encodeArray(n,{checksumAddress:e,length:t,parameter:{...s,type:o}})}if("tuple"===s.type)return encodeTuple(n,{checksumAddress:e,parameter:s});if("address"===s.type)return encodeAddress(n,{checksum:e});if("bool"===s.type)return encodeBoolean(n);if(s.type.startsWith("uint")||s.type.startsWith("int")){const e=s.type.startsWith("int");const[,,t="256"]=sa.exec(s.type)??[];return encodeNumber(n,{signed:e,size:Number(t)})}if(s.type.startsWith("bytes"))return encodeBytes(n,{type:s.type});if("string"===s.type)return encodeString(n);throw new ca(s.type)}function encode$3(e){let t=0;for(let o=0;o<e.length;o++){const{dynamic:n,encoded:s}=e[o];t+=n?32:size$2(s)}const n=[];const s=[];let r=0;for(let o=0;o<e.length;o++){const{dynamic:a,encoded:i}=e[o];if(a){n.push(fromNumber(t+r,{size:32}));s.push(i);r+=size$2(i)}else n.push(i)}return concat(...n,...s)}function encodeAddress(e,t){const{checksum:n=!1}=t;assert(e,{strict:n});return{dynamic:!1,encoded:padLeft(e.toLowerCase())}}function encodeArray(e,t){const{checksumAddress:n,length:s,parameter:r}=t;const o=null===s;if(!Array.isArray(e))throw new ia(e);if(!o&&e.length!==s)throw new ra({expectedLength:s,givenLength:e.length,type:`${r.type}[${s}]`});let a=!1;const i=[];for(let c=0;c<e.length;c++){const t=prepareParameter({checksumAddress:n,parameter:r,value:e[c]});t.dynamic&&(a=!0);i.push(t)}if(o||a){const e=encode$3(i);if(o){const t=fromNumber(i.length,{size:32});return{dynamic:!0,encoded:i.length>0?concat(t,e):t}}if(a)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:concat(...i.map(({encoded:e})=>e))}}function encodeBytes(e,{type:t}){const[,n]=t.split("bytes");const s=size$2(e);if(!n){let t=e;s%32!=0&&(t=padRight(t,32*Math.ceil((e.length-2)/2/32)));return{dynamic:!0,encoded:concat(padLeft(fromNumber(s,{size:32})),t)}}if(s!==Number.parseInt(n))throw new oa({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:padRight(e)}}function encodeBoolean(e){if("boolean"!=typeof e)throw new Kr(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:padLeft(fromBoolean(e))}}function encodeNumber(e,{signed:t,size:n}){if("number"==typeof n){const s=2n**(BigInt(n)-(t?1n:0n))-1n;const r=t?-s-1n:0n;if(e>s||e<r)throw new no({max:s.toString(),min:r.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:fromNumber(e,{size:32,signed:t})}}function encodeString(e){const t=fromString(e);const n=Math.ceil(size$2(t)/32);const s=[];for(let r=0;r<n;r++)s.push(padRight(slice(t,32*r,32*(r+1))));return{dynamic:!0,encoded:concat(padRight(fromNumber(size$2(t),{size:32})),...s)}}function encodeTuple(e,t){const{checksumAddress:n,parameter:s}=t;let r=!1;const o=[];for(let a=0;a<s.components.length;a++){const t=s.components[a];const i=Array.isArray(e)?a:t.name;const c=prepareParameter({checksumAddress:n,parameter:t,value:e[i]});o.push(c);c.dynamic&&(r=!0)}return{dynamic:r,encoded:r?encode$3(o):concat(...o.map(({encoded:e})=>e))}}function getArrayComponents(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}function encode$2(e,t,n){const{checksumAddress:s=!1}={};if(e.length!==t.length)throw new aa({expectedLength:e.length,givenLength:t.length});const r=prepareParameters({checksumAddress:s,parameters:e,values:t});const o=encode$3(r);return 0===o.length?"0x":o}function encodePacked$1(e,t){if(e.length!==t.length)throw new aa({expectedLength:e.length,givenLength:t.length});const n=[];for(let s=0;s<e.length;s++){const r=e[s];const o=t[s];n.push(encodePacked$1.encode(r,o))}return concat(...n)}!function(e){function encode2(e,t,n=!1){if("address"===e){const e=t;assert(e);return padLeft(e.toLowerCase(),n?32:0)}if("string"===e)return fromString(t);if("bytes"===e)return t;if("bool"===e)return padLeft(fromBoolean(t),n?32:1);const s=e.match(sa);if(s){const[e,r,o="256"]=s;const a=Number.parseInt(o)/8;return fromNumber(t,{size:n?32:a,signed:"int"===r})}const r=e.match(na);if(r){const[e,s]=r;if(Number.parseInt(s)!==(t.length-2)/2)throw new oa({expectedSize:Number.parseInt(s),value:t});return padRight(t,n?32:0)}const o=e.match(ta);if(o&&Array.isArray(t)){const[e,n]=o;const s=[];for(let r=0;r<t.length;r++)s.push(encode2(n,t[r],!0));return 0===s.length?"0x":concat(...s)}throw new ca(e)}e.encode=encode2}(encodePacked$1||(encodePacked$1={}));class ra extends Kr{constructor({expectedLength:e,givenLength:t,type:n}){super(`Array length mismatch for type \`${n}\`. Expected: \`${e}\`. Given: \`${t}\`.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ArrayLengthMismatchError"})}}class oa extends Kr{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${size$2(t)}) does not match expected size (bytes${e}).`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.BytesSizeMismatchError"})}}class aa extends Kr{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding parameters/values length mismatch.",`Expected length (parameters): ${e}`,`Given length (values): ${t}`].join("\n"));Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.LengthMismatchError"})}}class ia extends Kr{constructor(e){super(`Value \`${e}\` is not a valid array.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidArrayError"})}}class ca extends Kr{constructor(e){super(`Type \`${e}\` is not a valid ABI Type.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidTypeError"})}}function encode$1(e,t){const{bytecode:n,args:s}=t;return concat(n,e.inputs?.length&&s?.length?encode$2(e.inputs,s):"0x")}function from$1(e){return from$2(e)}function encodeData$1(e,...t){const{overloads:n}=e;const s=n?fromAbi([e,...n],e.name,{args:t[0]}):e;const r=getSelector(s);const o=t.length>0?encode$2(s.inputs,t[0]):void 0;return o?concat(r,o):r}function from(e,t={}){return from$2(e,t)}function fromAbi(e,t,n){const s=fromAbi$1(e,t,n);if("function"!==s.type)throw new ea({name:t,type:"function"});return s}function getSelector(e){return getSelector$1(e)}const ua="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";const la="0x0000000000000000000000000000000000000000";const da=new wt(8192);function withDedupe(e,{enabled:t=!0,id:n}){if(!t||!n)return e();if(da.get(n))return da.get(n);const s=e().finally(()=>da.delete(n));da.set(n,s);return s}async function wait(e){return new Promise(t=>setTimeout(t,e))}function withRetry(e,{delay:t=100,retryCount:n=2,shouldRetry:s=()=>!0}={}){return new Promise((r,o)=>{const attemptRetry=async({count:a=0}={})=>{const retry=async({error:e})=>{const n="function"==typeof t?t({count:a,error:e}):t;n&&await wait(n);attemptRetry({count:a+1})};try{const t=await e();r(t)}catch(i){if(a<n&&await s({count:a,error:i}))return retry({error:i});o(i)}};attemptRetry()})}function buildRequest(e,t={}){return async(n,s={})=>{const{dedupe:r=!1,methods:o,retryDelay:a=150,retryCount:i=3,uid:c}={...t,...s};const{method:u}=n;if(o?.exclude?.includes(u))throw new Wn(new Error("method not supported"),{method:u});if(o?.include&&!o.include.includes(u))throw new Wn(new Error("method not supported"),{method:u});const l=r?stringToHex(`${c}.${stringify$1(n)}`):void 0;return withDedupe(()=>withRetry(async()=>{try{return await e(n)}catch(t){const e=t;switch(e.code){case zn.code:throw new zn(e);case jn.code:throw new jn(e);case qn.code:throw new qn(e,{method:n.method});case Ln.code:throw new Ln(e);case Hn.code:throw new Hn(e);case Un.code:throw new Un(e);case _n.code:throw new _n(e);case Dn.code:throw new Dn(e);case Gn.code:throw new Gn(e);case Wn.code:throw new Wn(e,{method:n.method});case Vn.code:throw new Vn(e);case Kn.code:throw new Kn(e);case Qn.code:throw new Qn(e);case Zn.code:throw new Zn(e);case Jn.code:throw new Jn(e);case Yn.code:throw new Yn(e);case Xn.code:throw new Xn(e);case es.code:throw new es(e);case ts.code:throw new ts(e);case ns.code:throw new ns(e);case ss.code:throw new ss(e);case rs.code:throw new rs(e);case os.code:throw new os(e);case as.code:throw new as(e);case cs.code:throw new cs(e);case 5e3:throw new Qn(e);default:if(t instanceof Re)throw t;throw new us(e)}}},{delay:({count:e,error:t})=>{if(t&&t instanceof Cn){const e=t?.headers?.get("Retry-After");if(e?.match(/\d/))return 1e3*Number.parseInt(e)}return(1<<e)*a},retryCount:i,shouldRetry:({error:e})=>shouldRetry(e)}),{enabled:r,id:l})}}function shouldRetry(e){return"code"in e&&"number"==typeof e.code?-1===e.code||(e.code===Vn.code||e.code===Hn.code):!(e instanceof Cn&&e.status)||(403===e.status||(408===e.status||(413===e.status||(429===e.status||(500===e.status||(502===e.status||(503===e.status||504===e.status)))))))}class ha extends Re{constructor({callbackSelector:e,cause:t,data:n,extraData:s,sender:r,urls:o}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(e=>`    ${getUrl(e)}`)],`  Sender: ${r}`,`  Data: ${n}`,`  Callback selector: ${e}`,`  Extra data: ${s}`].flat(),name:"OffchainLookupError"})}}class fa extends Re{constructor({result:e,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${getUrl(t)}`,`Response: ${stringify$1(e)}`],name:"OffchainLookupResponseMalformedError"})}}class pa extends Re{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}const ma="0x556f1830";const ga={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function offchainLookup(e,{blockNumber:t,blockTag:n,data:s,to:r}){const{args:o}=decodeErrorResult({data:s,abi:[ga]});const[a,i,c,u,l]=o;const{ccipRead:d}=e;const f=d&&"function"==typeof d?.request?d.request:ccipRequest;try{if(!isAddressEqual(r,a))throw new pa({sender:a,to:r});const s=i.includes(Ur)?await localBatchGatewayRequest({data:c,ccipRequest:f}):await f({data:c,sender:a,urls:i});const{data:o}=await call(e,{blockNumber:t,blockTag:n,data:concat$1([u,encodeAbiParameters([{type:"bytes"},{type:"bytes"}],[s,l])]),to:r});return o}catch(p){throw new ha({callbackSelector:u,cause:p,data:s,extraData:l,sender:a,urls:i})}}async function ccipRequest({data:e,sender:t,urls:n}){let s=new Error("An unknown error occurred.");for(let o=0;o<n.length;o++){const a=n[o];const i=a.includes("{data}")?"GET":"POST";const c="POST"===i?{data:e,sender:t}:void 0;const u="POST"===i?{"Content-Type":"application/json"}:{};try{const n=await fetch(a.replace("{sender}",t.toLowerCase()).replace("{data}",e),{body:JSON.stringify(c),headers:u,method:i});let r;r=n.headers.get("Content-Type")?.startsWith("application/json")?(await n.json()).data:await n.text();if(!n.ok){s=new Cn({body:c,details:r?.error?stringify$1(r.error):n.statusText,headers:n.headers,status:n.status,url:a});continue}if(!isHex(r)){s=new fa({result:r,url:a});continue}return r}catch(r){s=new Cn({body:c,details:r.message,url:a})}}throw s}const ya=Object.freeze(Object.defineProperty({__proto__:null,ccipRequest:ccipRequest,offchainLookup:offchainLookup,offchainLookupAbiItem:ga,offchainLookupSignature:ma},Symbol.toStringTag,{value:"Module"}));function defineChain(e){return{formatters:void 0,fees:void 0,serializers:void 0,...e}}function withTimeout(e,{errorInstance:t=new Error("timed out"),timeout:n,signal:s}){return new Promise((r,o)=>{(async()=>{let a;try{const i=new AbortController;n>0&&(a=setTimeout(()=>{s?i.abort():o(t)},n));r(await e({signal:i?.signal||null}))}catch(i){"AbortError"===i?.name&&o(t);o(i)}finally{clearTimeout(a)}})()})}function createIdStore(){return{current:0,take(){return this.current++},reset(){this.current=0}}}const ba=createIdStore();function getHttpRpcClient(e,t={}){return{async request(n){const{body:s,onRequest:r=t.onRequest,onResponse:o=t.onResponse,timeout:a=t.timeout??1e4}=n;const i={...t.fetchOptions??{},...n.fetchOptions??{}};const{headers:c,method:u,signal:l}=i;try{const t=await withTimeout(async({signal:t})=>{const n={...i,body:Array.isArray(s)?stringify$1(s.map(e=>({jsonrpc:"2.0",id:e.id??ba.take(),...e}))):stringify$1({jsonrpc:"2.0",id:s.id??ba.take(),...s}),headers:{"Content-Type":"application/json",...c},method:u||"POST",signal:l||(a>0?t:null)};const o=new Request(e,n);const d=await(r?.(o,n))??{...n,url:e};const f=await fetch(d.url??e,d);return f},{errorInstance:new Fn({body:s,url:e}),timeout:a,signal:!0});o&&await o(t);let n;if(t.headers.get("Content-Type")?.startsWith("application/json"))n=await t.json();else{n=await t.text();try{n=JSON.parse(n||"{}")}catch(d){if(t.ok)throw d;n={error:n}}}if(!t.ok)throw new Cn({body:s,details:stringify$1(n.error)||t.statusText,headers:t.headers,status:t.status,url:e});return n}catch(d){if(d instanceof Cn)throw d;if(d instanceof Fn)throw d;throw new Cn({body:s,cause:d,url:e})}}}}class wa extends Re{constructor({domain:e}){super(`Invalid domain "${stringify$1(e)}".`,{metaMessages:["Must be a valid EIP-712 domain."]})}}class va extends Re{constructor({primaryType:e,types:t}){super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(t))}\`.`,{docsPath:"/api/glossary/Errors#typeddatainvalidprimarytypeerror",metaMessages:["Check that the primary type is a key in `types`."]})}}class xa extends Re{constructor({type:e}){super(`Struct type "${e}" is invalid.`,{metaMessages:["Struct type must not be a Solidity type."],name:"InvalidStructTypeError"})}}function hashTypedData(e){const{domain:t={},message:n,primaryType:s}=e;const r={EIP712Domain:getTypesForEIP712Domain({domain:t}),...e.types};validateTypedData({domain:t,message:n,primaryType:s,types:r});const o=["0x1901"];t&&o.push(hashDomain({domain:t,types:r}));"EIP712Domain"!==s&&o.push(hashStruct({data:n,primaryType:s,types:r}));return keccak256$1(concat$1(o))}function hashDomain({domain:e,types:t}){return hashStruct({data:e,primaryType:"EIP712Domain",types:t})}function hashStruct({data:e,primaryType:t,types:n}){const s=encodeData({data:e,primaryType:t,types:n});return keccak256$1(s)}function encodeData({data:e,primaryType:t,types:n}){const s=[{type:"bytes32"}];const r=[hashType({primaryType:t,types:n})];for(const o of n[t]){const[t,a]=encodeField({types:n,name:o.name,type:o.type,value:e[o.name]});s.push(t);r.push(a)}return encodeAbiParameters(s,r)}function hashType({primaryType:e,types:t}){const n=toHex(encodeType({primaryType:e,types:t}));return keccak256$1(n)}function encodeType({primaryType:e,types:t}){let n="";const s=findTypeDependencies({primaryType:e,types:t});s.delete(e);const r=[e,...Array.from(s).sort()];for(const o of r)n+=`${o}(${t[o].map(({name:e,type:t})=>`${t} ${e}`).join(",")})`;return n}function findTypeDependencies({primaryType:e,types:t},n=new Set){const s=e.match(/^\w*/u);const r=s?.[0];if(n.has(r)||void 0===t[r])return n;n.add(r);for(const o of t[r])findTypeDependencies({primaryType:o.type,types:t},n);return n}function encodeField({types:e,name:t,type:n,value:s}){if(void 0!==e[n])return[{type:"bytes32"},keccak256$1(encodeData({data:s,primaryType:n,types:e}))];if("bytes"===n){const e=s.length%2?"0":"";s=`0x${e+s.slice(2)}`;return[{type:"bytes32"},keccak256$1(s)]}if("string"===n)return[{type:"bytes32"},keccak256$1(toHex(s))];if(n.lastIndexOf("]")===n.length-1){const r=n.slice(0,n.lastIndexOf("["));const o=s.map(n=>encodeField({name:t,type:r,types:e,value:n}));return[{type:"bytes32"},keccak256$1(encodeAbiParameters(o.map(([e])=>e),o.map(([,e])=>e)))]}return[{type:n},s]}function validateTypedData(e){const{domain:t,message:n,primaryType:s,types:r}=e;const validateData=(e,t)=>{for(const n of e){const{name:e,type:s}=n;const o=t[e];const a=s.match(Kt);if(a&&("number"==typeof o||"bigint"==typeof o)){const[e,t,n]=a;numberToHex(o,{signed:"int"===t,size:Number.parseInt(n)/8})}if("address"===s&&"string"==typeof o&&!isAddress(o))throw new bt({address:o});const i=s.match(Vt);if(i){const[e,t]=i;if(t&&size$4(o)!==Number.parseInt(t))throw new lt({expectedSize:Number.parseInt(t),givenSize:size$4(o)})}const c=r[s];if(c){validateReference(s);validateData(c,o)}}};if(r.EIP712Domain&&t){if("object"!=typeof t)throw new wa({domain:t});validateData(r.EIP712Domain,t)}if("EIP712Domain"!==s){if(!r[s])throw new va({primaryType:s,types:r});validateData(r[s],n)}}function getTypesForEIP712Domain({domain:e}){return["string"==typeof e?.name&&{name:"name",type:"string"},e?.version&&{name:"version",type:"string"},("number"==typeof e?.chainId||"bigint"==typeof e?.chainId)&&{name:"chainId",type:"uint256"},e?.verifyingContract&&{name:"verifyingContract",type:"address"},e?.salt&&{name:"salt",type:"bytes32"}].filter(Boolean)}function validateReference(e){if("address"===e||"bool"===e||"string"===e||e.startsWith("bytes")||e.startsWith("uint")||e.startsWith("int"))throw new xa({type:e})}function encodePacked(e,t){if(e.length!==t.length)throw new Xe({expectedLength:e.length,givenLength:t.length});const n=[];for(let s=0;s<e.length;s++){const r=e[s];const o=t[s];n.push(encode(r,o))}return concatHex(n)}function encode(e,t,n=!1){if("address"===e){const e=t;if(!isAddress(e))throw new bt({address:e});return pad$2(e.toLowerCase(),{size:n?32:null})}if("string"===e)return stringToHex(t);if("bytes"===e)return t;if("bool"===e)return pad$2(boolToHex(t),{size:n?32:1});const s=e.match(Kt);if(s){const[e,r,o="256"]=s;const a=Number.parseInt(o)/8;return numberToHex(t,{size:n?32:a,signed:"int"===r})}const r=e.match(Vt);if(r){const[e,s]=r;if(Number.parseInt(s)!==(t.length-2)/2)throw new lt({expectedSize:Number.parseInt(s),givenSize:(t.length-2)/2});return pad$2(t,{dir:"right",size:n?32:null})}const o=e.match(Wt);if(o&&Array.isArray(t)){const[e,n]=o;const s=[];for(let r=0;r<t.length;r++)s.push(encode(n,t[r],!0));return 0===s.length?"0x":concatHex(s)}throw new yt(e)}const Pa="Ethereum Signed Message:\n";function toPrefixedMessage(e){const t=(()=>"string"==typeof e?stringToHex(e):"string"==typeof e.raw?e.raw:bytesToHex$1(e.raw))();const n=stringToHex(`${Pa}${size$4(t)}`);return concat$1([n,t])}function hashMessage(e,t){return keccak256$1(toPrefixedMessage(e),t)}const $a="0x6492649264926492649264926492649264926492649264926492649264926492";function isErc6492Signature(e){return sliceHex(e,-32)===$a}function serializeErc6492Signature(e){const{address:t,data:n,signature:s,to:r="hex"}=e;const o=concatHex([encodeAbiParameters([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,n,s]),$a]);return"hex"===r?o:hexToBytes$1(o)}class Ea extends Re{constructor({value:e}){super(`Number \`${e}\` is not a valid decimal number.`,{name:"InvalidDecimalNumberError"})}}function parseUnits(e,t){if(!/^(-?)([0-9]*)\.?([0-9]*)$/.test(e))throw new Ea({value:e});let[n,s="0"]=e.split(".");const r=n.startsWith("-");r&&(n=n.slice(1));s=s.replace(/(0+)$/,"");if(0===t){1===Math.round(Number(`.${s}`))&&(n=`${BigInt(n)+1n}`);s=""}else if(s.length>t){const[e,r,o]=[s.slice(0,t-1),s.slice(t-1,t),s.slice(t)];const a=Math.round(Number(`${r}.${o}`));s=a>9?`${BigInt(e)+BigInt(1)}0`.padStart(e.length+1,"0"):`${e}${a}`;if(s.length>t){s=s.slice(1);n=`${BigInt(n)+1n}`}s=s.slice(0,t)}else s=s.padEnd(t,"0");return BigInt(`${r?"-":""}${n}${s}`)}function createNonceManager(e){const{source:t}=e;const n=new Map;const s=new wt(8192);const r=new Map;const getKey=({address:e,chainId:t})=>`${e}.${t}`;return{async consume({address:e,chainId:n,client:r}){const o=getKey({address:e,chainId:n});const a=this.get({address:e,chainId:n,client:r});this.increment({address:e,chainId:n});const i=await a;await t.set({address:e,chainId:n},i);s.set(o,i);return i},async increment({address:e,chainId:t}){const s=getKey({address:e,chainId:t});const r=n.get(s)??0;n.set(s,r+1)},async get({address:e,chainId:o,client:a}){const i=getKey({address:e,chainId:o});let c=r.get(i);if(!c){c=(async()=>{try{const n=await t.get({address:e,chainId:o,client:a});const r=s.get(i)??0;if(r>0&&n<=r)return r+1;s.delete(i);return n}finally{this.reset({address:e,chainId:o})}})();r.set(i,c)}const u=n.get(i)??0;return u+await c},reset({address:e,chainId:t}){const s=getKey({address:e,chainId:t});n.delete(s);r.delete(s)}}}const Aa="0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";async function simulateCalls(e,t){const{blockNumber:n,blockTag:s,calls:r,stateOverrides:o,traceAssetChanges:a,traceTransfers:i,validation:c}=t;const u=t.account?parseAccount(t.account):void 0;if(a&&!u)throw new Re("`account` is required when `traceAssetChanges` is true");const l=u?encode$1(from$1("constructor(bytes, bytes)"),{bytecode:uo,args:[Aa,encodeData$1(from("function getBalance(address)"),[u.address])]}):void 0;const d=a?await Promise.all(t.calls.map(async t=>{if(!t.data&&!t.abi)return;const{accessList:n}=await createAccessList(e,{account:u.address,...t,data:t.abi?encodeFunctionData(t):t.data});return n.map(({address:e,storageKeys:t})=>t.length>0?e:null)})).then(e=>e.flat().filter(Boolean)):[];const f=await simulateBlocks(e,{blockNumber:n,blockTag:s,blocks:[...a?[{calls:[{data:l}],stateOverrides:o},{calls:d.map((e,t)=>({abi:[from("function balanceOf(address) returns (uint256)")],functionName:"balanceOf",args:[u.address],to:e,from:la,nonce:t})),stateOverrides:[{address:la,nonce:0}]}]:[],{calls:[...r,{}].map(e=>({...e,from:u?.address})),stateOverrides:o},...a?[{calls:[{data:l}]},{calls:d.map((e,t)=>({abi:[from("function balanceOf(address) returns (uint256)")],functionName:"balanceOf",args:[u.address],to:e,from:la,nonce:t})),stateOverrides:[{address:la,nonce:0}]},{calls:d.map((e,t)=>({to:e,abi:[from("function decimals() returns (uint256)")],functionName:"decimals",from:la,nonce:t})),stateOverrides:[{address:la,nonce:0}]},{calls:d.map((e,t)=>({to:e,abi:[from("function tokenURI(uint256) returns (string)")],functionName:"tokenURI",args:[0n],from:la,nonce:t})),stateOverrides:[{address:la,nonce:0}]},{calls:d.map((e,t)=>({to:e,abi:[from("function symbol() returns (string)")],functionName:"symbol",from:la,nonce:t})),stateOverrides:[{address:la,nonce:0}]}]:[]],traceTransfers:i,validation:c});const p=a?f[2]:f[0];const[m,g,,y,b,w,v,x]=a?f:[];const{calls:P,...$}=p;const E=P.slice(0,-1)??[];const A=m?.calls??[];const T=g?.calls??[];const I=[...A,...T].map(e=>"success"===e.status?hexToBigInt(e.data):null);const S=y?.calls??[];const k=b?.calls??[];const B=[...S,...k].map(e=>"success"===e.status?hexToBigInt(e.data):null);const C=(w?.calls??[]).map(e=>"success"===e.status?e.result:null);const O=(x?.calls??[]).map(e=>"success"===e.status?e.result:null);const F=(v?.calls??[]).map(e=>"success"===e.status?e.result:null);const N=[];for(const[R,M]of B.entries()){const e=I[R];if("bigint"!=typeof M)continue;if("bigint"!=typeof e)continue;const t=C[R-1];const n=O[R-1];const s=F[R-1];const r=(()=>0===R?{address:ua,decimals:18,symbol:"ETH"}:{address:d[R-1],decimals:s||t?Number(t??1):void 0,symbol:n??void 0})();N.some(e=>e.token.address===r.address)||N.push({token:r,value:{pre:e,post:M,diff:M-e}})}return{assetChanges:N,block:$,results:E}}const Ta=new Map;const Ia=new Map;let Sa=0;function observe(e,t,n){const s=++Sa;const getListeners=()=>Ta.get(e)||[];const unsubscribe=()=>{const t=getListeners();Ta.set(e,t.filter(e=>e.id!==s))};const unwatch=()=>{const t=getListeners();if(!t.some(e=>e.id===s))return;const n=Ia.get(e);if(1===t.length&&n){const e=n();e instanceof Promise&&e.catch(()=>{})}unsubscribe()};const r=getListeners();Ta.set(e,[...r,{id:s,fns:t}]);if(r&&r.length>0)return unwatch;const o={};for(const i in t)o[i]=(...e)=>{const t=getListeners();if(0!==t.length)for(const n of t)n.fns[i]?.(...e)};const a=n(o);"function"==typeof a&&Ia.set(e,a);return unwatch}function poll(e,{emitOnBegin:t,initialWaitTime:n,interval:s}){let r=!0;const unwatch=()=>r=!1;const watch=async()=>{let o;t&&(o=await e({unpoll:unwatch}));const a=await(n?.(o))??s;await wait(a);const poll2=async()=>{if(r){await e({unpoll:unwatch});await wait(s);poll2()}};poll2()};watch();return unwatch}function watchBlocks(e,{blockTag:t=e.experimental_blockTag??"latest",emitMissed:n=!1,emitOnBegin:s=!1,onBlock:r,onError:o,includeTransactions:a,poll:i,pollingInterval:c=e.pollingInterval}){const u=(()=>"undefined"!=typeof i?i:"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))();const l=a??!1;let d;const pollBlocks=()=>{const a=stringify$1(["watchBlocks",e.uid,t,n,s,l,c]);return observe(a,{onBlock:r,onError:o},r=>poll(async()=>{try{const s=await getAction$1(e,getBlock,"getBlock")({blockTag:t,includeTransactions:l});if(null!==s.number&&null!=d?.number){if(s.number===d.number)return;if(s.number-d.number>1&&n)for(let t=d?.number+1n;t<s.number;t++){const n=await getAction$1(e,getBlock,"getBlock")({blockNumber:t,includeTransactions:l});r.onBlock(n,d);d=n}}if(null==d?.number||"pending"===t&&null==s?.number||null!==s.number&&s.number>d.number){r.onBlock(s,d);d=s}}catch(s){r.onError?.(s)}},{emitOnBegin:s,interval:c}))};const subscribeBlocks=()=>{let n=!0;let a=!0;let unsubscribe=()=>n=!1;(async()=>{try{s&&getAction$1(e,getBlock,"getBlock")({blockTag:t,includeTransactions:l}).then(e=>{if(n&&a){r(e,void 0);a=!1}}).catch(o);const i=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})();const{unsubscribe:c}=await i.subscribe({params:["newHeads"],async onData(t){if(!n)return;const s=await getAction$1(e,getBlock,"getBlock")({blockNumber:t.result?.number,includeTransactions:l}).catch(()=>{});if(n){r(s,d);a=!1;d=s}},onError(e){o?.(e)}});unsubscribe=c;n||unsubscribe()}catch(i){o?.(i)}})();return()=>unsubscribe()};return u?pollBlocks():subscribeBlocks()}function watchBlockNumber(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:s,onError:r,poll:o,pollingInterval:a=e.pollingInterval}){const i=(()=>"undefined"!=typeof o?o:"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))();let c;const pollBlockNumber=()=>{const o=stringify$1(["watchBlockNumber",e.uid,t,n,a]);return observe(o,{onBlockNumber:s,onError:r},s=>poll(async()=>{try{const t=await getAction$1(e,getBlockNumber,"getBlockNumber")({cacheTime:0});if(c){if(t===c)return;if(t-c>1&&n)for(let e=c+1n;e<t;e++){s.onBlockNumber(e,c);c=e}}if(!c||t>c){s.onBlockNumber(t,c);c=t}}catch(t){s.onError?.(t)}},{emitOnBegin:t,interval:a}))};const subscribeBlockNumber=()=>{const o=stringify$1(["watchBlockNumber",e.uid,t,n]);return observe(o,{onBlockNumber:s,onError:r},t=>{let n=!0;let unsubscribe=()=>n=!1;(async()=>{try{const s=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})();const{unsubscribe:r}=await s.subscribe({params:["newHeads"],onData(e){if(!n)return;const s=hexToBigInt(e.result?.number);t.onBlockNumber(s,c);c=s},onError(e){t.onError?.(e)}});unsubscribe=r;n||unsubscribe()}catch(s){r?.(s)}})();return()=>unsubscribe()})};return i?pollBlockNumber():subscribeBlockNumber()}async function uninstallFilter(e,{filter:t}){return t.request({method:"eth_uninstallFilter",params:[t.id]})}function watchEvent(e,{address:t,args:n,batch:s=!0,event:r,events:o,fromBlock:a,onError:i,onLogs:c,poll:u,pollingInterval:l=e.pollingInterval,strict:d}){const f=(()=>"undefined"!=typeof u?u:"bigint"==typeof a||"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))();const p=d??!1;const pollEvent=()=>{const u=stringify$1(["watchEvent",t,n,s,e.uid,r,l,a]);return observe(u,{onLogs:c,onError:i},i=>{let c;void 0!==a&&(c=a-1n);let u;let d=!1;const f=poll(async()=>{if(d)try{let a;if(u)a=await getAction$1(e,getFilterChanges,"getFilterChanges")({filter:u});else{const s=await getAction$1(e,getBlockNumber,"getBlockNumber")({});a=c&&c!==s?await getAction$1(e,getLogs,"getLogs")({address:t,args:n,event:r,events:o,fromBlock:c+1n,toBlock:s}):[];c=s}if(0===a.length)return;if(s)i.onLogs(a);else for(const e of a)i.onLogs([e])}catch(l){u&&l instanceof Un&&(d=!1);i.onError?.(l)}else{try{u=await getAction$1(e,createEventFilter,"createEventFilter")({address:t,args:n,event:r,events:o,strict:p,fromBlock:a})}catch{}d=!0}},{emitOnBegin:!0,interval:l});return async()=>{u&&await getAction$1(e,uninstallFilter,"uninstallFilter")({filter:u});f()}})};const subscribeEvent=()=>{let s=!0;let unsubscribe=()=>s=!1;(async()=>{try{const a=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})();const u=o??(r?[r]:void 0);let l=[];if(u){const e=u.flatMap(e=>encodeEventTopics({abi:[e],eventName:e.name,args:n}));l=[e];r&&(l=l[0])}const{unsubscribe:f}=await a.subscribe({params:["logs",{address:t,topics:l}],onData(e){if(!s)return;const t=e.result;try{const{eventName:e,args:n}=decodeEventLog({abi:u??[],data:t.data,topics:t.topics,strict:p});const s=formatLog(t,{args:n,eventName:e});c([s])}catch(n){let e;let s;if(n instanceof dt||n instanceof ht){if(d)return;e=n.abiItem.name;s=n.abiItem.inputs?.some(e=>!("name"in e&&e.name))}const r=formatLog(t,{args:s?[]:{},eventName:e});c([r])}},onError(e){i?.(e)}});unsubscribe=f;s||unsubscribe()}catch(a){i?.(a)}})();return()=>unsubscribe()};return f?pollEvent():subscribeEvent()}function watchPendingTransactions$1(e,{batch:t=!0,onError:n,onTransactions:s,poll:r,pollingInterval:o=e.pollingInterval}){const a="undefined"!=typeof r?r:"webSocket"!==e.transport.type&&"ipc"!==e.transport.type;const pollPendingTransactions=()=>{const r=stringify$1(["watchPendingTransactions",e.uid,t,o]);return observe(r,{onTransactions:s,onError:n},n=>{let s;const r=poll(async()=>{try{if(!s)try{s=await getAction$1(e,createPendingTransactionFilter,"createPendingTransactionFilter")({});return}catch(o){r();throw o}const a=await getAction$1(e,getFilterChanges,"getFilterChanges")({filter:s});if(0===a.length)return;if(t)n.onTransactions(a);else for(const e of a)n.onTransactions([e])}catch(o){n.onError?.(o)}},{emitOnBegin:!0,interval:o});return async()=>{s&&await getAction$1(e,uninstallFilter,"uninstallFilter")({filter:s});r()}})};const subscribePendingTransactions=()=>{let t=!0;let unsubscribe=()=>t=!1;(async()=>{try{const{unsubscribe:r}=await e.transport.subscribe({params:["newPendingTransactions"],onData(e){if(!t)return;const n=e.result;s([n])},onError(e){n?.(e)}});unsubscribe=r;t||unsubscribe()}catch(r){n?.(r)}})();return()=>unsubscribe()};return a?pollPendingTransactions():subscribePendingTransactions()}const ka="0x5792579257925792579257925792579257925792579257925792579257925792";const Ba=numberToHex(0,{size:32});async function getCallsStatus(e,t){async function getStatus(t){const n=t.endsWith(ka.slice(2));if(n){const n=trim(sliceHex(t,-64,-32));const s=sliceHex(t,0,-64).slice(2).match(/.{1,64}/g);const r=await Promise.all(s.map(t=>Ba.slice(2)!==t?e.request({method:"eth_getTransactionReceipt",params:[`0x${t}`]},{dedupe:!0}):void 0));const o=(()=>r.some(e=>null===e)?100:r.every(e=>"0x1"===e?.status)?200:r.every(e=>"0x0"===e?.status)?500:600)();return{atomic:!1,chainId:hexToNumber$1(n),receipts:r.filter(Boolean),status:o,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[t]})}const{atomic:n=!1,chainId:s,receipts:r,version:o="2.0.0",...a}=await getStatus(t.id);const[i,c]=(()=>{const e=a.status;return e>=100&&e<200?["pending",e]:e>=200&&e<300?["success",e]:e>=300&&e<700?["failure",e]:"CONFIRMED"===e?["success",200]:"PENDING"===e?["pending",100]:[void 0,e]})();return{...a,atomic:n,chainId:s?hexToNumber$1(s):void 0,receipts:r?.map(e=>({...e,blockNumber:hexToBigInt(e.blockNumber),gasUsed:hexToBigInt(e.gasUsed),status:ko[e.status]}))??[],statusCode:c,status:i,version:o}}class Ca extends Re{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"});Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0});this.result=e}}async function waitForCallsStatus(e,t){const{id:n,pollingInterval:s=e.pollingInterval,status:r=({statusCode:e})=>200===e||e>=300,retryCount:o=4,retryDelay:a=({count:e})=>200*(1<<e),timeout:i=6e4,throwOnFailure:c=!1}=t;const u=stringify$1(["waitForCallsStatus",e.uid,n]);const{promise:l,resolve:d,reject:f}=withResolvers();let p;const m=observe(u,{resolve:d,reject:f},t=>{const i=poll(async()=>{const done=e=>{clearTimeout(p);i();e();m()};try{const s=await withRetry(async()=>{const t=await getCallsStatus(e,{id:n});if(c&&"failure"===t.status)throw new Ca(t);return t},{retryCount:o,delay:a});if(!r(s))return;done(()=>t.resolve(s))}catch(s){done(()=>t.reject(s))}},{interval:s,emitOnBegin:!0});return i});p=i?setTimeout(()=>{m();clearTimeout(p);f(new Oa({id:n}))},i):void 0;return await l}class Oa extends Re{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}function formatStorageProof(e){return e.map(e=>({...e,value:BigInt(e.value)}))}function formatProof(e){return{...e,balance:e.balance?BigInt(e.balance):void 0,nonce:e.nonce?hexToNumber$1(e.nonce):void 0,storageProof:e.storageProof?formatStorageProof(e.storageProof):void 0}}async function getProof(e,{address:t,blockNumber:n,blockTag:s,storageKeys:r}){const o=s??"latest";const a=void 0!==n?numberToHex(n):void 0;const i=await e.request({method:"eth_getProof",params:[t,r,a||o]});return formatProof(i)}async function waitForTransactionReceipt$1(e,t){const{checkReplacement:n=!0,confirmations:s=1,hash:r,onReplaced:o,retryCount:a=6,retryDelay:i=({count:e})=>200*(1<<e),timeout:c=18e4}=t;const u=stringify$1(["waitForTransactionReceipt",e.uid,r]);const l=(()=>t.pollingInterval?t.pollingInterval:e.chain?.experimental_preconfirmationTime?e.chain.experimental_preconfirmationTime:e.pollingInterval)();let d;let f;let p;let m=!1;let g;let y;const{promise:b,resolve:w,reject:v}=withResolvers();const x=c?setTimeout(()=>{y();g();v(new Bn({hash:r}))},c):void 0;g=observe(u,{onReplaced:o,resolve:w,reject:v},async t=>{p=await getAction$1(e,getTransactionReceipt,"getTransactionReceipt")({hash:r}).catch(()=>{});if(p&&s<=1){clearTimeout(x);t.resolve(p);g()}else y=getAction$1(e,watchBlockNumber,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:l,async onBlockNumber(o){const done=e=>{clearTimeout(x);y();e();g()};let c=o;if(!m)try{if(p){if(s>1&&(!p.blockNumber||c-p.blockNumber+1n<s))return;done(()=>t.resolve(p));return}if(n&&!d){m=!0;await withRetry(async()=>{d=await getAction$1(e,getTransaction,"getTransaction")({hash:r});d.blockNumber&&(c=d.blockNumber)},{delay:i,retryCount:a});m=!1}p=await getAction$1(e,getTransactionReceipt,"getTransactionReceipt")({hash:r});if(s>1&&(!p.blockNumber||c-p.blockNumber+1n<s))return;done(()=>t.resolve(p))}catch(u){if(u instanceof Sn||u instanceof kn){if(!d){m=!1;return}try{f=d;m=!0;const n=await withRetry(()=>getAction$1(e,getBlock,"getBlock")({blockNumber:c,includeTransactions:!0}),{delay:i,retryCount:a,shouldRetry:({error:e})=>e instanceof ms});m=!1;const r=n.transactions.find(({from:e,nonce:t})=>e===f.from&&t===f.nonce);if(!r)return;p=await getAction$1(e,getTransactionReceipt,"getTransactionReceipt")({hash:r.hash});if(s>1&&(!p.blockNumber||c-p.blockNumber+1n<s))return;let o="replaced";r.to===f.to&&r.value===f.value&&r.input===f.input?o="repriced":r.from===r.to&&0n===r.value&&(o="cancelled");done(()=>{t.onReplaced?.({reason:o,replacedTransaction:f,transaction:r,transactionReceipt:p});t.resolve(p)})}catch(l){done(()=>t.reject(l))}}else done(()=>t.reject(u))}}})});return b}async function prepareAuthorization(e,t){const{account:n=e.account,chainId:s,nonce:r}=t;if(!n)throw new Zt({docsPath:"/docs/eip7702/prepareAuthorization"});const o=parseAccount(n);const a=(()=>{if(t.executor)return"self"===t.executor?t.executor:parseAccount(t.executor)})();const i={address:t.contractAddress??t.address,chainId:s,nonce:r};"undefined"==typeof i.chainId&&(i.chainId=e.chain?.id??await getAction$1(e,getChainId$1,"getChainId")({}));if("undefined"==typeof i.nonce){i.nonce=await getAction$1(e,getTransactionCount,"getTransactionCount")({address:o.address,blockTag:"pending"});("self"===a||a?.address&&isAddressEqual(a.address,o.address))&&(i.nonce+=1)}return i}async function signMessage$1(e,{account:t=e.account,message:n}){if(!t)throw new Zt({docsPath:"/docs/actions/wallet/signMessage"});const s=parseAccount(t);if(s.signMessage)return s.signMessage({message:n});const r=(()=>"string"==typeof n?stringToHex(n):n.raw instanceof Uint8Array?toHex(n.raw):n.raw)();return e.request({method:"personal_sign",params:[r,s.address]},{retryCount:0})}async function simulateContract(e,t){const{abi:n,address:s,args:r,dataSuffix:o,functionName:a,...i}=t;const c=i.account?parseAccount(i.account):e.account;const u=encodeFunctionData({abi:n,args:r,functionName:a});try{const{data:l}=await getAction$1(e,call,"call")({batch:!1,data:`${u}${o?o.replace("0x",""):""}`,to:s,...i,account:c});const d=decodeFunctionResult({abi:n,args:r,functionName:a,data:l||"0x"});const f=n.filter(e=>"name"in e&&e.name===t.functionName);return{result:d,request:{abi:f,address:s,args:r,dataSuffix:o,functionName:a,...i,account:c}}}catch(l){throw getContractError(l,{abi:n,address:s,args:r,docsPath:"/docs/contract/simulateContract",functionName:a,sender:c?.address})}}class Fa extends St{constructor(e,t){super();this.finished=!1;this.destroyed=!1;ahash(e);const n=toBytes$1(t);this.iHash=e.create();if("function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const s=this.blockLen;const r=new Uint8Array(s);r.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r);this.oHash=e.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r);clean$1(r)}update(e){aexists$1(this);this.iHash.update(e);return this}digestInto(e){aexists$1(this);abytes$1(e,this.outputLen);this.finished=!0;this.iHash.digestInto(e);this.oHash.update(e);this.oHash.digestInto(e);this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);this.digestInto(e);return e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:r,blockLen:o,outputLen:a}=this;e;e.finished=s;e.destroyed=r;e.blockLen=o;e.outputLen=a;e.oHash=t._cloneInto(e.oHash);e.iHash=n._cloneInto(e.iHash);return e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0;this.oHash.destroy();this.iHash.destroy()}}const hmac=(e,t,n)=>new Fa(e,t).update(n).digest();hmac.create=(e,t)=>new Fa(e,t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Na=BigInt(0);const Ra=BigInt(1);function abool(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}function numberToHexUnpadded(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?Na:BigInt("0x"+e)}function bytesToNumberBE(e){return hexToNumber(bytesToHex(e))}function bytesToNumberLE(e){abytes$1(e);return hexToNumber(bytesToHex(Uint8Array.from(e).reverse()))}function numberToBytesBE(e,t){return hexToBytes(e.toString(16).padStart(2*t,"0"))}function numberToBytesLE(e,t){return numberToBytesBE(e,t).reverse()}function ensureBytes(e,t,n){let s;if("string"==typeof t)try{s=hexToBytes(t)}catch(o){throw new Error(e+" must be hex string or Uint8Array, cause: "+o)}else{if(!isBytes$1(t))throw new Error(e+" must be hex string or Uint8Array");s=Uint8Array.from(t)}const r=s.length;if("number"==typeof n&&r!==n)throw new Error(e+" of length "+n+" expected, got "+r);return s}const isPosBig=e=>"bigint"==typeof e&&Na<=e;function inRange(e,t,n){return isPosBig(e)&&isPosBig(t)&&isPosBig(n)&&t<=e&&e<n}function aInRange(e,t,n,s){if(!inRange(t,n,s))throw new Error("expected valid "+e+": "+n+" <= n < "+s+", got "+t)}function bitLen(e){let t;for(t=0;e>Na;e>>=Ra,t+=1);return t}const bitMask=e=>(Ra<<BigInt(e))-Ra;function createHmacDrbg(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");const u8n=e=>new Uint8Array(e);const u8of=e=>Uint8Array.of(e);let s=u8n(e);let r=u8n(e);let o=0;const reset=()=>{s.fill(1);r.fill(0);o=0};const h=(...e)=>n(r,s,...e);const reseed=(e=u8n(0))=>{r=h(u8of(0),e);s=h();if(0!==e.length){r=h(u8of(1),e);s=h()}};const gen2=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){s=h();const t=s.slice();n.push(t);e+=s.length}return concatBytes(...n)};const genUntil=(e,t)=>{reset();reseed(e);let n;for(;!(n=t(gen2()));)reseed();reset();return n};return genUntil}function _validateObject(e,t,n={}){if(!e||"object"!=typeof e)throw new Error("expected valid options object");function checkField(t,n,s){const r=e[t];if(s&&void 0===r)return;const o=typeof r;if(o!==n||null===r)throw new Error(`param "${t}" is invalid: expected ${n}, got ${o}`)}Object.entries(t).forEach(([e,t])=>checkField(e,t,!1));Object.entries(n).forEach(([e,t])=>checkField(e,t,!0))}function memoized(e){const t=new WeakMap;return(n,...s)=>{const r=t.get(n);if(void 0!==r)return r;const o=e(n,...s);t.set(n,o);return o}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ma=BigInt(0),za=BigInt(1),ja=BigInt(2),qa=BigInt(3);const La=BigInt(4),Ha=BigInt(5);const Ua=BigInt(8);function mod(e,t){const n=e%t;return n>=Ma?n:t+n}function pow2(e,t,n){let s=e;for(;t-- >Ma;){s*=s;s%=n}return s}function invert(e,t){if(e===Ma)throw new Error("invert: expected non-zero number");if(t<=Ma)throw new Error("invert: expected positive modulus, got "+t);let n=mod(e,t);let s=t;let r=Ma,o=za;for(;n!==Ma;){const e=s/n;const t=s%n;const a=r-o*e;s=n,n=t,r=o,o=a}const a=s;if(a!==za)throw new Error("invert: does not exist");return mod(r,t)}function sqrt3mod4(e,t){const n=(e.ORDER+za)/La;const s=e.pow(t,n);if(!e.eql(e.sqr(s),t))throw new Error("Cannot find square root");return s}function sqrt5mod8(e,t){const n=(e.ORDER-Ha)/Ua;const s=e.mul(t,ja);const r=e.pow(s,n);const o=e.mul(t,r);const a=e.mul(e.mul(o,ja),r);const i=e.mul(o,e.sub(a,e.ONE));if(!e.eql(e.sqr(i),t))throw new Error("Cannot find square root");return i}function tonelliShanks(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let t=e-za;let n=0;for(;t%ja===Ma;){t/=ja;n++}let s=ja;const r=Field(e);for(;1===FpLegendre(r,s);)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return sqrt3mod4;let o=r.pow(s,t);const a=(t+za)/ja;return function(e,s){if(e.is0(s))return s;if(1!==FpLegendre(e,s))throw new Error("Cannot find square root");let r=n;let i=e.mul(e.ONE,o);let c=e.pow(s,t);let u=e.pow(s,a);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1;let n=e.sqr(c);for(;!e.eql(n,e.ONE);){t++;n=e.sqr(n);if(t===r)throw new Error("Cannot find square root")}const s=za<<BigInt(r-t-1);const o=e.pow(i,s);r=t;i=e.sqr(o);c=e.mul(c,i);u=e.mul(u,o)}return u}}function FpSqrt(e){return e%La===qa?sqrt3mod4:e%Ua===Ha?sqrt5mod8:tonelliShanks(e)}const _a=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"};const n=_a.reduce((e,t)=>{e[t]="function";return e},t);_validateObject(e,n);return e}function FpPow(e,t,n){if(n<Ma)throw new Error("invalid exponent, negatives unsupported");if(n===Ma)return e.ONE;if(n===za)return t;let s=e.ONE;let r=t;for(;n>Ma;){n&za&&(s=e.mul(s,r));r=e.sqr(r);n>>=za}return s}function FpInvertBatch(e,t,n=!1){const s=new Array(t.length).fill(n?e.ZERO:void 0);const r=t.reduce((t,n,r)=>{if(e.is0(n))return t;s[r]=t;return e.mul(t,n)},e.ONE);const o=e.inv(r);t.reduceRight((t,n,r)=>{if(e.is0(n))return t;s[r]=e.mul(t,s[r]);return e.mul(t,n)},o);return s}function FpLegendre(e,t){const n=(e.ORDER-za)/ja;const s=e.pow(t,n);const r=e.eql(s,e.ONE);const o=e.eql(s,e.ZERO);const a=e.eql(s,e.neg(e.ONE));if(!r&&!o&&!a)throw new Error("invalid Legendre symbol result");return r?1:o?0:-1}function nLength(e,t){void 0!==t&&anumber$1(t);const n=void 0!==t?t:e.toString(2).length;const s=Math.ceil(n/8);return{nBitLength:n,nByteLength:s}}function Field(e,t,n=!1,s={}){if(e<=Ma)throw new Error("invalid field: expected ORDER > 0, got "+e);let r;let o;if("object"==typeof t&&null!=t){if(s.sqrt||n)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(r=e.BITS);e.sqrt&&(o=e.sqrt);"boolean"==typeof e.isLE&&(n=e.isLE)}else{"number"==typeof t&&(r=t);s.sqrt&&(o=s.sqrt)}const{nBitLength:a,nByteLength:i}=nLength(e,r);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const u=Object.freeze({ORDER:e,isLE:n,BITS:a,BYTES:i,MASK:bitMask(a),ZERO:Ma,ONE:za,create:t=>mod(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return Ma<=t&&t<e},is0:e=>e===Ma,isValidNot0:e=>!u.is0(e)&&u.isValid(e),isOdd:e=>(e&za)===za,neg:t=>mod(-t,e),eql:(e,t)=>e===t,sqr:t=>mod(t*t,e),add:(t,n)=>mod(t+n,e),sub:(t,n)=>mod(t-n,e),mul:(t,n)=>mod(t*n,e),pow:(e,t)=>FpPow(u,e,t),div:(t,n)=>mod(t*invert(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>invert(t,e),sqrt:o||(t=>{c||(c=FpSqrt(e));return c(u,t)}),toBytes:e=>n?numberToBytesLE(e,i):numberToBytesBE(e,i),fromBytes:e=>{if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);return n?bytesToNumberLE(e):bytesToNumberBE(e)},invertBatch:e=>FpInvertBatch(u,e),cmov:(e,t,n)=>n?t:e});return Object.freeze(u)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}function mapHashToField(e,t,n=!1){const s=e.length;const r=getFieldBytesLength(t);const o=getMinHashLength(t);if(s<16||s<o||s>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+s);const a=n?bytesToNumberLE(e):bytesToNumberBE(e);const i=mod(a,t-za)+za;return n?numberToBytesLE(i,r):numberToBytesBE(i,r)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Da=BigInt(0);const Ga=BigInt(1);function negateCt(e,t){const n=t.negate();return e?n:t}function normalizeZ(e,t,n){const getz=e=>e.pz;const s=FpInvertBatch(e.Fp,n.map(getz));const r=n.map((e,t)=>e.toAffine(s[t]));return r.map(e.fromAffine)}function validateW(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function calcWOpts(e,t){validateW(e,t);const n=Math.ceil(t/e)+1;const s=2**(e-1);const r=2**e;const o=bitMask(e);const a=BigInt(e);return{windows:n,windowSize:s,mask:o,maxNumber:r,shiftBy:a}}function calcOffsets(e,t,n){const{windowSize:s,mask:r,maxNumber:o,shiftBy:a}=n;let i=Number(e&r);let c=e>>a;if(i>s){i-=o;c+=Ga}const u=t*s;const l=u+Math.abs(i)-1;const d=0===i;const f=i<0;const p=t%2!=0;const m=u;return{nextN:c,offset:l,isZero:d,isNeg:f,isNegF:p,offsetF:m}}function validateMSMPoints(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function validateMSMScalars(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}const Wa=new WeakMap;const Va=new WeakMap;function getW(e){return Va.get(e)||1}function assert0(e){if(e!==Da)throw new Error("invalid wNAF")}function wNAF(e,t){return{constTimeNegate:negateCt,hasPrecomputes:e=>1!==getW(e),unsafeLadder(t,n,s=e.ZERO){let r=t;for(;n>Da;){n&Ga&&(s=s.add(r));r=r.double();n>>=Ga}return s},precomputeWindow(e,n){const{windows:s,windowSize:r}=calcWOpts(n,t);const o=[];let a=e;let i=a;for(let t=0;t<s;t++){i=a;o.push(i);for(let e=1;e<r;e++){i=i.add(a);o.push(i)}a=i.double()}return o},wNAF(n,s,r){let o=e.ZERO;let a=e.BASE;const i=calcWOpts(n,t);for(let e=0;e<i.windows;e++){const{nextN:t,offset:n,isZero:c,isNeg:u,isNegF:l,offsetF:d}=calcOffsets(r,e,i);r=t;c?a=a.add(negateCt(l,s[d])):o=o.add(negateCt(u,s[n]))}assert0(r);return{p:o,f:a}},wNAFUnsafe(n,s,r,o=e.ZERO){const a=calcWOpts(n,t);for(let e=0;e<a.windows&&r!==Da;e++){const{nextN:t,offset:n,isZero:i,isNeg:c}=calcOffsets(r,e,a);r=t;if(!i){const e=s[n];o=o.add(c?e.negate():e)}}assert0(r);return o},getPrecomputes(e,t,n){let s=Wa.get(t);if(!s){s=this.precomputeWindow(t,e);if(1!==e){"function"==typeof n&&(s=n(s));Wa.set(t,s)}}return s},wNAFCached(e,t,n){const s=getW(e);return this.wNAF(s,this.getPrecomputes(s,e,n),t)},wNAFCachedUnsafe(e,t,n,s){const r=getW(e);return 1===r?this.unsafeLadder(e,t,s):this.wNAFUnsafe(r,this.getPrecomputes(r,e,n),t,s)},setWindowSize(e,n){validateW(n,t);Va.set(e,n);Wa.delete(e)}}}function mulEndoUnsafe(e,t,n,s){let r=t;let o=e.ZERO;let a=e.ZERO;for(;n>Da||s>Da;){n&Ga&&(o=o.add(r));s&Ga&&(a=a.add(r));r=r.double();n>>=Ga;s>>=Ga}return{p1:o,p2:a}}function pippenger(e,t,n,s){validateMSMPoints(n,e);validateMSMScalars(s,t);const r=n.length;const o=s.length;if(r!==o)throw new Error("arrays of points and scalars must have equal length");const a=e.ZERO;const i=bitLen(BigInt(r));let c=1;i>12?c=i-3:i>4?c=i-2:i>0&&(c=2);const u=bitMask(c);const l=new Array(Number(u)+1).fill(a);const d=Math.floor((t.BITS-1)/c)*c;let f=a;for(let p=d;p>=0;p-=c){l.fill(a);for(let t=0;t<o;t++){const e=s[t];const r=Number(e>>BigInt(p)&u);l[r]=l[r].add(n[t])}let e=a;for(let t=l.length-1,n=a;t>0;t--){n=n.add(l[t]);e=e.add(n)}f=f.add(e);if(0!==p)for(let t=0;t<c;t++)f=f.double()}return f}function createField(e,t){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");validateField(t);return t}return Field(e)}function _createCurveFields(e,t,n={}){if(!t||"object"!=typeof t)throw new Error(`expected valid ${e} CURVE object`);for(const i of["p","n","h"]){const e=t[i];if(!("bigint"==typeof e&&e>Da))throw new Error(`CURVE.${i} must be positive bigint`)}const s=createField(t.p,n.Fp);const r=createField(t.n,n.Fn);const o="b";const a=["Gx","Gy","a",o];for(const i of a)if(!s.isValid(t[i]))throw new Error(`CURVE.${i} must be valid field element of CURVE.Fp`);return{Fp:s,Fn:r}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validateSigVerOpts(e){void 0!==e.lowS&&abool("lowS",e.lowS);void 0!==e.prehash&&abool("prehash",e.prehash)}class Ka extends Error{constructor(e=""){super(e)}}const Qa={Err:Ka,_tlv:{encode:(e,t)=>{const{Err:n}=Qa;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const s=t.length/2;const r=numberToHexUnpadded(s);if(r.length/2&128)throw new n("tlv.encode: long form length too big");const o=s>127?numberToHexUnpadded(r.length/2|128):"";const a=numberToHexUnpadded(e);return a+o+r+t},decode(e,t){const{Err:n}=Qa;let s=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[s++]!==e)throw new n("tlv.decode: wrong tlv");const r=t[s++];const o=!!(128&r);let a=0;if(o){const e=127&r;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const o=t.subarray(s,s+e);if(o.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===o[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of o)a=a<<8|t;s+=e;if(a<128)throw new n("tlv.decode(long): not minimal encoding")}else a=r;const i=t.subarray(s,s+a);if(i.length!==a)throw new n("tlv.decode: wrong value length");return{v:i,l:t.subarray(s+a)}}},_int:{encode(e){const{Err:t}=Qa;if(e<Za)throw new t("integer: negative integers are not allowed");let n=numberToHexUnpadded(e);8&Number.parseInt(n[0],16)&&(n="00"+n);if(1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Qa;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return bytesToNumberBE(e)}},toSig(e){const{Err:t,_int:n,_tlv:s}=Qa;const r=ensureBytes("signature",e);const{v:o,l:a}=s.decode(48,r);if(a.length)throw new t("invalid signature: left bytes after parsing");const{v:i,l:c}=s.decode(2,o);const{v:u,l:l}=s.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(i),s:n.decode(u)}},hexFromSig(e){const{_tlv:t,_int:n}=Qa;const s=t.encode(2,n.encode(e.r));const r=t.encode(2,n.encode(e.s));const o=s+r;return t.encode(48,o)}};const Za=BigInt(0),Ja=BigInt(1),Ya=BigInt(2),Xa=BigInt(3),ei=BigInt(4);function _legacyHelperEquat(e,t,n){function weierstrassEquation(s){const r=e.sqr(s);const o=e.mul(r,s);return e.add(e.add(o,e.mul(s,t)),n)}return weierstrassEquation}function _legacyHelperNormPriv(e,t,n){const{BYTES:s}=e;function normPrivateKeyToScalar(r){let o;if("bigint"==typeof r)o=r;else{let n=ensureBytes("private key",r);if(t){if(!t.includes(2*n.length))throw new Error("invalid private key");const e=new Uint8Array(s);e.set(n,e.length-n.length);n=e}try{o=e.fromBytes(n)}catch(a){throw new Error(`invalid private key: expected ui8a of size ${s}, got ${typeof r}`)}}n&&(o=e.create(o));if(!e.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return normPrivateKeyToScalar}function weierstrassN(e,t={}){const{Fp:n,Fn:s}=_createCurveFields("weierstrass",e,t);const{h:r,n:o}=e;_validateObject(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:a}=t;if(a&&(!n.is0(e.a)||"bigint"!=typeof a.beta||"function"!=typeof a.splitScalar))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function assertCompressionIsSupported(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function pointToBytes(e,t,s){const{x:r,y:o}=t.toAffine();const a=n.toBytes(r);abool("isCompressed",s);if(s){assertCompressionIsSupported();const e=!n.isOdd(o);return concatBytes(pprefix(e),a)}return concatBytes(Uint8Array.of(4),a,n.toBytes(o))}function pointFromBytes(e){abytes$1(e);const t=n.BYTES;const s=t+1;const r=2*t+1;const o=e.length;const a=e[0];const i=e.subarray(1);if(o!==s||2!==a&&3!==a){if(o===r&&4===a){const e=n.fromBytes(i.subarray(0*t,1*t));const s=n.fromBytes(i.subarray(1*t,2*t));if(!isValidXY(e,s))throw new Error("bad point: is not on curve");return{x:e,y:s}}throw new Error(`bad point: got length ${o}, expected compressed=${s} or uncompressed=${r}`)}{const e=n.fromBytes(i);if(!n.isValid(e))throw new Error("bad point: is not on curve, wrong x");const t=u(e);let s;try{s=n.sqrt(t)}catch(c){const e=c instanceof Error?": "+c.message:"";throw new Error("bad point: is not on curve, sqrt error"+e)}assertCompressionIsSupported();const r=n.isOdd(s);const o=!(1&~a);o!==r&&(s=n.neg(s));return{x:e,y:s}}}const i=t.toBytes||pointToBytes;const c=t.fromBytes||pointFromBytes;const u=_legacyHelperEquat(n,e.a,e.b);function isValidXY(e,t){const s=n.sqr(t);const r=u(e);return n.eql(s,r)}if(!isValidXY(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const l=n.mul(n.pow(e.a,Xa),ei);const d=n.mul(n.sqr(e.b),BigInt(27));if(n.is0(n.add(l,d)))throw new Error("bad curve params: a or b");function acoord(e,t,s=!1){if(!n.isValid(t)||s&&n.is0(t))throw new Error(`bad point coordinate ${e}`);return t}function aprjpoint(e){if(!(e instanceof m))throw new Error("ProjectivePoint expected")}const f=memoized((e,t)=>{const{px:s,py:r,pz:o}=e;if(n.eql(o,n.ONE))return{x:s,y:r};const a=e.is0();null==t&&(t=a?n.ONE:n.inv(o));const i=n.mul(s,t);const c=n.mul(r,t);const u=n.mul(o,t);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:i,y:c}});const p=memoized(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:s,y:r}=e.toAffine();if(!n.isValid(s)||!n.isValid(r))throw new Error("bad point: x or y not field elements");if(!isValidXY(s,r))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function finishEndo(e,t,s,r,o){s=new m(n.mul(s.px,e),s.py,s.pz);t=negateCt(r,t);s=negateCt(o,s);return t.add(s)}class m{constructor(e,t,n){this.px=acoord("x",e);this.py=acoord("y",t,!0);this.pz=acoord("z",n);Object.freeze(this)}static fromAffine(e){const{x:t,y:s}=e||{};if(!e||!n.isValid(t)||!n.isValid(s))throw new Error("invalid affine point");if(e instanceof m)throw new Error("projective point not allowed");return n.is0(t)&&n.is0(s)?m.ZERO:new m(t,s,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){return normalizeZ(m,"pz",e)}static fromBytes(e){abytes$1(e);return m.fromHex(e)}static fromHex(e){const t=m.fromAffine(c(ensureBytes("pointHex",e)));t.assertValidity();return t}static fromPrivateKey(e){const n=_legacyHelperNormPriv(s,t.allowedPrivateKeyLengths,t.wrapPrivateKey);return m.BASE.multiply(n(e))}static msm(e,t){return pippenger(m,s,e,t)}precompute(e=8,t=!0){y.setWindowSize(this,e);t||this.multiply(Xa);return this}_setWindowSize(e){this.precompute(e)}assertValidity(){p(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){aprjpoint(e);const{px:t,py:s,pz:r}=this;const{px:o,py:a,pz:i}=e;const c=n.eql(n.mul(t,i),n.mul(o,r));const u=n.eql(n.mul(s,i),n.mul(a,r));return c&&u}negate(){return new m(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:s}=e;const r=n.mul(s,Xa);const{px:o,py:a,pz:i}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO;let d=n.mul(o,o);let f=n.mul(a,a);let p=n.mul(i,i);let g=n.mul(o,a);g=n.add(g,g);l=n.mul(o,i);l=n.add(l,l);c=n.mul(t,l);u=n.mul(r,p);u=n.add(c,u);c=n.sub(f,u);u=n.add(f,u);u=n.mul(c,u);c=n.mul(g,c);l=n.mul(r,l);p=n.mul(t,p);g=n.sub(d,p);g=n.mul(t,g);g=n.add(g,l);l=n.add(d,d);d=n.add(l,d);d=n.add(d,p);d=n.mul(d,g);u=n.add(u,d);p=n.mul(a,i);p=n.add(p,p);d=n.mul(p,g);c=n.sub(c,d);l=n.mul(p,f);l=n.add(l,l);l=n.add(l,l);return new m(c,u,l)}add(t){aprjpoint(t);const{px:s,py:r,pz:o}=this;const{px:a,py:i,pz:c}=t;let u=n.ZERO,l=n.ZERO,d=n.ZERO;const f=e.a;const p=n.mul(e.b,Xa);let g=n.mul(s,a);let y=n.mul(r,i);let b=n.mul(o,c);let w=n.add(s,r);let v=n.add(a,i);w=n.mul(w,v);v=n.add(g,y);w=n.sub(w,v);v=n.add(s,o);let x=n.add(a,c);v=n.mul(v,x);x=n.add(g,b);v=n.sub(v,x);x=n.add(r,o);u=n.add(i,c);x=n.mul(x,u);u=n.add(y,b);x=n.sub(x,u);d=n.mul(f,v);u=n.mul(p,b);d=n.add(u,d);u=n.sub(y,d);d=n.add(y,d);l=n.mul(u,d);y=n.add(g,g);y=n.add(y,g);b=n.mul(f,b);v=n.mul(p,v);y=n.add(y,b);b=n.sub(g,b);b=n.mul(f,b);v=n.add(v,b);g=n.mul(y,v);l=n.add(l,g);g=n.mul(x,v);u=n.mul(w,u);u=n.sub(u,g);g=n.mul(w,y);d=n.mul(x,d);d=n.add(d,g);return new m(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(m.ZERO)}multiply(e){const{endo:n}=t;if(!s.isValidNot0(e))throw new Error("invalid scalar: out of range");let r,o;const mul=e=>y.wNAFCached(this,e,m.normalizeZ);if(n){const{k1neg:t,k1:s,k2neg:a,k2:i}=n.splitScalar(e);const{p:c,f:u}=mul(s);const{p:l,f:d}=mul(i);o=u.add(d);r=finishEndo(n.beta,c,l,t,a)}else{const{p:t,f:n}=mul(e);r=t;o=n}return m.normalizeZ([r,o])[0]}multiplyUnsafe(e){const{endo:n}=t;const r=this;if(!s.isValid(e))throw new Error("invalid scalar: out of range");if(e===Za||r.is0())return m.ZERO;if(e===Ja)return r;if(y.hasPrecomputes(this))return this.multiply(e);if(n){const{k1neg:t,k1:s,k2neg:o,k2:a}=n.splitScalar(e);const{p1:i,p2:c}=mulEndoUnsafe(m,r,s,a);return finishEndo(n.beta,i,c,t,o)}return y.wNAFCachedUnsafe(r,e)}multiplyAndAddUnsafe(e,t,n){const s=this.multiplyUnsafe(t).add(e.multiplyUnsafe(n));return s.is0()?void 0:s}toAffine(e){return f(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return r===Ja||(e?e(m,this):y.wNAFCachedUnsafe(this,o).is0())}clearCofactor(){const{clearCofactor:e}=t;return r===Ja?this:e?e(m,this):this.multiplyUnsafe(r)}toBytes(e=!0){abool("isCompressed",e);this.assertValidity();return i(m,this,e)}toRawBytes(e=!0){return this.toBytes(e)}toHex(e=!0){return bytesToHex(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}m.BASE=new m(e.Gx,e.Gy,n.ONE);m.ZERO=new m(n.ZERO,n.ONE,n.ZERO);m.Fp=n;m.Fn=s;const g=s.BITS;const y=wNAF(m,t.endo?Math.ceil(g/2):g);return m}function pprefix(e){return Uint8Array.of(e?2:3)}function ecdsa(e,t,n={}){_validateObject(t,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const s=t.randomBytes||randomBytes;const r=t.hmac||((e,...n)=>hmac(t.hash,e,concatBytes(...n)));const{Fp:o,Fn:a}=e;const{ORDER:i,BITS:c}=a;function isBiggerThanHalfOrder(e){const t=i>>Ja;return e>t}function normalizeS(e){return isBiggerThanHalfOrder(e)?a.neg(e):e}function aValidRS(e,t){if(!a.isValidNot0(t))throw new Error(`invalid signature ${e}: out of range 1..CURVE.n`)}class u{constructor(e,t,n){aValidRS("r",e);aValidRS("s",t);this.r=e;this.s=t;null!=n&&(this.recovery=n);Object.freeze(this)}static fromCompact(e){const t=a.BYTES;const n=ensureBytes("compactSignature",e,2*t);return new u(a.fromBytes(n.subarray(0,t)),a.fromBytes(n.subarray(t,2*t)))}static fromDER(e){const{r:t,s:n}=Qa.toSig(ensureBytes("DER",e));return new u(t,n)}assertValidity(){}addRecoveryBit(e){return new u(this.r,this.s,e)}recoverPublicKey(t){const n=o.ORDER;const{r:s,s:r,recovery:c}=this;if(null==c||![0,1,2,3].includes(c))throw new Error("recovery id invalid");const u=i*Ya<n;if(u&&c>1)throw new Error("recovery id is ambiguous for h>1 curve");const l=2===c||3===c?s+i:s;if(!o.isValid(l))throw new Error("recovery id 2 or 3 invalid");const d=o.toBytes(l);const f=e.fromHex(concatBytes(pprefix(!(1&c)),d));const m=a.inv(l);const g=p(ensureBytes("msgHash",t));const y=a.create(-g*m);const b=a.create(r*m);const w=e.BASE.multiplyUnsafe(y).add(f.multiplyUnsafe(b));if(w.is0())throw new Error("point at infinify");w.assertValidity();return w}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,a.neg(this.s),this.recovery):this}toBytes(e){if("compact"===e)return concatBytes(a.toBytes(this.r),a.toBytes(this.s));if("der"===e)return hexToBytes(Qa.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return bytesToHex(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return bytesToHex(this.toBytes("compact"))}}const l=_legacyHelperNormPriv(a,n.allowedPrivateKeyLengths,n.wrapPrivateKey);const d={isValidPrivateKey(e){try{l(e);return!0}catch(t){return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const e=i;return mapHashToField(s(getMinHashLength(e)),e)},precompute:(t=8,n=e.BASE)=>n.precompute(t,!1)};function getPublicKey(t,n=!0){return e.fromPrivateKey(t).toBytes(n)}function isProbPub(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const s=ensureBytes("key",t);const r=s.length;const i=o.BYTES;const c=i+1;const u=2*i+1;return n.allowedPrivateKeyLengths||a.BYTES===c?void 0:r===c||r===u}function getSharedSecret(t,n,s=!0){if(!0===isProbPub(t))throw new Error("first arg must be private key");if(!1===isProbPub(n))throw new Error("second arg must be public key");const r=e.fromHex(n);return r.multiply(l(t)).toBytes(s)}const f=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=bytesToNumberBE(e);const n=8*e.length-c;return n>0?t>>BigInt(n):t};const p=t.bits2int_modN||function(e){return a.create(f(e))};const m=bitMask(c);function int2octets(e){aInRange("num < 2^"+c,e,Za,m);return a.toBytes(e)}function prepSig(n,r,i=g){if(["recovered","canonical"].some(e=>e in i))throw new Error("sign() legacy options not supported");const{hash:c}=t;let{lowS:d,prehash:m,extraEntropy:y}=i;null==d&&(d=!0);n=ensureBytes("msgHash",n);validateSigVerOpts(i);m&&(n=ensureBytes("prehashed msgHash",c(n)));const b=p(n);const w=l(r);const v=[int2octets(w),int2octets(b)];if(null!=y&&!1!==y){const e=!0===y?s(o.BYTES):y;v.push(ensureBytes("extraEntropy",e))}const x=concatBytes(...v);const P=b;function k2sig(t){const n=f(t);if(!a.isValidNot0(n))return;const s=a.inv(n);const r=e.BASE.multiply(n).toAffine();const o=a.create(r.x);if(o===Za)return;const i=a.create(s*a.create(P+o*w));if(i===Za)return;let c=(r.x===o?0:2)|Number(r.y&Ja);let l=i;if(d&&isBiggerThanHalfOrder(i)){l=normalizeS(i);c^=1}return new u(o,l,c)}return{seed:x,k2sig:k2sig}}const g={lowS:t.lowS,prehash:!1};const y={lowS:t.lowS,prehash:!1};function sign(e,n,s=g){const{seed:o,k2sig:i}=prepSig(e,n,s);const c=createHmacDrbg(t.hash.outputLen,a.BYTES,r);return c(o,i)}e.BASE.precompute(8);function verify(n,s,r,o=y){const i=n;s=ensureBytes("msgHash",s);r=ensureBytes("publicKey",r);validateSigVerOpts(o);const{lowS:c,prehash:l,format:d}=o;if("strict"in o)throw new Error("options.strict was renamed to lowS");if(void 0!==d&&!["compact","der","js"].includes(d))throw new Error('format must be "compact", "der" or "js"');const f="string"==typeof i||isBytes$1(i);const m=!f&&!d&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!f&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g;let b;try{if(m){if(void 0!==d&&"js"!==d)throw new Error("invalid format");g=new u(i.r,i.s)}if(f){try{"compact"!==d&&(g=u.fromDER(i))}catch(I){if(!(I instanceof Qa.Err))throw I}g||"der"===d||(g=u.fromCompact(i))}b=e.fromHex(r)}catch(S){return!1}if(!g)return!1;if(c&&g.hasHighS())return!1;l&&(s=t.hash(s));const{r:w,s:v}=g;const x=p(s);const P=a.inv(v);const $=a.create(x*P);const E=a.create(w*P);const A=e.BASE.multiplyUnsafe($).add(b.multiplyUnsafe(E));if(A.is0())return!1;const T=a.create(A.x);return T===w}return Object.freeze({getPublicKey:getPublicKey,getSharedSecret:getSharedSecret,sign:sign,verify:verify,utils:d,Point:e,Signature:u})}function _weierstrass_legacy_opts_to_new(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy};const n=e.Fp;const s=Field(t.n,e.nBitLength);const r={Fp:n,Fn:s,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:t,curveOpts:r}}function _ecdsa_legacy_opts_to_new(e){const{CURVE:t,curveOpts:n}=_weierstrass_legacy_opts_to_new(e);const s={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:n,ecdsaOpts:s}}function _ecdsa_new_output_to_legacy(e,t){return Object.assign({},t,{ProjectivePoint:t.Point,CURVE:e})}function weierstrass(e){const{CURVE:t,curveOpts:n,ecdsaOpts:s}=_ecdsa_legacy_opts_to_new(e);const r=weierstrassN(t,n);const o=ecdsa(r,s,n);return _ecdsa_new_output_to_legacy(e,o)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function createCurve(e,t){const create=t=>weierstrass({...e,hash:t});return{...create(t),create:create}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ti={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const ni=BigInt(1);const si=BigInt(2);const divNearest=(e,t)=>(e+t/si)/t;function sqrtMod(e){const t=ti.p;const n=BigInt(3),s=BigInt(6),r=BigInt(11),o=BigInt(22);const a=BigInt(23),i=BigInt(44),c=BigInt(88);const u=e*e*e%t;const l=u*u*e%t;const d=pow2(l,n,t)*l%t;const f=pow2(d,n,t)*l%t;const p=pow2(f,si,t)*u%t;const m=pow2(p,r,t)*p%t;const g=pow2(m,o,t)*m%t;const y=pow2(g,i,t)*g%t;const b=pow2(y,c,t)*y%t;const w=pow2(b,i,t)*g%t;const v=pow2(w,n,t)*l%t;const x=pow2(v,a,t)*m%t;const P=pow2(x,s,t)*u%t;const $=pow2(P,si,t);if(!ri.eql(ri.sqr($),e))throw new Error("Cannot find square root");return $}const ri=Field(ti.p,void 0,void 0,{sqrt:sqrtMod});const oi=createCurve({...ti,Fp:ri,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=ti.n;const n=BigInt("0x3086d221a7d46bcde86c90e49284eb15");const s=-ni*BigInt("0xe4437ed6010e88286f547fa90abfe4c3");const r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");const o=n;const a=BigInt("0x100000000000000000000000000000000");const i=divNearest(o*e,t);const c=divNearest(-s*e,t);let u=mod(e-i*n-c*r,t);let l=mod(-i*s-c*o,t);const d=u>a;const f=l>a;d&&(u=t-u);f&&(l=t-l);if(u>a||l>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:u,k2neg:f,k2:l}}}},As);const ai=Object.freeze(Object.defineProperty({__proto__:null,secp256k1:oi},Symbol.toStringTag,{value:"Module"}));function serializeSignature({r:e,s:t,to:n="hex",v:s,yParity:r}){const o=(()=>{if(0===r||1===r)return r;if(s&&(27n===s||28n===s||s>=35n))return s%2n==0n?1:0;throw new Error("Invalid `v` or `yParity` value")})();const a=`0x${new oi.Signature(hexToBigInt(e),hexToBigInt(t)).toCompactHex()}${0===o?"1b":"1c"}`;return"hex"===n?a:hexToBytes$1(a)}async function verifyHash(e,t){const{address:n,factory:s,factoryData:r,hash:o,signature:a,universalSignatureVerifierAddress:i=e.chain?.contracts?.universalSignatureVerifier?.address,...c}=t;const u=(()=>isHex(a)?a:"object"==typeof a&&"r"in a&&"s"in a?serializeSignature(a):bytesToHex$1(a))();const l=await(async()=>s||r?isErc6492Signature(u)?u:serializeErc6492Signature({address:s,data:r,signature:u}):u)();try{const t=i?{to:i,data:encodeFunctionData({abi:Ds,functionName:"isValidSig",args:[n,o,l]}),...c}:{data:encodeDeployData({abi:Ds,args:[n,o,l],bytecode:ho}),...c};const{data:s}=await getAction$1(e,call,"call")(t);return hexToBool(s??"0x0")}catch(d){try{const e=isAddressEqual(getAddress(n),await recoverAddress({hash:o,signature:a}));if(e)return!0}catch{}if(d instanceof Nr)return!1;throw d}}async function verifyMessage(e,{address:t,message:n,factory:s,factoryData:r,signature:o,...a}){const i=hashMessage(n);return verifyHash(e,{address:t,factory:s,factoryData:r,hash:i,signature:o,...a})}async function verifyTypedData(e,t){const{address:n,factory:s,factoryData:r,signature:o,message:a,primaryType:i,types:c,domain:u,...l}=t;const d=hashTypedData({message:a,primaryType:i,types:c,domain:u});return verifyHash(e,{address:n,factory:s,factoryData:r,hash:d,signature:o,...l})}function watchContractEvent(e,t){const{abi:n,address:s,args:r,batch:o=!0,eventName:a,fromBlock:i,onError:c,onLogs:u,poll:l,pollingInterval:d=e.pollingInterval,strict:f}=t;const p=(()=>"undefined"!=typeof l?l:"bigint"==typeof i||"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))();const pollContractEvent=()=>{const t=f??!1;const l=stringify$1(["watchContractEvent",s,r,o,e.uid,a,d,t,i]);return observe(l,{onLogs:u,onError:c},c=>{let u;void 0!==i&&(u=i-1n);let l;let f=!1;const p=poll(async()=>{if(f)try{let i;if(l)i=await getAction$1(e,getFilterChanges,"getFilterChanges")({filter:l});else{const o=await getAction$1(e,getBlockNumber,"getBlockNumber")({});i=u&&u<o?await getAction$1(e,getContractEvents,"getContractEvents")({abi:n,address:s,args:r,eventName:a,fromBlock:u+1n,toBlock:o,strict:t}):[];u=o}if(0===i.length)return;if(o)c.onLogs(i);else for(const e of i)c.onLogs([e])}catch(d){l&&d instanceof Un&&(f=!1);c.onError?.(d)}else{try{l=await getAction$1(e,createContractEventFilter,"createContractEventFilter")({abi:n,address:s,args:r,eventName:a,strict:t,fromBlock:i})}catch{}f=!0}},{emitOnBegin:!0,interval:d});return async()=>{l&&await getAction$1(e,uninstallFilter,"uninstallFilter")({filter:l});p()}})};const subscribeContractEvent=()=>{const t=f??!1;const i=stringify$1(["watchContractEvent",s,r,o,e.uid,a,d,t]);let l=!0;let unsubscribe=()=>l=!1;return observe(i,{onLogs:u,onError:c},t=>{(async()=>{try{const o=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})();const i=a?encodeEventTopics({abi:n,eventName:a,args:r}):[];const{unsubscribe:c}=await o.subscribe({params:["logs",{address:s,topics:i}],onData(e){if(!l)return;const s=e.result;try{const{eventName:e,args:r}=decodeEventLog({abi:n,data:s.data,topics:s.topics,strict:f});const o=formatLog(s,{args:r,eventName:e});t.onLogs([o])}catch(r){let e;let n;if(r instanceof dt||r instanceof ht){if(f)return;e=r.abiItem.name;n=r.abiItem.inputs?.some(e=>!("name"in e&&e.name))}const o=formatLog(s,{args:n?[]:{},eventName:e});t.onLogs([o])}},onError(e){t.onError?.(e)}});unsubscribe=c;l||unsubscribe()}catch(o){c?.(o)}})();return()=>unsubscribe()})};return p?pollContractEvent():subscribeContractEvent()}async function writeContract$1(e,t){const{abi:n,account:s=e.account,address:r,args:o,dataSuffix:a,functionName:i,...c}=t;if("undefined"==typeof s)throw new Zt({docsPath:"/docs/contract/writeContract"});const u=s?parseAccount(s):null;const l=encodeFunctionData({abi:n,args:o,functionName:i});try{return await getAction$1(e,sendTransaction$1,"sendTransaction")({data:`${l}${a?a.replace("0x",""):""}`,to:r,account:u,...c})}catch(d){throw getContractError(d,{abi:n,address:r,args:o,docsPath:"/docs/contract/writeContract",functionName:i,sender:u?.address})}}function getAction(e,t,n){const s=e[t.name];if("function"==typeof s)return s;const r=e[n];return"function"==typeof r?r:n=>t(e,n)}const ii="2.19.0";const getVersion$1=()=>`@wagmi/core@${ii}`;var __classPrivateFieldGet=function(e,t,n,s){if("a"===n&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?s:"a"===n?s.call(e):s?s.value:t.get(e)};var ci,ui;let li=class e extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return getVersion$1()}constructor(t,n={}){super();ci.add(this);Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const s=n.cause instanceof e?n.cause.details:n.cause?.message?n.cause.message:n.details;const r=n.cause instanceof e&&n.cause.docsPath||n.docsPath;this.message=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...r?[`Docs: ${this.docsBaseUrl}${r}.html${n.docsSlug?`#${n.docsSlug}`:""}`]:[],...s?[`Details: ${s}`]:[],`Version: ${this.version}`].join("\n");n.cause&&(this.cause=n.cause);this.details=s;this.docsPath=r;this.metaMessages=n.metaMessages;this.shortMessage=t}walk(e){return __classPrivateFieldGet(this,ci,"m",ui).call(this,this,e)}};ci=new WeakSet,ui=function _BaseError_walk2(e,t){return t?.(e)?e:e.cause?__classPrivateFieldGet(this,ci,"m",_BaseError_walk2).call(this,e.cause,t):e};class di extends li{constructor(){super("Chain not configured.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class hi extends li{constructor(){super("Connector already connected.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class fi extends li{constructor(){super("Connector not connected.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class pi extends li{constructor({address:e,connector:t}){super(`Account "${e}" not found for connector "${t.name}".`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class mi extends li{constructor({connectionChainId:e,connectorChainId:t}){super(`The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${e}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e}`]});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}}class gi extends li{constructor({connector:e}){super(`Connector "${e.name}" unavailable while reconnecting.`,{details:["During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.","All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.","This error commonly occurs for connectors that asynchronously inject after reconnection has already started."].join(" ")});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}}async function connect(e,t){let n;n="function"==typeof t.connector?e._internal.connectors.setup(t.connector):t.connector;if(n.uid===e.state.current)throw new hi;try{e.setState(e=>({...e,status:"connecting"}));n.emitter.emit("message",{type:"connecting"});const{connector:s,...r}=t;const o=await n.connect(r);const a=o.accounts;n.emitter.off("connect",e._internal.events.connect);n.emitter.on("change",e._internal.events.change);n.emitter.on("disconnect",e._internal.events.disconnect);await(e.storage?.setItem("recentConnectorId",n.id));e.setState(e=>({...e,connections:new Map(e.connections).set(n.uid,{accounts:a,chainId:o.chainId,connector:n}),current:n.uid,status:"connected"}));return{accounts:a,chainId:o.chainId}}catch(s){e.setState(e=>({...e,status:e.current?"connected":"disconnected"}));throw s}}const yi=256;let bi=yi;let wi;function uid$1(e=11){if(!wi||bi+e>2*yi){wi="";bi=0;for(let e=0;e<yi;e++)wi+=(256+256*Math.random()|0).toString(16).substring(1)}return wi.substring(bi,bi+++e)}function createClient(e){const{batch:t,chain:n,ccipRead:s,key:r="base",name:o="Base Client",type:a="base"}=e;const i=e.experimental_blockTag??("number"==typeof n?.experimental_preconfirmationTime?"pending":void 0);const c=n?.blockTime??12e3;const u=Math.min(Math.max(Math.floor(c/2),500),4e3);const l=e.pollingInterval??u;const d=e.cacheTime??l;const f=e.account?parseAccount(e.account):void 0;const{config:p,request:m,value:g}=e.transport({chain:n,pollingInterval:l});const y={...p,...g};const b={account:f,batch:t,cacheTime:d,ccipRead:s,chain:n,key:r,name:o,pollingInterval:l,request:m,transport:y,type:a,uid:uid$1(),...i?{experimental_blockTag:i}:{}};function extend(e){return t=>{const n=t(e);for(const e in b)delete n[e];const s={...e,...n};return Object.assign(s,{extend:extend(s)})}}return Object.assign(b,{extend:extend(b)})}function createTransport({key:e,methods:t,name:n,request:s,retryCount:r=3,retryDelay:o=150,timeout:a,type:i},c){const u=uid$1();return{config:{key:e,methods:t,name:n,request:s,retryCount:r,retryDelay:o,timeout:a,type:i},request:buildRequest(s,{methods:t,retryCount:r,retryDelay:o,uid:u}),value:c}}function custom(e,t={}){const{key:n="custom",methods:s,name:r="Custom Provider",retryDelay:o}=t;return({retryCount:a})=>createTransport({key:n,methods:s,name:r,request:e.request.bind(e),retryCount:t.retryCount??a,retryDelay:o,type:"custom"})}function fallback(e,t={}){const{key:n="fallback",name:s="Fallback",rank:r=!1,shouldThrow:o=shouldThrow,retryCount:a,retryDelay:i}=t;return({chain:t,pollingInterval:c=4e3,timeout:u,...l})=>{let d=e;let onResponse=()=>{};const f=createTransport({key:n,name:s,async request({method:e,params:n}){let s;const fetch2=async(r=0)=>{const a=d[r]({...l,chain:t,retryCount:0,timeout:u});try{const t=await a.request({method:e,params:n});onResponse({method:e,params:n,response:t,transport:a,status:"success"});return t}catch(i){onResponse({error:i,method:e,params:n,transport:a,status:"error"});if(o(i))throw i;if(r===d.length-1)throw i;s??(s=d.slice(r+1).some(n=>{const{include:s,exclude:r}=n({chain:t}).config.methods||{};return s?s.includes(e):!r||!r.includes(e)}));if(!s)throw i;return fetch2(r+1)}};return fetch2()},retryCount:a,retryDelay:i,type:"fallback"},{onResponse:e=>onResponse=e,transports:d.map(e=>e({chain:t,retryCount:0}))});if(r){const e="object"==typeof r?r:{};rankTransports({chain:t,interval:e.interval??c,onTransports:e=>d=e,ping:e.ping,sampleCount:e.sampleCount,timeout:e.timeout,transports:d,weights:e.weights})}return f}}function shouldThrow(e){return!(!("code"in e)||"number"!=typeof e.code||e.code!==Gn.code&&e.code!==Qn.code&&!hn.nodeMessage.test(e.message)&&5e3!==e.code)}function rankTransports({chain:e,interval:t=4e3,onTransports:n,ping:s,sampleCount:r=10,timeout:o=1e3,transports:a,weights:i={}}){const{stability:c=.7,latency:u=.3}=i;const l=[];const rankTransports_=async()=>{const i=await Promise.all(a.map(async t=>{const n=t({chain:e,retryCount:0,timeout:o});const r=Date.now();let a;let i;try{await(s?s({transport:n}):n.request({method:"net_listening"}));i=1}catch{i=0}finally{a=Date.now()}const c=a-r;return{latency:c,success:i}}));l.push(i);l.length>r&&l.shift();const d=Math.max(...l.map(e=>Math.max(...e.map(({latency:e})=>e))));const f=a.map((e,t)=>{const n=l.map(e=>e[t].latency);const s=n.reduce((e,t)=>e+t,0)/n.length;const r=1-s/d;const o=l.map(e=>e[t].success);const a=o.reduce((e,t)=>e+t,0)/o.length;return 0===a?[0,t]:[u*r+c*a,t]}).sort((e,t)=>t[0]-e[0]);n(f.map(([,e])=>a[e]));await wait(t);rankTransports_()};rankTransports_()}class vi extends Re{constructor(){super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",{docsPath:"/docs/clients/intro",name:"UrlRequiredError"})}}function http(e,t={}){const{batch:n,fetchOptions:s,key:r="http",methods:o,name:a="HTTP JSON-RPC",onFetchRequest:i,onFetchResponse:c,retryDelay:u,raw:l}=t;return({chain:d,retryCount:f,timeout:p})=>{const{batchSize:m=1e3,wait:g=0}="object"==typeof n?n:{};const y=t.retryCount??f;const b=p??t.timeout??1e4;const w=e||d?.rpcUrls.default.http[0];if(!w)throw new vi;const v=getHttpRpcClient(w,{fetchOptions:s,onRequest:i,onResponse:c,timeout:b});return createTransport({key:r,methods:o,name:a,async request({method:e,params:t}){const s={method:e,params:t};const{schedule:r}=createBatchScheduler({id:w,wait:g,shouldSplitBatch:e=>e.length>m,fn:e=>v.request({body:e}),sort:(e,t)=>e.id-t.id});const fn=async e=>n?r(e):[await v.request({body:e})];const[{error:o,result:a}]=await fn(s);if(l)return{error:o,result:a};if(o)throw new On({body:s,error:o,url:w});return a},retryCount:y,retryDelay:u,timeout:b,type:"http"},{fetchOptions:s,url:w})}}function parseSiweMessage(e){const{scheme:t,statement:n,...s}=e.match(xi)?.groups??{};const{chainId:r,expirationTime:o,issuedAt:a,notBefore:i,requestId:c,...u}=e.match(Pi)?.groups??{};const l=e.split("Resources:")[1]?.split("\n- ").slice(1);return{...s,...u,...r?{chainId:Number(r)}:{},...o?{expirationTime:new Date(o)}:{},...a?{issuedAt:new Date(a)}:{},...i?{notBefore:new Date(i)}:{},...c?{requestId:c}:{},...l?{resources:l}:{},...t?{scheme:t}:{},...n?{statement:n}:{}}}const xi=/^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;const Pi=/(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;function validateSiweMessage(e){const{address:t,domain:n,message:s,nonce:r,scheme:o,time:a=new Date}=e;if(n&&s.domain!==n)return!1;if(r&&s.nonce!==r)return!1;if(o&&s.scheme!==o)return!1;if(s.expirationTime&&a>=s.expirationTime)return!1;if(s.notBefore&&a<s.notBefore)return!1;try{if(!s.address)return!1;if(!isAddress(s.address,{strict:!1}))return!1;if(t&&!isAddressEqual(s.address,t))return!1}catch{return!1}return!0}async function verifySiweMessage(e,t){const{address:n,domain:s,message:r,nonce:o,scheme:a,signature:i,time:c=new Date,...u}=t;const l=parseSiweMessage(r);if(!l.address)return!1;const d=validateSiweMessage({address:n,domain:s,message:l,nonce:o,scheme:a,time:c});if(!d)return!1;const f=hashMessage(r);return verifyHash(e,{address:l.address,hash:f,signature:i,...u})}function publicActions(e){return{call:t=>call(e,t),createAccessList:t=>createAccessList(e,t),createBlockFilter:()=>createBlockFilter(e),createContractEventFilter:t=>createContractEventFilter(e,t),createEventFilter:t=>createEventFilter(e,t),createPendingTransactionFilter:()=>createPendingTransactionFilter(e),estimateContractGas:t=>estimateContractGas(e,t),estimateGas:t=>estimateGas$1(e,t),getBalance:t=>getBalance$1(e,t),getBlobBaseFee:()=>getBlobBaseFee(e),getBlock:t=>getBlock(e,t),getBlockNumber:t=>getBlockNumber(e,t),getBlockTransactionCount:t=>getBlockTransactionCount(e,t),getBytecode:t=>getCode(e,t),getChainId:()=>getChainId$1(e),getCode:t=>getCode(e,t),getContractEvents:t=>getContractEvents(e,t),getEip712Domain:t=>getEip712Domain(e,t),getEnsAddress:t=>getEnsAddress(e,t),getEnsAvatar:t=>getEnsAvatar(e,t),getEnsName:t=>getEnsName(e,t),getEnsResolver:t=>getEnsResolver(e,t),getEnsText:t=>getEnsText(e,t),getFeeHistory:t=>getFeeHistory(e,t),estimateFeesPerGas:t=>estimateFeesPerGas(e,t),getFilterChanges:t=>getFilterChanges(e,t),getFilterLogs:t=>getFilterLogs(e,t),getGasPrice:()=>getGasPrice(e),getLogs:t=>getLogs(e,t),getProof:t=>getProof(e,t),estimateMaxPriorityFeePerGas:t=>estimateMaxPriorityFeePerGas(e,t),getStorageAt:t=>getStorageAt(e,t),getTransaction:t=>getTransaction(e,t),getTransactionConfirmations:t=>getTransactionConfirmations(e,t),getTransactionCount:t=>getTransactionCount(e,t),getTransactionReceipt:t=>getTransactionReceipt(e,t),multicall:t=>multicall$1(e,t),prepareTransactionRequest:t=>prepareTransactionRequest$1(e,t),readContract:t=>readContract$1(e,t),sendRawTransaction:t=>sendRawTransaction(e,t),simulate:t=>simulateBlocks(e,t),simulateBlocks:t=>simulateBlocks(e,t),simulateCalls:t=>simulateCalls(e,t),simulateContract:t=>simulateContract(e,t),verifyMessage:t=>verifyMessage(e,t),verifySiweMessage:t=>verifySiweMessage(e,t),verifyTypedData:t=>verifyTypedData(e,t),uninstallFilter:t=>uninstallFilter(e,t),waitForTransactionReceipt:t=>waitForTransactionReceipt$1(e,t),watchBlocks:t=>watchBlocks(e,t),watchBlockNumber:t=>watchBlockNumber(e,t),watchContractEvent:t=>watchContractEvent(e,t),watchEvent:t=>watchEvent(e,t),watchPendingTransactions:t=>watchPendingTransactions$1(e,t)}}function createPublicClient(e){const{key:t="public",name:n="Public Client"}=e;const s=createClient({...e,key:t,name:n,type:"publicClient"});return s.extend(publicActions)}function parseSignature(e){const{r:t,s:n}=oi.Signature.fromCompact(e.slice(2,130));const s=Number(`0x${e.slice(130)}`);const[r,o]=(()=>{if(0===s||1===s)return[void 0,s];if(27===s)return[BigInt(s),0];if(28===s)return[BigInt(s),1];throw new Error("Invalid yParityOrV value")})();return"undefined"!=typeof r?{r:numberToHex(t,{size:32}),s:numberToHex(n,{size:32}),v:r,yParity:o}:{r:numberToHex(t,{size:32}),s:numberToHex(n,{size:32}),yParity:o}}async function getConnectorClient(e,t={}){let n;if(t.connector){const{connector:s}=t;if("reconnecting"===e.state.status&&!s.getAccounts&&!s.getChainId)throw new gi({connector:s});const[r,o]=await Promise.all([s.getAccounts().catch(e=>{if(null===t.account)return[];throw e}),s.getChainId()]);n={accounts:r,chainId:o,connector:s}}else n=e.state.connections.get(e.state.current);if(!n)throw new fi;const s=t.chainId??n.chainId;const r=await n.connector.getChainId();if(r!==n.chainId)throw new mi({connectionChainId:n.chainId,connectorChainId:r});const o=n.connector;if(o.getClient)return o.getClient({chainId:s});const a=parseAccount(t.account??n.accounts[0]);a&&(a.address=getAddress(a.address));if(t.account&&!n.accounts.some(e=>e.toLowerCase()===a.address.toLowerCase()))throw new pi({address:a.address,connector:o});const i=e.chains.find(e=>e.id===s);const c=await n.connector.getProvider({chainId:s});return createClient({account:a,chain:i,name:"Connector Client",transport:e=>custom(c)({...e,retryCount:0})})}async function disconnect(e,t={}){let n;if(t.connector)n=t.connector;else{const{connections:t,current:s}=e.state;const r=t.get(s);n=r?.connector}const s=e.state.connections;if(n){await n.disconnect();n.emitter.off("change",e._internal.events.change);n.emitter.off("disconnect",e._internal.events.disconnect);n.emitter.on("connect",e._internal.events.connect);s.delete(n.uid)}e.setState(e=>{if(0===s.size)return{...e,connections:new Map,current:null,status:"disconnected"};const t=s.values().next().value;return{...e,connections:new Map(s),current:t.connector.uid}});{const t=e.state.current;if(!t)return;const n=e.state.connections.get(t)?.connector;if(!n)return;await(e.storage?.setItem("recentConnectorId",n.id))}}function getUnit(e){return"number"==typeof e?e:"wei"===e?0:Math.abs(dn[e])}async function estimateGas(e,t){const{chainId:n,connector:s,...r}=t;let o;if(t.account)o=t.account;else{const r=await getConnectorClient(e,{account:t.account,chainId:n,connector:s});o=r.account}const a=e.getClient({chainId:n});const i=getAction(a,estimateGas$1,"estimateGas");return i({...r,account:o})}function getAccount(e){const t=e.state.current;const n=e.state.connections.get(t);const s=n?.accounts;const r=s?.[0];const o=e.chains.find(e=>e.id===n?.chainId);const a=e.state.status;switch(a){case"connected":return{address:r,addresses:s,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:a};case"reconnecting":return{address:r,addresses:s,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!!r,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:a};case"connecting":return{address:r,addresses:s,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:a};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:a}}}async function multicall(e,t){const{allowFailure:n=!0,chainId:s,contracts:r,...o}=t;const a=e.getClient({chainId:s});const i=getAction(a,multicall$1,"multicall");return i({allowFailure:n,contracts:r,...o})}function readContract(e,t){const{chainId:n,...s}=t;const r=e.getClient({chainId:n});const o=getAction(r,readContract$1,"readContract");return o(s)}async function readContracts(e,t){const{allowFailure:n=!0,blockNumber:s,blockTag:r,...o}=t;const a=t.contracts;try{const t={};for(const[n,s]of a.entries()){const r=s.chainId??e.state.chainId;t[r]||(t[r]=[]);t[r]?.push({contract:s,index:n})}const promises=()=>Object.entries(t).map(([t,a])=>multicall(e,{...o,allowFailure:n,blockNumber:s,blockTag:r,chainId:Number.parseInt(t),contracts:a.map(({contract:e})=>e)}));const i=(await Promise.all(promises())).flat();const c=Object.values(t).flatMap(e=>e.map(({index:e})=>e));return i.reduce((e,t,n)=>{e&&(e[c[n]]=t);return e},[])}catch(i){if(i instanceof Rr)throw i;const promises=()=>a.map(t=>readContract(e,{...t,blockNumber:s,blockTag:r}));return n?(await Promise.allSettled(promises())).map(e=>"fulfilled"===e.status?{result:e.value,status:"success"}:{error:e.reason,result:void 0,status:"failure"}):await Promise.all(promises())}}async function getBalance(e,t){const{address:n,blockNumber:s,blockTag:r,chainId:o,token:a,unit:i="ether"}=t;if(a)try{return await getTokenBalance(e,{balanceAddress:n,chainId:o,symbolType:"string",tokenAddress:a})}catch(f){if("ContractFunctionExecutionError"===f.name){const t=await getTokenBalance(e,{balanceAddress:n,chainId:o,symbolType:"bytes32",tokenAddress:a});const s=hexToString(trim(t.symbol,{dir:"right"}));return{...t,symbol:s}}throw f}const c=e.getClient({chainId:o});const u=getAction(c,getBalance$1,"getBalance");const l=await u(s?{address:n,blockNumber:s}:{address:n,blockTag:r});const d=e.chains.find(e=>e.id===o)??c.chain;return{decimals:d.nativeCurrency.decimals,formatted:formatUnits(l,getUnit(i)),symbol:d.nativeCurrency.symbol,value:l}}async function getTokenBalance(e,t){const{balanceAddress:n,chainId:s,symbolType:r,tokenAddress:o,unit:a}=t;const i={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:r}]}],address:o};const[c,u,l]=await readContracts(e,{allowFailure:!1,contracts:[{...i,functionName:"balanceOf",args:[n],chainId:s},{...i,functionName:"decimals",chainId:s},{...i,functionName:"symbol",chainId:s}]});const d=formatUnits(c??"0",getUnit(a??u));return{decimals:u,formatted:d,symbol:l,value:c}}function getChainId(e){return e.state.chainId}function deepEqual(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){if(e.constructor!==t.constructor)return!1;let n;let s;if(Array.isArray(e)&&Array.isArray(t)){n=e.length;if(n!==t.length)return!1;for(s=n;0!==s--;)if(!deepEqual(e[s],t[s]))return!1;return!0}if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();const r=Object.keys(e);n=r.length;if(n!==Object.keys(t).length)return!1;for(s=n;0!==s--;)if(!Object.hasOwn(t,r[s]))return!1;for(s=n;0!==s--;){const n=r[s];if(n&&!deepEqual(e[n],t[n]))return!1}return!0}return e!=e&&t!=t}let $i=[];function getChains(e){const t=e.chains;if(deepEqual($i,t))return $i;$i=t;return t}let Ei=[];function getConnections(e){const t=[...e.state.connections.values()];if("reconnecting"===e.state.status)return Ei;if(deepEqual(Ei,t))return Ei;Ei=t;return t}let Ai=[];function getConnectors(e){const t=e.connectors;if(deepEqual(Ai,t))return Ai;Ai=t;return t}async function prepareTransactionRequest(e,t){const{account:n,chainId:s,...r}=t;const o=n??getAccount(e).address;const a=e.getClient({chainId:s});const i=getAction(a,prepareTransactionRequest$1,"prepareTransactionRequest");return i({...r,...o?{account:o}:{}})}let Ti=!1;async function reconnect(e,t={}){if(Ti)return[];Ti=!0;e.setState(e=>({...e,status:e.current?"reconnecting":"connecting"}));const n=[];if(t.connectors?.length)for(const u of t.connectors){let t;t="function"==typeof u?e._internal.connectors.setup(u):u;n.push(t)}else n.push(...e.connectors);let s;try{s=await(e.storage?.getItem("recentConnectorId"))}catch{}const r={};for(const[,u]of e.state.connections)r[u.connector.id]=1;s&&(r[s]=0);const o=Object.keys(r).length>0?[...n].sort((e,t)=>(r[e.id]??10)-(r[t.id]??10)):n;let a=!1;const i=[];const c=[];for(const u of o){const t=await u.getProvider().catch(()=>{});if(!t)continue;if(c.some(e=>e===t))continue;const n=await u.isAuthorized();if(!n)continue;const s=await u.connect({isReconnecting:!0}).catch(()=>null);if(s){u.emitter.off("connect",e._internal.events.connect);u.emitter.on("change",e._internal.events.change);u.emitter.on("disconnect",e._internal.events.disconnect);e.setState(e=>{const t=new Map(a?e.connections:new Map).set(u.uid,{accounts:s.accounts,chainId:s.chainId,connector:u});return{...e,current:a?e.current:u.uid,connections:t}});i.push({accounts:s.accounts,chainId:s.chainId,connector:u});c.push(t);a=!0}}"reconnecting"!==e.state.status&&"connecting"!==e.state.status||(a?e.setState(e=>({...e,status:"connected"})):e.setState(e=>({...e,connections:new Map,current:null,status:"disconnected"})));Ti=!1;return i}async function sendTransaction(e,t){const{account:n,chainId:s,connector:r,...o}=t;let a;a="object"==typeof n&&"local"===n?.type?e.getClient({chainId:s}):await getConnectorClient(e,{account:n??void 0,chainId:s,connector:r});const i=getAction(a,sendTransaction$1,"sendTransaction");const c=await i({...o,...n?{account:n}:{},chain:s?{id:s}:null,gas:o.gas??void 0});return c}async function signMessage(e,t){const{account:n,connector:s,...r}=t;let o;o="object"==typeof n&&"local"===n.type?e.getClient():await getConnectorClient(e,{account:n,connector:s});const a=getAction(o,signMessage$1,"signMessage");return a({...r,...n?{account:n}:{}})}class Ii extends li{constructor(){super("Provider not found.");Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}class Si extends li{constructor({connector:e}){super(`"${e.name}" does not support programmatic chain switching.`);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}async function switchChain(e,t){const{addEthereumChainParameter:n,chainId:s}=t;const r=e.state.connections.get(t.connector?.uid??e.state.current);if(r){const e=r.connector;if(!e.switchChain)throw new Si({connector:e});const t=await e.switchChain({addEthereumChainParameter:n,chainId:s});return t}const o=e.chains.find(e=>e.id===s);if(!o)throw new di;e.setState(e=>({...e,chainId:s}));return o}async function waitForTransactionReceipt(e,t){const{chainId:n,timeout:s=0,...r}=t;const o=e.getClient({chainId:n});const a=getAction(o,waitForTransactionReceipt$1,"waitForTransactionReceipt");const i=await a({...r,timeout:s});if("reverted"===i.status){const e=getAction(o,getTransaction,"getTransaction");const t=await e({hash:i.transactionHash});const n=getAction(o,call,"call");const s=await n({...t,data:t.input,gasPrice:"eip1559"!==t.type?t.gasPrice:void 0,maxFeePerGas:"eip1559"===t.type?t.maxFeePerGas:void 0,maxPriorityFeePerGas:"eip1559"===t.type?t.maxPriorityFeePerGas:void 0});const r=s?.data?hexToString(`0x${s.data.substring(138)}`):"unknown reason";throw new Error(r)}return{...i,chainId:o.chain.id}}function watchAccount(e,t){const{onChange:n}=t;return e.subscribe(()=>getAccount(e),n,{equalityFn(e,t){const{connector:n,...s}=e;const{connector:r,...o}=t;return deepEqual(s,o)&&n?.id===r?.id&&n?.uid===r?.uid}})}function watchChainId(e,t){const{onChange:n}=t;return e.subscribe(e=>e.chainId,n)}function watchConnections(e,t){const{onChange:n}=t;return e.subscribe(()=>getConnections(e),n,{equalityFn:deepEqual})}function watchConnectors(e,t){const{onChange:n}=t;return e._internal.connectors.subscribe((e,t)=>{n(Object.values(e),t)})}function watchPendingTransactions(e,t){const{syncConnectedChain:n=e._internal.syncConnectedChain,...s}=t;let r;const listener=t=>{r&&r();const n=e.getClient({chainId:t});const o=getAction(n,watchPendingTransactions$1,"watchPendingTransactions");r=o(s);return r};const o=listener(t.chainId);let a;n&&!t.chainId&&(a=e.subscribe(({chainId:e})=>e,async e=>listener(e)));return()=>{o?.();a?.()}}async function writeContract(e,t){const{account:n,chainId:s,connector:r,...o}=t;let a;a="object"==typeof n&&"local"===n?.type?e.getClient({chainId:s}):await getConnectorClient(e,{account:n??void 0,chainId:s,connector:r});const i=getAction(a,writeContract$1,"writeContract");const c=await i({...o,...n?{account:n}:{},chain:s?{id:s}:null});return c}function createConnector(e){return e}injected.type="injected";function injected(e={}){const{shimDisconnect:t=!0,unstable_shimAsyncInject:n}=e;function getTarget(){const t=e.target;if("function"==typeof t){const e=t();if(e)return e}return"object"==typeof t?t:"string"==typeof t?{...ki[t]??{id:t,name:`${t[0].toUpperCase()}${t.slice(1)}`,provider:`is${t[0].toUpperCase()}${t.slice(1)}`}}:{id:"injected",name:"Injected",provider:e=>e?.ethereum}}let s;let r;let o;let a;return createConnector(i=>({get icon(){return getTarget().icon},get id(){return getTarget().id},get name(){return getTarget().name},get supportsSimulation(){return!0},type:injected.type,async setup(){const t=await this.getProvider();if(t?.on&&e.target){if(!o){o=this.onConnect.bind(this);t.on("connect",o)}if(!s){s=this.onAccountsChanged.bind(this);t.on("accountsChanged",s)}}},async connect({chainId:n,isReconnecting:c}={}){const u=await this.getProvider();if(!u)throw new Ii;let l=[];if(c)l=await this.getAccounts().catch(()=>[]);else if(t)try{const e=await u.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});l=e[0]?.caveats?.[0]?.value?.map(e=>getAddress(e));if(l.length>0){const e=await this.getAccounts();l=e}}catch(d){const e=d;if(e.code===Qn.code)throw new Qn(e);if(e.code===Dn.code)throw e}try{if(!l?.length&&!c){const e=await u.request({method:"eth_requestAccounts"});l=e.map(e=>getAddress(e))}if(o){u.removeListener("connect",o);o=void 0}if(!s){s=this.onAccountsChanged.bind(this);u.on("accountsChanged",s)}if(!r){r=this.onChainChanged.bind(this);u.on("chainChanged",r)}if(!a){a=this.onDisconnect.bind(this);u.on("disconnect",a)}let d=await this.getChainId();if(n&&d!==n){const e=await this.switchChain({chainId:n}).catch(e=>{if(e.code===Qn.code)throw e;return{id:d}});d=e?.id??d}t&&await(i.storage?.removeItem(`${this.id}.disconnected`));e.target||await(i.storage?.setItem("injected.connected",!0));return{accounts:l,chainId:d}}catch(d){const e=d;if(e.code===Qn.code)throw new Qn(e);if(e.code===Dn.code)throw new Dn(e);throw e}},async disconnect(){const n=await this.getProvider();if(!n)throw new Ii;if(r){n.removeListener("chainChanged",r);r=void 0}if(a){n.removeListener("disconnect",a);a=void 0}if(!o){o=this.onConnect.bind(this);n.on("connect",o)}try{await withTimeout(()=>n.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}t&&await(i.storage?.setItem(`${this.id}.disconnected`,!0));e.target||await(i.storage?.removeItem("injected.connected"))},async getAccounts(){const e=await this.getProvider();if(!e)throw new Ii;const t=await e.request({method:"eth_accounts"});return t.map(e=>getAddress(e))},async getChainId(){const e=await this.getProvider();if(!e)throw new Ii;const t=await e.request({method:"eth_chainId"});return Number(t)},async getProvider(){if("undefined"==typeof window)return;let e;const t=getTarget();e="function"==typeof t.provider?t.provider(window):"string"==typeof t.provider?findProvider(window,t.provider):t.provider;e&&!e.removeListener&&("off"in e&&"function"==typeof e.off?e.removeListener=e.off:e.removeListener=()=>{});return e},async isAuthorized(){try{const s=t&&await(i.storage?.getItem(`${this.id}.disconnected`));if(s)return!1;if(!e.target){const e=await(i.storage?.getItem("injected.connected"));if(!e)return!1}const r=await this.getProvider();if(!r){if(void 0!==n&&!1!==n){const handleEthereum=async()=>{"undefined"!=typeof window&&window.removeEventListener("ethereum#initialized",handleEthereum);const e=await this.getProvider();return!!e};const e="number"==typeof n?n:1e3;const t=await Promise.race([..."undefined"!=typeof window?[new Promise(e=>window.addEventListener("ethereum#initialized",()=>e(handleEthereum()),{once:!0}))]:[],new Promise(t=>setTimeout(()=>t(handleEthereum()),e))]);if(t)return!0}throw new Ii}const o=await withRetry(()=>this.getAccounts());return!!o.length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){const n=await this.getProvider();if(!n)throw new Ii;const s=i.chains.find(e=>e.id===t);if(!s)throw new es(new di);const r=new Promise(e=>{const listener=n=>{if("chainId"in n&&n.chainId===t){i.emitter.off("change",listener);e()}};i.emitter.on("change",listener)});try{await Promise.all([n.request({method:"wallet_switchEthereumChain",params:[{chainId:numberToHex(t)}]}).then(async()=>{const e=await this.getChainId();e===t&&i.emitter.emit("change",{chainId:t})}),r]);return s}catch(o){const c=o;if(4902===c.code||4902===c?.data?.originalError?.code)try{const{default:o,...a}=s.blockExplorers??{};let c;e?.blockExplorerUrls?c=e.blockExplorerUrls:o&&(c=[o.url,...Object.values(a).map(e=>e.url)]);let u;u=e?.rpcUrls?.length?e.rpcUrls:[s.rpcUrls.default?.http[0]??""];const l={blockExplorerUrls:c,chainId:numberToHex(t),chainName:e?.chainName??s.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??s.nativeCurrency,rpcUrls:u};await Promise.all([n.request({method:"wallet_addEthereumChain",params:[l]}).then(async()=>{const e=await this.getChainId();if(e!==t)throw new Qn(new Error("User rejected switch after adding network."));i.emitter.emit("change",{chainId:t})}),r]);return s}catch(a){throw new Qn(a)}if(c.code===Qn.code)throw new Qn(c);throw new es(c)}},async onAccountsChanged(e){if(0===e.length)this.onDisconnect();else if(i.emitter.listenerCount("connect")){const e=(await this.getChainId()).toString();this.onConnect({chainId:e});t&&await(i.storage?.removeItem(`${this.id}.disconnected`))}else i.emitter.emit("change",{accounts:e.map(e=>getAddress(e))})},onChainChanged(e){const t=Number(e);i.emitter.emit("change",{chainId:t})},async onConnect(e){const t=await this.getAccounts();if(0===t.length)return;const n=Number(e.chainId);i.emitter.emit("connect",{accounts:t,chainId:n});const c=await this.getProvider();if(c){if(o){c.removeListener("connect",o);o=void 0}if(!s){s=this.onAccountsChanged.bind(this);c.on("accountsChanged",s)}if(!r){r=this.onChainChanged.bind(this);c.on("chainChanged",r)}if(!a){a=this.onDisconnect.bind(this);c.on("disconnect",a)}}},async onDisconnect(e){const t=await this.getProvider();if(!(e&&1013===e.code&&t&&(await this.getAccounts()).length)){i.emitter.emit("disconnect");if(t){if(r){t.removeListener("chainChanged",r);r=void 0}if(a){t.removeListener("disconnect",a);a=void 0}if(!o){o=this.onConnect.bind(this);t.on("connect",o)}}}}}))}const ki={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider:e=>e?.coinbaseWalletExtension?e.coinbaseWalletExtension:findProvider(e,"isCoinbaseWallet")},metaMask:{id:"metaMask",name:"MetaMask",provider:e=>findProvider(e,e=>{if(!e.isMetaMask)return!1;if(e.isBraveWallet&&!e._events&&!e._state)return!1;const t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPhantom","isPortal","isRabby","isTokenPocket","isTokenary","isUniswapWallet","isZerion"];for(const n of t)if(e[n])return!1;return!0})},phantom:{id:"phantom",name:"Phantom",provider:e=>e?.phantom?.ethereum?e.phantom?.ethereum:findProvider(e,"isPhantom")}};function findProvider(e,t){function isProvider(e){return"function"==typeof t?t(e):"string"!=typeof t||e[t]}const ethereum=e.ethereum;return ethereum?.providers?ethereum.providers.find(e=>isProvider(e)):ethereum&&isProvider(ethereum)?ethereum:void 0}function requestProviders(e){if("undefined"==typeof window)return;const handler=t=>e(t.detail);window.addEventListener("eip6963:announceProvider",handler);window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));return()=>window.removeEventListener("eip6963:announceProvider",handler)}function createStore$1(){const e=new Set;let t=[];const request=()=>requestProviders(n=>{if(!t.some(({info:e})=>e.uuid===n.info.uuid)){t=[...t,n];e.forEach(e=>e(t,{added:[n]}))}});let n=request();return{_listeners:()=>e,clear(){e.forEach(e=>e([],{removed:[...t]}));t=[]},destroy(){this.clear();e.clear();n?.()},findProvider:({rdns:e})=>t.find(t=>t.info.rdns===e),getProviders:()=>t,reset(){this.clear();n?.();n=request()},subscribe(n,{emitImmediately:s}={}){e.add(n);s&&n(t,{added:t});return()=>e.delete(n)}}}const subscribeWithSelectorImpl=e=>(t,n,s)=>{const r=s.subscribe;s.subscribe=(e,t,n)=>{let o=e;if(t){const r=(null==n?void 0:n.equalityFn)||Object.is;let a=e(s.getState());o=n=>{const s=e(n);if(!r(a,s)){const e=a;t(a=s,e)}};(null==n?void 0:n.fireImmediately)&&t(a,a)}return r(o)};const o=e(t,n,s);return o};const Bi=subscribeWithSelectorImpl;function createJSONStorage(e,t){let n;try{n=e()}catch(r){return}const s={getItem:e=>{var t;const parse=e=>null===e?null:JSON.parse(e,void 0);const s=null!=(t=n.getItem(e))?t:null;return s instanceof Promise?s.then(parse):parse(s)},setItem:(e,t)=>n.setItem(e,JSON.stringify(t,void 0)),removeItem:e=>n.removeItem(e)};return s}const toThenable=e=>t=>{try{const n=e(t);return n instanceof Promise?n:{then:e=>toThenable(e)(n),catch(e){return this}}}catch(n){return{then(e){return this},catch:e=>toThenable(e)(n)}}};const persistImpl=(e,t)=>(n,s,r)=>{let o={storage:createJSONStorage(()=>localStorage),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t};let a=!1;const i=new Set;const c=new Set;let u=o.storage;if(!u)return e((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`);n(...e)},s,r);const setItem=()=>{const e=o.partialize({...s()});return u.setItem(o.name,{state:e,version:o.version})};const l=r.setState;r.setState=(e,t)=>{l(e,t);void setItem()};const d=e((...e)=>{n(...e);void setItem()},s,r);r.getInitialState=()=>d;let f;const hydrate2=()=>{var e,t;if(!u)return;a=!1;i.forEach(e=>{var t;return e(null!=(t=s())?t:d)});const r=(null==(t=o.onRehydrateStorage)?void 0:t.call(o,null!=(e=s())?e:d))||void 0;return toThenable(u.getItem.bind(u))(o.name).then(e=>{if(e){if("number"!=typeof e.version||e.version===o.version)return[!1,e.state];if(o.migrate)return[!0,o.migrate(e.state,e.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(e=>{var t;const[r,a]=e;f=o.merge(a,null!=(t=s())?t:d);n(f,!0);if(r)return setItem()}).then(()=>{null==r?void 0:r(f,void 0);f=s();a=!0;c.forEach(e=>e(f))}).catch(e=>{null==r?void 0:r(void 0,e)})};r.persist={setOptions:e=>{o={...o,...e};e.storage&&(u=e.storage)},clearStorage:()=>{null==u?void 0:u.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>hydrate2(),hasHydrated:()=>a,onHydrate:e=>{i.add(e);return()=>{i.delete(e)}},onFinishHydration:e=>{c.add(e);return()=>{c.delete(e)}}};o.skipHydration||hydrate2();return f||d};const Ci=persistImpl;const createStoreImpl=e=>{let t;const n=new Set;const setState=(e,s)=>{const r="function"==typeof e?e(t):e;if(!Object.is(r,t)){const e=t;t=(null!=s?s:"object"!=typeof r||null===r)?r:Object.assign({},t,r);n.forEach(n=>n(t,e))}};const getState=()=>t;const getInitialState=()=>r;const subscribe=e=>{n.add(e);return()=>n.delete(e)};const s={setState:setState,getState:getState,getInitialState:getInitialState,subscribe:subscribe};const r=t=e(setState,getState,s);return s};const createStore=e=>e?createStoreImpl(e):createStoreImpl;var Oi={exports:{}};var Fi;function requireEventemitter3(){if(Fi)return Oi.exports;Fi=1;!function(e){var t=Object.prototype.hasOwnProperty,n="~";function Events(){}if(Object.create){Events.prototype=Object.create(null);(new Events).__proto__||(n=!1)}function EE(e,t,n){this.fn=e;this.context=t;this.once=n||!1}function addListener(e,t,s,r,o){if("function"!=typeof s)throw new TypeError("The listener must be a function");var a=new EE(s,r||e,o),i=n?n+t:t;e._events[i]?e._events[i].fn?e._events[i]=[e._events[i],a]:e._events[i].push(a):(e._events[i]=a,e._eventsCount++);return e}function clearEvent(e,t){0===--e._eventsCount?e._events=new Events:delete e._events[t]}function EventEmitter2(){this._events=new Events;this._eventsCount=0}EventEmitter2.prototype.eventNames=function(){var e,s,r=[];if(0===this._eventsCount)return r;for(s in e=this._events)t.call(e,s)&&r.push(n?s.slice(1):s);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(e)):r};EventEmitter2.prototype.listeners=function(e){var t=n?n+e:e,s=this._events[t];if(!s)return[];if(s.fn)return[s.fn];for(var r=0,o=s.length,a=new Array(o);r<o;r++)a[r]=s[r].fn;return a};EventEmitter2.prototype.listenerCount=function(e){var t=n?n+e:e,s=this._events[t];return s?s.fn?1:s.length:0};EventEmitter2.prototype.emit=function(e,t,s,r,o,a){var i=n?n+e:e;if(!this._events[i])return!1;var c,u,l=this._events[i],d=arguments.length;if(l.fn){l.once&&this.removeListener(e,l.fn,void 0,!0);switch(d){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,t),!0;case 3:return l.fn.call(l.context,t,s),!0;case 4:return l.fn.call(l.context,t,s,r),!0;case 5:return l.fn.call(l.context,t,s,r,o),!0;case 6:return l.fn.call(l.context,t,s,r,o,a),!0}for(u=1,c=new Array(d-1);u<d;u++)c[u-1]=arguments[u];l.fn.apply(l.context,c)}else{var f,p=l.length;for(u=0;u<p;u++){l[u].once&&this.removeListener(e,l[u].fn,void 0,!0);switch(d){case 1:l[u].fn.call(l[u].context);break;case 2:l[u].fn.call(l[u].context,t);break;case 3:l[u].fn.call(l[u].context,t,s);break;case 4:l[u].fn.call(l[u].context,t,s,r);break;default:if(!c)for(f=1,c=new Array(d-1);f<d;f++)c[f-1]=arguments[f];l[u].fn.apply(l[u].context,c)}}}return!0};EventEmitter2.prototype.on=function(e,t,n){return addListener(this,e,t,n,!1)};EventEmitter2.prototype.once=function(e,t,n){return addListener(this,e,t,n,!0)};EventEmitter2.prototype.removeListener=function(e,t,s,r){var o=n?n+e:e;if(!this._events[o])return this;if(!t){clearEvent(this,o);return this}var a=this._events[o];if(a.fn)a.fn!==t||r&&!a.once||s&&a.context!==s||clearEvent(this,o);else{for(var i=0,c=[],u=a.length;i<u;i++)(a[i].fn!==t||r&&!a[i].once||s&&a[i].context!==s)&&c.push(a[i]);c.length?this._events[o]=1===c.length?c[0]:c:clearEvent(this,o)}return this};EventEmitter2.prototype.removeAllListeners=function(e){var t;if(e){t=n?n+e:e;this._events[t]&&clearEvent(this,t)}else{this._events=new Events;this._eventsCount=0}return this};EventEmitter2.prototype.off=EventEmitter2.prototype.removeListener;EventEmitter2.prototype.addListener=EventEmitter2.prototype.on;EventEmitter2.prefixed=n;EventEmitter2.EventEmitter=EventEmitter2;e.exports=EventEmitter2}(Oi);return Oi.exports}var Ni=requireEventemitter3();const Ri=Ee(Ni);class Mi{constructor(e){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:e});Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Ri})}on(e,t){this._emitter.on(e,t)}once(e,t){this._emitter.once(e,t)}off(e,t){this._emitter.off(e,t)}emit(e,...t){const n=t[0];this._emitter.emit(e,{uid:this.uid,...n})}listenerCount(e){return this._emitter.listenerCount(e)}}function createEmitter(e){return new Mi(e)}function deserialize(e,t){return JSON.parse(e,(e,n)=>{let s=n;"bigint"===s?.__type&&(s=BigInt(s.value));"Map"===s?.__type&&(s=new Map(s.value));return t?.(e,s)??s})}function getReferenceKey(e,t){return e.slice(0,t).join(".")||"."}function getCutoff(e,t){const{length:n}=e;for(let s=0;s<n;++s)if(e[s]===t)return s+1;return 0}function createReplacer(e,t){const n="function"==typeof e;const s="function"==typeof t;const r=[];const o=[];return function(a,i){if("object"==typeof i)if(r.length){const e=getCutoff(r,this);if(0===e)r[r.length]=this;else{r.splice(e);o.splice(e)}o[o.length]=a;const n=getCutoff(r,i);if(0!==n)return s?t.call(this,a,i,getReferenceKey(o,n)):`[ref=${getReferenceKey(o,n)}]`}else{r[0]=i;o[0]=a}return n?e.call(this,a,i):i}}function serialize(e,t,n,s){return JSON.stringify(e,createReplacer((e,n)=>{let s=n;"bigint"==typeof s&&(s={__type:"bigint",value:n.toString()});s instanceof Map&&(s={__type:"Map",value:Array.from(n.entries())});return t?.(e,s)??s},s),n??void 0)}function createStorage(e){const{deserialize:t=deserialize,key:n="wagmi",serialize:s=serialize,storage:r=zi}=e;function unwrap(e){return e instanceof Promise?e.then(e=>e).catch(()=>null):e}return{...r,key:n,async getItem(e,s){const o=r.getItem(`${n}.${e}`);const a=await unwrap(o);return a?t(a)??null:s??null},async setItem(e,t){const o=`${n}.${e}`;null===t?await unwrap(r.removeItem(o)):await unwrap(r.setItem(o,s(t)))},async removeItem(e){await unwrap(r.removeItem(`${n}.${e}`))}}}const zi={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function getDefaultStorage(){const e=(()=>"undefined"!=typeof window&&window.localStorage?window.localStorage:zi)();return{getItem:t=>e.getItem(t),removeItem(t){e.removeItem(t)},setItem(t,n){try{e.setItem(t,n)}catch{}}}}const ji=256;let qi=ji;let Li;function uid(e=11){if(!Li||qi+e>2*ji){Li="";qi=0;for(let e=0;e<ji;e++)Li+=(256+256*Math.random()|0).toString(16).substring(1)}return Li.substring(qi,qi+++e)}function createConfig(e){const{multiInjectedProviderDiscovery:t=!0,storage:n=createStorage({storage:getDefaultStorage()}),syncConnectedChain:s=!0,ssr:r=!1,...o}=e;const a="undefined"!=typeof window&&t?createStore$1():void 0;const i=createStore(()=>o.chains);const c=createStore(()=>{const e=[];const t=new Set;for(const n of o.connectors??[]){const s=setup(n);e.push(s);if(!r&&s.rdns){const e="string"==typeof s.rdns?[s.rdns]:s.rdns;for(const n of e)t.add(n)}}if(!r&&a){const n=a.getProviders();for(const s of n)t.has(s.info.rdns)||e.push(setup(providerDetailToConnector(s)))}return e});function setup(e){const t=createEmitter(uid());const s={...e({emitter:t,chains:i.getState(),storage:n,transports:o.transports}),emitter:t,uid:t.uid};t.on("connect",connect2);s.setup?.();return s}function providerDetailToConnector(e){const{info:t}=e;const n=e.provider;return injected({target:{...t,id:t.rdns,provider:n}})}const u=new Map;function getClient(e={}){const t=e.chainId??f.getState().chainId;const n=i.getState().find(e=>e.id===t);if(e.chainId&&!n)throw new di;{const e=u.get(f.getState().chainId);if(e&&!n)return e;if(!n)throw new di}{const e=u.get(t);if(e)return e}let s;if(o.client)s=o.client({chain:n});else{const e=n.id;const t=i.getState().map(e=>e.id);const r={};const a=Object.entries(o);for(const[n,s]of a)if("chains"!==n&&"client"!==n&&"connectors"!==n&&"transports"!==n)if("object"==typeof s)if(e in s)r[n]=s[e];else{const e=t.some(e=>e in s);if(e)continue;r[n]=s}else r[n]=s;s=createClient({...r,chain:n,batch:r.batch??{multicall:!0},transport:t=>o.transports[e]({...t,connectors:c})})}u.set(t,s);return s}function getInitialState(){return{chainId:i.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let l;const d="0.0.0-canary-";l=ii.startsWith(d)?Number.parseInt(ii.replace(d,"")):Number.parseInt(ii.split(".")[0]??"0");const f=createStore(Bi(n?Ci(getInitialState,{migrate(e,t){if(t===l)return e;const n=getInitialState();const s=validatePersistedChainId(e,n.chainId);return{...n,chainId:s}},name:"store",partialize:e=>({connections:{__type:"Map",value:Array.from(e.connections.entries()).map(([e,t])=>{const{id:n,name:s,type:r,uid:o}=t.connector;const a={id:n,name:s,type:r,uid:o};return[e,{...t,connector:a}]})},chainId:e.chainId,current:e.current}),merge(e,t){"object"==typeof e&&e&&"status"in e&&delete e.status;const n=validatePersistedChainId(e,t.chainId);return{...t,...e,chainId:n}},skipHydration:r,storage:n,version:l}):getInitialState));f.setState(getInitialState());function validatePersistedChainId(e,t){return e&&"object"==typeof e&&"chainId"in e&&"number"==typeof e.chainId&&i.getState().some(t=>t.id===e.chainId)?e.chainId:t}s&&f.subscribe(({connections:e,current:t})=>t?e.get(t)?.chainId:void 0,e=>{const t=i.getState().some(t=>t.id===e);if(t)return f.setState(t=>({...t,chainId:e??t.chainId}))});a?.subscribe(e=>{const t=new Set;const s=new Set;for(const n of c.getState()){t.add(n.id);if(n.rdns){const e="string"==typeof n.rdns?[n.rdns]:n.rdns;for(const t of e)s.add(t)}}const r=[];for(const n of e){if(s.has(n.info.rdns))continue;const e=setup(providerDetailToConnector(n));t.has(e.id)||r.push(e)}n&&!f.persist.hasHydrated()||c.setState(e=>[...e,...r],!0)});function change(e){f.setState(t=>{const n=t.connections.get(e.uid);return n?{...t,connections:new Map(t.connections).set(e.uid,{accounts:e.accounts??n.accounts,chainId:e.chainId??n.chainId,connector:n.connector})}:t})}function connect2(e){"connecting"!==f.getState().status&&"reconnecting"!==f.getState().status&&f.setState(t=>{const n=c.getState().find(t=>t.uid===e.uid);if(!n)return t;n.emitter.listenerCount("connect")&&n.emitter.off("connect",change);n.emitter.listenerCount("change")||n.emitter.on("change",change);n.emitter.listenerCount("disconnect")||n.emitter.on("disconnect",disconnect2);return{...t,connections:new Map(t.connections).set(e.uid,{accounts:e.accounts,chainId:e.chainId,connector:n}),current:e.uid,status:"connected"}})}function disconnect2(e){f.setState(t=>{const n=t.connections.get(e.uid);if(n){const e=n.connector;e.emitter.listenerCount("change")&&n.connector.emitter.off("change",change);e.emitter.listenerCount("disconnect")&&n.connector.emitter.off("disconnect",disconnect2);e.emitter.listenerCount("connect")||n.connector.emitter.on("connect",connect2)}t.connections.delete(e.uid);if(0===t.connections.size)return{...t,connections:new Map,current:null,status:"disconnected"};const s=t.connections.values().next().value;return{...t,connections:new Map(t.connections),current:s.connector.uid}})}return{get chains(){return i.getState()},get connectors(){return c.getState()},storage:n,getClient:getClient,get state(){return f.getState()},setState(e){let t;t="function"==typeof e?e(f.getState()):e;const n=getInitialState();"object"!=typeof t&&(t=n);const s=Object.keys(n).some(e=>!(e in t));s&&(t=n);f.setState(t,!0)},subscribe:(e,t,n)=>f.subscribe(e,t,n?{...n,fireImmediately:n.emitImmediately}:void 0),_internal:{mipd:a,store:f,ssr:Boolean(r),syncConnectedChain:s,transports:o.transports,chains:{setState(e){const t="function"==typeof e?e(i.getState()):e;if(0!==t.length)return i.setState(t,!0)},subscribe:e=>i.subscribe(e)},connectors:{providerDetailToConnector:providerDetailToConnector,setup:setup,setState:e=>c.setState("function"==typeof e?e(c.getState()):e,!0),subscribe:e=>c.subscribe(e)},events:{change:change,connect:connect2,disconnect:disconnect2}}}}function hydrate(e,t){const{initialState:n,reconnectOnMount:s}=t;n&&!e._internal.store.persist.hasHydrated()&&e.setState({...n,chainId:e.chains.some(e=>e.id===n.chainId)?n.chainId:e.chains[0].id,connections:s?n.connections:new Map,status:s?"reconnecting":"disconnected"});return{async onMount(){if(e._internal.ssr){await e._internal.store.persist.rehydrate();e._internal.mipd&&e._internal.connectors.setState(t=>{const n=new Set;for(const e of t??[])if(e.rdns){const t=Array.isArray(e.rdns)?e.rdns:[e.rdns];for(const e of t)n.add(e)}const s=[];const r=e._internal.mipd?.getProviders()??[];for(const o of r){if(n.has(o.info.rdns))continue;const t=e._internal.connectors.providerDetailToConnector(o);const r=e._internal.connectors.setup(t);s.push(r)}return[...t,...s]})}s?reconnect(e):e.storage&&e.setState(e=>({...e,connections:new Map}))}}}function Hydrate(e){const{children:t,config:n,initialState:s,reconnectOnMount:r=!0}=e;const{onMount:o}=hydrate(n,{initialState:s,reconnectOnMount:r});n._internal.ssr||o();const a=Be.useRef(!0);Be.useEffect(()=>{if(a.current&&n._internal.ssr){o();return()=>{a.current=!1}}},[]);return t}const Hi=Be.createContext(void 0);function WagmiProvider(e){const{children:t,config:n}=e;const s={value:n};return Be.createElement(Hydrate,e,Be.createElement(Hi.Provider,s,t))}const Ui="2.16.2";const getVersion=()=>`wagmi@${Ui}`;class _i extends li{constructor(){super(...arguments);Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/react"}get version(){return getVersion()}}class Di extends _i{constructor(){super("`useConfig` must be used within `WagmiProvider`.",{docsPath:"/api/WagmiProvider"});Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiProviderNotFoundError"})}}function useConfig(e={}){const t=e.config??Be.useContext(Hi);if(!t)throw new Di;return t}function watchChains(e,t){const{onChange:n}=t;return e._internal.chains.subscribe((e,t)=>{n(e,t)})}var Gi={exports:{}};var Wi={};var Vi={exports:{}};var Ki={};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Qi;function requireUseSyncExternalStoreShim_production(){if(Qi)return Ki;Qi=1;var e=$e();function is(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t}var t="function"==typeof Object.is?Object.is:is,n=e.useState,s=e.useEffect,r=e.useLayoutEffect,o=e.useDebugValue;function useSyncExternalStore$2(e,t){var a=t(),i=n({inst:{value:a,getSnapshot:t}}),c=i[0].inst,u=i[1];r(function(){c.value=a;c.getSnapshot=t;checkIfSnapshotChanged(c)&&u({inst:c})},[e,a,t]);s(function(){checkIfSnapshotChanged(c)&&u({inst:c});return e(function(){checkIfSnapshotChanged(c)&&u({inst:c})})},[e]);o(a);return a}function checkIfSnapshotChanged(e){var n=e.getSnapshot;e=e.value;try{var s=n();return!t(e,s)}catch(r){return!0}}function useSyncExternalStore$1(e,t){return t()}var a="undefined"==typeof window||"undefined"==typeof window.document||"undefined"==typeof window.document.createElement?useSyncExternalStore$1:useSyncExternalStore$2;Ki.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:a;return Ki}var Zi;function requireShim(){if(Zi)return Vi.exports;Zi=1;Vi.exports=requireUseSyncExternalStoreShim_production();return Vi.exports}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ji;function requireWithSelector_production(){if(Ji)return Wi;Ji=1;var e=$e(),t=requireShim();function is(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t}var n="function"==typeof Object.is?Object.is:is,s=t.useSyncExternalStore,r=e.useRef,o=e.useEffect,a=e.useMemo,i=e.useDebugValue;Wi.useSyncExternalStoreWithSelector=function(e,t,c,u,l){var d=r(null);if(null===d.current){var f={hasValue:!1,value:null};d.current=f}else f=d.current;d=a(function(){function memoizedSelector(t){if(!r){r=!0;e=t;t=u(t);if(void 0!==l&&f.hasValue){var o=f.value;if(l(o,t))return s=o}return s=t}o=s;if(n(e,t))return o;var a=u(t);if(void 0!==l&&l(o,a))return e=t,o;e=t;return s=a}var e,s,r=!1,o=void 0===c?null:c;return[function(){return memoizedSelector(t())},null===o?void 0:function(){return memoizedSelector(o())}]},[t,c,u,l]);var p=s(e,d[0],d[1]);o(function(){f.hasValue=!0;f.value=p},[p]);i(p);return p};return Wi}var Yi;function requireWithSelector(){if(Yi)return Gi.exports;Yi=1;Gi.exports=requireWithSelector_production();return Gi.exports}var Xi=requireWithSelector();const isPlainObject$2=e=>"object"==typeof e&&!Array.isArray(e);function useSyncExternalStoreWithTracked(e,t,n=t,s=deepEqual){const r=Be.useRef([]);const o=Xi.useSyncExternalStoreWithSelector(e,t,n,e=>e,(e,t)=>{if(isPlainObject$2(e)&&isPlainObject$2(t)&&r.current.length){for(const n of r.current){const r=s(e[n],t[n]);if(!r)return!1}return!0}return s(e,t)});return Be.useMemo(()=>{if(isPlainObject$2(o)){const e={...o};let t={};for(const[n,s]of Object.entries(e))t={...t,[n]:{configurable:!1,enumerable:!0,get:()=>{r.current.includes(n)||r.current.push(n);return s}}};Object.defineProperties(e,t);return e}return o},[o])}function useAccount(e={}){const t=useConfig(e);return useSyncExternalStoreWithTracked(e=>watchAccount(t,{onChange:e}),()=>getAccount(t))}var ec=class{constructor(){this.listeners=new Set;this.subscribe=this.subscribe.bind(this)}subscribe(e){this.listeners.add(e);this.onSubscribe();return()=>{this.listeners.delete(e);this.onUnsubscribe()}}hasListeners(){return this.listeners.size>0}onSubscribe(){}onUnsubscribe(){}};var tc="undefined"==typeof window||"Deno"in globalThis;function noop(){}function functionalUpdate(e,t){return"function"==typeof e?e(t):e}function isValidTimeout(e){return"number"==typeof e&&e>=0&&e!==1/0}function timeUntilStale(e,t){return Math.max(e+(t||0)-Date.now(),0)}function resolveStaleTime(e,t){return"function"==typeof e?e(t):e}function resolveEnabled(e,t){return"function"==typeof e?e(t):e}function matchQuery(e,t){const{type:n="all",exact:s,fetchStatus:r,predicate:o,queryKey:a,stale:i}=e;if(a)if(s){if(t.queryHash!==hashQueryKeyByOptions(a,t.options))return!1}else if(!partialMatchKey(t.queryKey,a))return!1;if("all"!==n){const e=t.isActive();if("active"===n&&!e)return!1;if("inactive"===n&&e)return!1}return("boolean"!=typeof i||t.isStale()===i)&&((!r||r===t.state.fetchStatus)&&!(o&&!o(t)))}function matchMutation(e,t){const{exact:n,status:s,predicate:r,mutationKey:o}=e;if(o){if(!t.options.mutationKey)return!1;if(n){if(hashKey(t.options.mutationKey)!==hashKey(o))return!1}else if(!partialMatchKey(t.options.mutationKey,o))return!1}return(!s||t.state.status===s)&&!(r&&!r(t))}function hashQueryKeyByOptions(e,t){const n=t?.queryKeyHashFn||hashKey;return n(e)}function hashKey(e){return JSON.stringify(e,(e,t)=>isPlainObject$1(t)?Object.keys(t).sort().reduce((e,n)=>{e[n]=t[n];return e},{}):t)}function partialMatchKey(e,t){return e===t||typeof e==typeof t&&(!(!e||!t||"object"!=typeof e||"object"!=typeof t)&&Object.keys(t).every(n=>partialMatchKey(e[n],t[n])))}function replaceEqualDeep(e,t){if(e===t)return e;const n=isPlainArray(e)&&isPlainArray(t);if(n||isPlainObject$1(e)&&isPlainObject$1(t)){const s=n?e:Object.keys(e);const r=s.length;const o=n?t:Object.keys(t);const a=o.length;const i=n?[]:{};const c=new Set(s);let u=0;for(let l=0;l<a;l++){const s=n?l:o[l];if((!n&&c.has(s)||n)&&void 0===e[s]&&void 0===t[s]){i[s]=void 0;u++}else{i[s]=replaceEqualDeep(e[s],t[s]);i[s]===e[s]&&void 0!==e[s]&&u++}}return r===a&&u===r?e:i}return t}function shallowEqualObjects(e,t){if(!t||Object.keys(e).length!==Object.keys(t).length)return!1;for(const n in e)if(e[n]!==t[n])return!1;return!0}function isPlainArray(e){return Array.isArray(e)&&e.length===Object.keys(e).length}function isPlainObject$1(e){if(!hasObjectPrototype$1(e))return!1;const t=e.constructor;if(void 0===t)return!0;const n=t.prototype;return!!hasObjectPrototype$1(n)&&(!!n.hasOwnProperty("isPrototypeOf")&&Object.getPrototypeOf(e)===Object.prototype)}function hasObjectPrototype$1(e){return"[object Object]"===Object.prototype.toString.call(e)}function sleep(e){return new Promise(t=>{setTimeout(t,e)})}function replaceData(e,t,n){return"function"==typeof n.structuralSharing?n.structuralSharing(e,t):!1!==n.structuralSharing?replaceEqualDeep(e,t):t}function addToEnd(e,t,n=0){const s=[...e,t];return n&&s.length>n?s.slice(1):s}function addToStart(e,t,n=0){const s=[t,...e];return n&&s.length>n?s.slice(0,-1):s}var nc=Symbol();function ensureQueryFn(e,t){return!e.queryFn&&t?.initialPromise?()=>t.initialPromise:e.queryFn&&e.queryFn!==nc?e.queryFn:()=>Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`))}function shouldThrowError(e,t){return"function"==typeof e?e(...t):!!e}var sc=(s=class extends ec{constructor(){super();__privateAdd(this,e);__privateAdd(this,t);__privateAdd(this,n);__privateSet(this,n,e=>{if(!tc&&window.addEventListener){const listener=()=>e();window.addEventListener("visibilitychange",listener,!1);return()=>{window.removeEventListener("visibilitychange",listener)}}})}onSubscribe(){__privateGet(this,t)||this.setEventListener(__privateGet(this,n))}onUnsubscribe(){var e;if(!this.hasListeners()){null==(e=__privateGet(this,t))?void 0:e.call(this);__privateSet(this,t,void 0)}}setEventListener(e){var s;__privateSet(this,n,e);null==(s=__privateGet(this,t))?void 0:s.call(this);__privateSet(this,t,e(e=>{"boolean"==typeof e?this.setFocused(e):this.onFocus()}))}setFocused(t){const n=__privateGet(this,e)!==t;if(n){__privateSet(this,e,t);this.onFocus()}}onFocus(){const e=this.isFocused();this.listeners.forEach(t=>{t(e)})}isFocused(){return"boolean"==typeof __privateGet(this,e)?__privateGet(this,e):"hidden"!==globalThis.document?.visibilityState}},e=new WeakMap,t=new WeakMap,n=new WeakMap,s);var rc=new sc;var oc=(i=class extends ec{constructor(){super();__privateAdd(this,r,!0);__privateAdd(this,o);__privateAdd(this,a);__privateSet(this,a,e=>{if(!tc&&window.addEventListener){const onlineListener=()=>e(!0);const offlineListener=()=>e(!1);window.addEventListener("online",onlineListener,!1);window.addEventListener("offline",offlineListener,!1);return()=>{window.removeEventListener("online",onlineListener);window.removeEventListener("offline",offlineListener)}}})}onSubscribe(){__privateGet(this,o)||this.setEventListener(__privateGet(this,a))}onUnsubscribe(){var e;if(!this.hasListeners()){null==(e=__privateGet(this,o))?void 0:e.call(this);__privateSet(this,o,void 0)}}setEventListener(e){var t;__privateSet(this,a,e);null==(t=__privateGet(this,o))?void 0:t.call(this);__privateSet(this,o,e(this.setOnline.bind(this)))}setOnline(e){const t=__privateGet(this,r)!==e;if(t){__privateSet(this,r,e);this.listeners.forEach(t=>{t(e)})}}isOnline(){return __privateGet(this,r)}},r=new WeakMap,o=new WeakMap,a=new WeakMap,i);var ac=new oc;function pendingThenable(){let e;let t;const n=new Promise((n,s)=>{e=n;t=s});n.status="pending";n.catch(()=>{});function finalize(e){Object.assign(n,e);delete n.resolve;delete n.reject}n.resolve=t=>{finalize({status:"fulfilled",value:t});e(t)};n.reject=e=>{finalize({status:"rejected",reason:e});t(e)};return n}function defaultRetryDelay(e){return Math.min(1e3*2**e,3e4)}function canFetch(e){return"online"!==(e??"online")||ac.isOnline()}var ic=class extends Error{constructor(e){super("CancelledError");this.revert=e?.revert;this.silent=e?.silent}};function isCancelledError(e){return e instanceof ic}function createRetryer(e){let t=!1;let n=0;let s=!1;let r;const o=pendingThenable();const cancel=t=>{if(!s){reject(new ic(t));e.abort?.()}};const cancelRetry=()=>{t=!0};const continueRetry=()=>{t=!1};const canContinue=()=>rc.isFocused()&&("always"===e.networkMode||ac.isOnline())&&e.canRun();const canStart=()=>canFetch(e.networkMode)&&e.canRun();const resolve=t=>{if(!s){s=!0;e.onSuccess?.(t);r?.();o.resolve(t)}};const reject=t=>{if(!s){s=!0;e.onError?.(t);r?.();o.reject(t)}};const pause=()=>new Promise(t=>{r=e=>{(s||canContinue())&&t(e)};e.onPause?.()}).then(()=>{r=void 0;s||e.onContinue?.()});const run=()=>{if(s)return;let r;const o=0===n?e.initialPromise:void 0;try{r=o??e.fn()}catch(a){r=Promise.reject(a)}Promise.resolve(r).then(resolve).catch(r=>{if(s)return;const o=e.retry??(tc?0:3);const a=e.retryDelay??defaultRetryDelay;const i="function"==typeof a?a(n,r):a;const c=!0===o||"number"==typeof o&&n<o||"function"==typeof o&&o(n,r);if(!t&&c){n++;e.onFail?.(n,r);sleep(i).then(()=>canContinue()?void 0:pause()).then(()=>{t?reject(r):run()})}else reject(r)})};return{promise:o,cancel:cancel,continue:()=>{r?.();return o},cancelRetry:cancelRetry,continueRetry:continueRetry,canStart:canStart,start:()=>{canStart()?run():pause().then(run);return o}}}var defaultScheduler=e=>setTimeout(e,0);function createNotifyManager(){let e=[];let t=0;let notifyFn=e=>{e()};let batchNotifyFn=e=>{e()};let n=defaultScheduler;const schedule=s=>{t?e.push(s):n(()=>{notifyFn(s)})};const flush=()=>{const t=e;e=[];t.length&&n(()=>{batchNotifyFn(()=>{t.forEach(e=>{notifyFn(e)})})})};return{batch:e=>{let n;t++;try{n=e()}finally{t--;t||flush()}return n},batchCalls:e=>(...t)=>{schedule(()=>{e(...t)})},schedule:schedule,setNotifyFunction:e=>{notifyFn=e},setBatchNotifyFunction:e=>{batchNotifyFn=e},setScheduler:e=>{n=e}}}var cc=createNotifyManager();var uc=(u=class{constructor(){__privateAdd(this,c)}destroy(){this.clearGcTimeout()}scheduleGc(){this.clearGcTimeout();isValidTimeout(this.gcTime)&&__privateSet(this,c,setTimeout(()=>{this.optionalRemove()},this.gcTime))}updateGcTime(e){this.gcTime=Math.max(this.gcTime||0,e??(tc?1/0:3e5))}clearGcTimeout(){if(__privateGet(this,c)){clearTimeout(__privateGet(this,c));__privateSet(this,c,void 0)}}},c=new WeakMap,u);var lc=(v=class extends uc{constructor(e){super();__privateAdd(this,b);__privateAdd(this,l);__privateAdd(this,d);__privateAdd(this,f);__privateAdd(this,p);__privateAdd(this,m);__privateAdd(this,g);__privateAdd(this,y);__privateSet(this,y,!1);__privateSet(this,g,e.defaultOptions);this.setOptions(e.options);this.observers=[];__privateSet(this,p,e.client);__privateSet(this,f,__privateGet(this,p).getQueryCache());this.queryKey=e.queryKey;this.queryHash=e.queryHash;__privateSet(this,l,getDefaultState$1(this.options));this.state=e.state??__privateGet(this,l);this.scheduleGc()}get meta(){return this.options.meta}get promise(){return __privateGet(this,m)?.promise}setOptions(e){this.options={...__privateGet(this,g),...e};this.updateGcTime(this.options.gcTime)}optionalRemove(){this.observers.length||"idle"!==this.state.fetchStatus||__privateGet(this,f).remove(this)}setData(e,t){const n=replaceData(this.state.data,e,this.options);__privateMethod(this,b,w).call(this,{data:n,type:"success",dataUpdatedAt:t?.updatedAt,manual:t?.manual});return n}setState(e,t){__privateMethod(this,b,w).call(this,{type:"setState",state:e,setStateOptions:t})}cancel(e){const t=__privateGet(this,m)?.promise;__privateGet(this,m)?.cancel(e);return t?t.then(noop).catch(noop):Promise.resolve()}destroy(){super.destroy();this.cancel({silent:!0})}reset(){this.destroy();this.setState(__privateGet(this,l))}isActive(){return this.observers.some(e=>!1!==resolveEnabled(e.options.enabled,this))}isDisabled(){return this.getObserversCount()>0?!this.isActive():this.options.queryFn===nc||this.state.dataUpdateCount+this.state.errorUpdateCount===0}isStatic(){return this.getObserversCount()>0&&this.observers.some(e=>"static"===resolveStaleTime(e.options.staleTime,this))}isStale(){return this.getObserversCount()>0?this.observers.some(e=>e.getCurrentResult().isStale):void 0===this.state.data||this.state.isInvalidated}isStaleByTime(e=0){return void 0===this.state.data||"static"!==e&&(!!this.state.isInvalidated||!timeUntilStale(this.state.dataUpdatedAt,e))}onFocus(){const e=this.observers.find(e=>e.shouldFetchOnWindowFocus());e?.refetch({cancelRefetch:!1});__privateGet(this,m)?.continue()}onOnline(){const e=this.observers.find(e=>e.shouldFetchOnReconnect());e?.refetch({cancelRefetch:!1});__privateGet(this,m)?.continue()}addObserver(e){if(!this.observers.includes(e)){this.observers.push(e);this.clearGcTimeout();__privateGet(this,f).notify({type:"observerAdded",query:this,observer:e})}}removeObserver(e){if(this.observers.includes(e)){this.observers=this.observers.filter(t=>t!==e);if(!this.observers.length){__privateGet(this,m)&&(__privateGet(this,y)?__privateGet(this,m).cancel({revert:!0}):__privateGet(this,m).cancelRetry());this.scheduleGc()}__privateGet(this,f).notify({type:"observerRemoved",query:this,observer:e})}}getObserversCount(){return this.observers.length}invalidate(){this.state.isInvalidated||__privateMethod(this,b,w).call(this,{type:"invalidate"})}fetch(e,t){if("idle"!==this.state.fetchStatus)if(void 0!==this.state.data&&t?.cancelRefetch)this.cancel({silent:!0});else if(__privateGet(this,m)){__privateGet(this,m).continueRetry();return __privateGet(this,m).promise}e&&this.setOptions(e);if(!this.options.queryFn){const e=this.observers.find(e=>e.options.queryFn);e&&this.setOptions(e.options)}const n=new AbortController;const addSignalProperty=e=>{Object.defineProperty(e,"signal",{enumerable:!0,get:()=>{__privateSet(this,y,!0);return n.signal}})};const fetchFn=()=>{const e=ensureQueryFn(this.options,t);const createQueryFnContext=()=>{const e={client:__privateGet(this,p),queryKey:this.queryKey,meta:this.meta};addSignalProperty(e);return e};const n=createQueryFnContext();__privateSet(this,y,!1);return this.options.persister?this.options.persister(e,n,this):e(n)};const createFetchContext=()=>{const e={fetchOptions:t,options:this.options,queryKey:this.queryKey,client:__privateGet(this,p),state:this.state,fetchFn:fetchFn};addSignalProperty(e);return e};const s=createFetchContext();this.options.behavior?.onFetch(s,this);__privateSet(this,d,this.state);"idle"!==this.state.fetchStatus&&this.state.fetchMeta===s.fetchOptions?.meta||__privateMethod(this,b,w).call(this,{type:"fetch",meta:s.fetchOptions?.meta});const onError=e=>{isCancelledError(e)&&e.silent||__privateMethod(this,b,w).call(this,{type:"error",error:e});if(!isCancelledError(e)){__privateGet(this,f).config.onError?.(e,this);__privateGet(this,f).config.onSettled?.(this.state.data,e,this)}this.scheduleGc()};__privateSet(this,m,createRetryer({initialPromise:t?.initialPromise,fn:s.fetchFn,abort:n.abort.bind(n),onSuccess:e=>{if(void 0!==e){try{this.setData(e)}catch(t){onError(t);return}__privateGet(this,f).config.onSuccess?.(e,this);__privateGet(this,f).config.onSettled?.(e,this.state.error,this);this.scheduleGc()}else onError(new Error(`${this.queryHash} data is undefined`))},onError:onError,onFail:(e,t)=>{__privateMethod(this,b,w).call(this,{type:"failed",failureCount:e,error:t})},onPause:()=>{__privateMethod(this,b,w).call(this,{type:"pause"})},onContinue:()=>{__privateMethod(this,b,w).call(this,{type:"continue"})},retry:s.options.retry,retryDelay:s.options.retryDelay,networkMode:s.options.networkMode,canRun:()=>!0}));return __privateGet(this,m).start()}},l=new WeakMap,d=new WeakMap,f=new WeakMap,p=new WeakMap,m=new WeakMap,g=new WeakMap,y=new WeakMap,b=new WeakSet,w=function(e){const reducer=t=>{switch(e.type){case"failed":return{...t,fetchFailureCount:e.failureCount,fetchFailureReason:e.error};case"pause":return{...t,fetchStatus:"paused"};case"continue":return{...t,fetchStatus:"fetching"};case"fetch":return{...t,...fetchState(t.data,this.options),fetchMeta:e.meta??null};case"success":__privateSet(this,d,void 0);return{...t,data:e.data,dataUpdateCount:t.dataUpdateCount+1,dataUpdatedAt:e.dataUpdatedAt??Date.now(),error:null,isInvalidated:!1,status:"success",...!e.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};case"error":const n=e.error;return isCancelledError(n)&&n.revert&&__privateGet(this,d)?{...__privateGet(this,d),fetchStatus:"idle"}:{...t,error:n,errorUpdateCount:t.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:t.fetchFailureCount+1,fetchFailureReason:n,fetchStatus:"idle",status:"error"};case"invalidate":return{...t,isInvalidated:!0};case"setState":return{...t,...e.state}}};this.state=reducer(this.state);cc.batch(()=>{this.observers.forEach(e=>{e.onQueryUpdate()});__privateGet(this,f).notify({query:this,type:"updated",action:e})})},v);function fetchState(e,t){return{fetchFailureCount:0,fetchFailureReason:null,fetchStatus:canFetch(t.networkMode)?"fetching":"paused",...void 0===e&&{error:null,status:"pending"}}}function getDefaultState$1(e){const t="function"==typeof e.initialData?e.initialData():e.initialData;const n=void 0!==t;const s=n?"function"==typeof e.initialDataUpdatedAt?e.initialDataUpdatedAt():e.initialDataUpdatedAt:0;return{data:t,dataUpdateCount:0,dataUpdatedAt:n?s??Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:n?"success":"pending",fetchStatus:"idle"}}var dc=(P=class extends ec{constructor(e={}){super();__privateAdd(this,x);this.config=e;__privateSet(this,x,new Map)}build(e,t,n){const s=t.queryKey;const r=t.queryHash??hashQueryKeyByOptions(s,t);let o=this.get(r);if(!o){o=new lc({client:e,queryKey:s,queryHash:r,options:e.defaultQueryOptions(t),state:n,defaultOptions:e.getQueryDefaults(s)});this.add(o)}return o}add(e){if(!__privateGet(this,x).has(e.queryHash)){__privateGet(this,x).set(e.queryHash,e);this.notify({type:"added",query:e})}}remove(e){const t=__privateGet(this,x).get(e.queryHash);if(t){e.destroy();t===e&&__privateGet(this,x).delete(e.queryHash);this.notify({type:"removed",query:e})}}clear(){cc.batch(()=>{this.getAll().forEach(e=>{this.remove(e)})})}get(e){return __privateGet(this,x).get(e)}getAll(){return[...__privateGet(this,x).values()]}find(e){const t={exact:!0,...e};return this.getAll().find(e=>matchQuery(t,e))}findAll(e={}){const t=this.getAll();return Object.keys(e).length>0?t.filter(t=>matchQuery(e,t)):t}notify(e){cc.batch(()=>{this.listeners.forEach(t=>{t(e)})})}onFocus(){cc.batch(()=>{this.getAll().forEach(e=>{e.onFocus()})})}onOnline(){cc.batch(()=>{this.getAll().forEach(e=>{e.onOnline()})})}},x=new WeakMap,P);var hc=(S=class extends uc{constructor(e){super();__privateAdd(this,T);__privateAdd(this,$);__privateAdd(this,E);__privateAdd(this,A);this.mutationId=e.mutationId;__privateSet(this,E,e.mutationCache);__privateSet(this,$,[]);this.state=e.state||getDefaultState();this.setOptions(e.options);this.scheduleGc()}setOptions(e){this.options=e;this.updateGcTime(this.options.gcTime)}get meta(){return this.options.meta}addObserver(e){if(!__privateGet(this,$).includes(e)){__privateGet(this,$).push(e);this.clearGcTimeout();__privateGet(this,E).notify({type:"observerAdded",mutation:this,observer:e})}}removeObserver(e){__privateSet(this,$,__privateGet(this,$).filter(t=>t!==e));this.scheduleGc();__privateGet(this,E).notify({type:"observerRemoved",mutation:this,observer:e})}optionalRemove(){__privateGet(this,$).length||("pending"===this.state.status?this.scheduleGc():__privateGet(this,E).remove(this))}continue(){return __privateGet(this,A)?.continue()??this.execute(this.state.variables)}async execute(e){const onContinue=()=>{__privateMethod(this,T,I).call(this,{type:"continue"})};__privateSet(this,A,createRetryer({fn:()=>this.options.mutationFn?this.options.mutationFn(e):Promise.reject(new Error("No mutationFn found")),onFail:(e,t)=>{__privateMethod(this,T,I).call(this,{type:"failed",failureCount:e,error:t})},onPause:()=>{__privateMethod(this,T,I).call(this,{type:"pause"})},onContinue:onContinue,retry:this.options.retry??0,retryDelay:this.options.retryDelay,networkMode:this.options.networkMode,canRun:()=>__privateGet(this,E).canRun(this)}));const t="pending"===this.state.status;const n=!__privateGet(this,A).canStart();try{if(t)onContinue();else{__privateMethod(this,T,I).call(this,{type:"pending",variables:e,isPaused:n});await(__privateGet(this,E).config.onMutate?.(e,this));const t=await(this.options.onMutate?.(e));t!==this.state.context&&__privateMethod(this,T,I).call(this,{type:"pending",context:t,variables:e,isPaused:n})}const s=await __privateGet(this,A).start();await(__privateGet(this,E).config.onSuccess?.(s,e,this.state.context,this));await(this.options.onSuccess?.(s,e,this.state.context));await(__privateGet(this,E).config.onSettled?.(s,null,this.state.variables,this.state.context,this));await(this.options.onSettled?.(s,null,e,this.state.context));__privateMethod(this,T,I).call(this,{type:"success",data:s});return s}catch(s){try{await(__privateGet(this,E).config.onError?.(s,e,this.state.context,this));await(this.options.onError?.(s,e,this.state.context));await(__privateGet(this,E).config.onSettled?.(void 0,s,this.state.variables,this.state.context,this));await(this.options.onSettled?.(void 0,s,e,this.state.context));throw s}finally{__privateMethod(this,T,I).call(this,{type:"error",error:s})}}finally{__privateGet(this,E).runNext(this)}}},$=new WeakMap,E=new WeakMap,A=new WeakMap,T=new WeakSet,I=function(e){const reducer=t=>{switch(e.type){case"failed":return{...t,failureCount:e.failureCount,failureReason:e.error};case"pause":return{...t,isPaused:!0};case"continue":return{...t,isPaused:!1};case"pending":return{...t,context:e.context,data:void 0,failureCount:0,failureReason:null,error:null,isPaused:e.isPaused,status:"pending",variables:e.variables,submittedAt:Date.now()};case"success":return{...t,data:e.data,failureCount:0,failureReason:null,error:null,status:"success",isPaused:!1};case"error":return{...t,data:void 0,error:e.error,failureCount:t.failureCount+1,failureReason:e.error,isPaused:!1,status:"error"}}};this.state=reducer(this.state);cc.batch(()=>{__privateGet(this,$).forEach(t=>{t.onMutationUpdate(e)});__privateGet(this,E).notify({mutation:this,type:"updated",action:e})})},S);function getDefaultState(){return{context:void 0,data:void 0,error:null,failureCount:0,failureReason:null,isPaused:!1,status:"idle",variables:void 0,submittedAt:0}}var fc=(O=class extends ec{constructor(e={}){super();__privateAdd(this,k);__privateAdd(this,B);__privateAdd(this,C);this.config=e;__privateSet(this,k,new Set);__privateSet(this,B,new Map);__privateSet(this,C,0)}build(e,t,n){const s=new hc({mutationCache:this,mutationId:++__privateWrapper(this,C)._,options:e.defaultMutationOptions(t),state:n});this.add(s);return s}add(e){__privateGet(this,k).add(e);const t=scopeFor(e);if("string"==typeof t){const n=__privateGet(this,B).get(t);n?n.push(e):__privateGet(this,B).set(t,[e])}this.notify({type:"added",mutation:e})}remove(e){if(__privateGet(this,k).delete(e)){const t=scopeFor(e);if("string"==typeof t){const n=__privateGet(this,B).get(t);if(n)if(n.length>1){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}else n[0]===e&&__privateGet(this,B).delete(t)}}this.notify({type:"removed",mutation:e})}canRun(e){const t=scopeFor(e);if("string"==typeof t){const n=__privateGet(this,B).get(t);const s=n?.find(e=>"pending"===e.state.status);return!s||s===e}return!0}runNext(e){const t=scopeFor(e);if("string"==typeof t){const n=__privateGet(this,B).get(t)?.find(t=>t!==e&&t.state.isPaused);return n?.continue()??Promise.resolve()}return Promise.resolve()}clear(){cc.batch(()=>{__privateGet(this,k).forEach(e=>{this.notify({type:"removed",mutation:e})});__privateGet(this,k).clear();__privateGet(this,B).clear()})}getAll(){return Array.from(__privateGet(this,k))}find(e){const t={exact:!0,...e};return this.getAll().find(e=>matchMutation(t,e))}findAll(e={}){return this.getAll().filter(t=>matchMutation(e,t))}notify(e){cc.batch(()=>{this.listeners.forEach(t=>{t(e)})})}resumePausedMutations(){const e=this.getAll().filter(e=>e.state.isPaused);return cc.batch(()=>Promise.all(e.map(e=>e.continue().catch(noop))))}},k=new WeakMap,B=new WeakMap,C=new WeakMap,O);function scopeFor(e){return e.options.scope?.id}function infiniteQueryBehavior(e){return{onFetch:(t,n)=>{const s=t.options;const r=t.fetchOptions?.meta?.fetchMore?.direction;const o=t.state.data?.pages||[];const a=t.state.data?.pageParams||[];let i={pages:[],pageParams:[]};let c=0;const fetchFn=async()=>{let n=!1;const addSignalProperty=e=>{Object.defineProperty(e,"signal",{enumerable:!0,get:()=>{t.signal.aborted?n=!0:t.signal.addEventListener("abort",()=>{n=!0});return t.signal}})};const u=ensureQueryFn(t.options,t.fetchOptions);const fetchPage=async(e,s,r)=>{if(n)return Promise.reject();if(null==s&&e.pages.length)return Promise.resolve(e);const createQueryFnContext=()=>{const e={client:t.client,queryKey:t.queryKey,pageParam:s,direction:r?"backward":"forward",meta:t.options.meta};addSignalProperty(e);return e};const o=createQueryFnContext();const a=await u(o);const{maxPages:i}=t.options;const c=r?addToStart:addToEnd;return{pages:c(e.pages,a,i),pageParams:c(e.pageParams,s,i)}};if(r&&o.length){const e="backward"===r;const t=e?getPreviousPageParam:getNextPageParam;const n={pages:o,pageParams:a};const c=t(s,n);i=await fetchPage(n,c,e)}else{const t=e??o.length;do{const e=0===c?a[0]??s.initialPageParam:getNextPageParam(s,i);if(c>0&&null==e)break;i=await fetchPage(i,e);c++}while(c<t)}return i};t.options.persister?t.fetchFn=()=>t.options.persister?.(fetchFn,{client:t.client,queryKey:t.queryKey,meta:t.options.meta,signal:t.signal},n):t.fetchFn=fetchFn}}}function getNextPageParam(e,{pages:t,pageParams:n}){const s=t.length-1;return t.length>0?e.getNextPageParam(t[s],t,n[s],n):void 0}function getPreviousPageParam(e,{pages:t,pageParams:n}){return t.length>0?e.getPreviousPageParam?.(t[0],t,n[0],n):void 0}var pc=(U=class{constructor(e={}){__privateAdd(this,F);__privateAdd(this,N);__privateAdd(this,R);__privateAdd(this,M);__privateAdd(this,z);__privateAdd(this,j);__privateAdd(this,L);__privateAdd(this,H);__privateSet(this,F,e.queryCache||new dc);__privateSet(this,N,e.mutationCache||new fc);__privateSet(this,R,e.defaultOptions||{});__privateSet(this,M,new Map);__privateSet(this,z,new Map);__privateSet(this,j,0)}mount(){__privateWrapper(this,j)._++;if(1===__privateGet(this,j)){__privateSet(this,L,rc.subscribe(async e=>{if(e){await this.resumePausedMutations();__privateGet(this,F).onFocus()}}));__privateSet(this,H,ac.subscribe(async e=>{if(e){await this.resumePausedMutations();__privateGet(this,F).onOnline()}}))}}unmount(){var e,t;__privateWrapper(this,j)._--;if(0===__privateGet(this,j)){null==(e=__privateGet(this,L))?void 0:e.call(this);__privateSet(this,L,void 0);null==(t=__privateGet(this,H))?void 0:t.call(this);__privateSet(this,H,void 0)}}isFetching(e){return __privateGet(this,F).findAll({...e,fetchStatus:"fetching"}).length}isMutating(e){return __privateGet(this,N).findAll({...e,status:"pending"}).length}getQueryData(e){const t=this.defaultQueryOptions({queryKey:e});return __privateGet(this,F).get(t.queryHash)?.state.data}ensureQueryData(e){const t=this.defaultQueryOptions(e);const n=__privateGet(this,F).build(this,t);const s=n.state.data;if(void 0===s)return this.fetchQuery(e);e.revalidateIfStale&&n.isStaleByTime(resolveStaleTime(t.staleTime,n))&&void this.prefetchQuery(t);return Promise.resolve(s)}getQueriesData(e){return __privateGet(this,F).findAll(e).map(({queryKey:e,state:t})=>{const n=t.data;return[e,n]})}setQueryData(e,t,n){const s=this.defaultQueryOptions({queryKey:e});const r=__privateGet(this,F).get(s.queryHash);const o=r?.state.data;const a=functionalUpdate(t,o);if(void 0!==a)return __privateGet(this,F).build(this,s).setData(a,{...n,manual:!0})}setQueriesData(e,t,n){return cc.batch(()=>__privateGet(this,F).findAll(e).map(({queryKey:e})=>[e,this.setQueryData(e,t,n)]))}getQueryState(e){const t=this.defaultQueryOptions({queryKey:e});return __privateGet(this,F).get(t.queryHash)?.state}removeQueries(e){const t=__privateGet(this,F);cc.batch(()=>{t.findAll(e).forEach(e=>{t.remove(e)})})}resetQueries(e,t){const n=__privateGet(this,F);return cc.batch(()=>{n.findAll(e).forEach(e=>{e.reset()});return this.refetchQueries({type:"active",...e},t)})}cancelQueries(e,t={}){const n={revert:!0,...t};const s=cc.batch(()=>__privateGet(this,F).findAll(e).map(e=>e.cancel(n)));return Promise.all(s).then(noop).catch(noop)}invalidateQueries(e,t={}){return cc.batch(()=>{__privateGet(this,F).findAll(e).forEach(e=>{e.invalidate()});return"none"===e?.refetchType?Promise.resolve():this.refetchQueries({...e,type:e?.refetchType??e?.type??"active"},t)})}refetchQueries(e,t={}){const n={...t,cancelRefetch:t.cancelRefetch??!0};const s=cc.batch(()=>__privateGet(this,F).findAll(e).filter(e=>!e.isDisabled()&&!e.isStatic()).map(e=>{let t=e.fetch(void 0,n);n.throwOnError||(t=t.catch(noop));return"paused"===e.state.fetchStatus?Promise.resolve():t}));return Promise.all(s).then(noop)}fetchQuery(e){const t=this.defaultQueryOptions(e);void 0===t.retry&&(t.retry=!1);const n=__privateGet(this,F).build(this,t);return n.isStaleByTime(resolveStaleTime(t.staleTime,n))?n.fetch(t):Promise.resolve(n.state.data)}prefetchQuery(e){return this.fetchQuery(e).then(noop).catch(noop)}fetchInfiniteQuery(e){e.behavior=infiniteQueryBehavior(e.pages);return this.fetchQuery(e)}prefetchInfiniteQuery(e){return this.fetchInfiniteQuery(e).then(noop).catch(noop)}ensureInfiniteQueryData(e){e.behavior=infiniteQueryBehavior(e.pages);return this.ensureQueryData(e)}resumePausedMutations(){return ac.isOnline()?__privateGet(this,N).resumePausedMutations():Promise.resolve()}getQueryCache(){return __privateGet(this,F)}getMutationCache(){return __privateGet(this,N)}getDefaultOptions(){return __privateGet(this,R)}setDefaultOptions(e){__privateSet(this,R,e)}setQueryDefaults(e,t){__privateGet(this,M).set(hashKey(e),{queryKey:e,defaultOptions:t})}getQueryDefaults(e){const t=[...__privateGet(this,M).values()];const n={};t.forEach(t=>{partialMatchKey(e,t.queryKey)&&Object.assign(n,t.defaultOptions)});return n}setMutationDefaults(e,t){__privateGet(this,z).set(hashKey(e),{mutationKey:e,defaultOptions:t})}getMutationDefaults(e){const t=[...__privateGet(this,z).values()];const n={};t.forEach(t=>{partialMatchKey(e,t.mutationKey)&&Object.assign(n,t.defaultOptions)});return n}defaultQueryOptions(e){if(e._defaulted)return e;const t={...__privateGet(this,R).queries,...this.getQueryDefaults(e.queryKey),...e,_defaulted:!0};t.queryHash||(t.queryHash=hashQueryKeyByOptions(t.queryKey,t));void 0===t.refetchOnReconnect&&(t.refetchOnReconnect="always"!==t.networkMode);void 0===t.throwOnError&&(t.throwOnError=!!t.suspense);!t.networkMode&&t.persister&&(t.networkMode="offlineFirst");t.queryFn===nc&&(t.enabled=!1);return t}defaultMutationOptions(e){return e?._defaulted?e:{...__privateGet(this,R).mutations,...e?.mutationKey&&this.getMutationDefaults(e.mutationKey),...e,_defaulted:!0}}clear(){__privateGet(this,F).clear();__privateGet(this,N).clear()}},F=new WeakMap,N=new WeakMap,R=new WeakMap,M=new WeakMap,z=new WeakMap,j=new WeakMap,L=new WeakMap,H=new WeakMap,U);var mc=(pe=class extends ec{constructor(e,t){super();__privateAdd(this,re);__privateAdd(this,_);__privateAdd(this,D);__privateAdd(this,G);__privateAdd(this,W);__privateAdd(this,V);__privateAdd(this,K);__privateAdd(this,Q);__privateAdd(this,Z);__privateAdd(this,J);__privateAdd(this,Y);__privateAdd(this,X);__privateAdd(this,ee);__privateAdd(this,te);__privateAdd(this,ne);__privateAdd(this,se,new Set);this.options=t;__privateSet(this,_,e);__privateSet(this,Z,null);__privateSet(this,Q,pendingThenable());this.options.experimental_prefetchInRender||__privateGet(this,Q).reject(new Error("experimental_prefetchInRender feature flag is not enabled"));this.bindMethods();this.setOptions(t)}bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){if(1===this.listeners.size){__privateGet(this,D).addObserver(this);shouldFetchOnMount(__privateGet(this,D),this.options)?__privateMethod(this,re,oe).call(this):this.updateResult();__privateMethod(this,re,ue).call(this)}}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return shouldFetchOn(__privateGet(this,D),this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return shouldFetchOn(__privateGet(this,D),this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set;__privateMethod(this,re,le).call(this);__privateMethod(this,re,de).call(this);__privateGet(this,D).removeObserver(this)}setOptions(e){const t=this.options;const n=__privateGet(this,D);this.options=__privateGet(this,_).defaultQueryOptions(e);if(void 0!==this.options.enabled&&"boolean"!=typeof this.options.enabled&&"function"!=typeof this.options.enabled&&"boolean"!=typeof resolveEnabled(this.options.enabled,__privateGet(this,D)))throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");__privateMethod(this,re,he).call(this);__privateGet(this,D).setOptions(this.options);t._defaulted&&!shallowEqualObjects(this.options,t)&&__privateGet(this,_).getQueryCache().notify({type:"observerOptionsUpdated",query:__privateGet(this,D),observer:this});const s=this.hasListeners();s&&shouldFetchOptionally(__privateGet(this,D),n,this.options,t)&&__privateMethod(this,re,oe).call(this);this.updateResult();!s||__privateGet(this,D)===n&&resolveEnabled(this.options.enabled,__privateGet(this,D))===resolveEnabled(t.enabled,__privateGet(this,D))&&resolveStaleTime(this.options.staleTime,__privateGet(this,D))===resolveStaleTime(t.staleTime,__privateGet(this,D))||__privateMethod(this,re,ae).call(this);const r=__privateMethod(this,re,ie).call(this);!s||__privateGet(this,D)===n&&resolveEnabled(this.options.enabled,__privateGet(this,D))===resolveEnabled(t.enabled,__privateGet(this,D))&&r===__privateGet(this,ne)||__privateMethod(this,re,ce).call(this,r)}getOptimisticResult(e){const t=__privateGet(this,_).getQueryCache().build(__privateGet(this,_),e);const n=this.createResult(t,e);if(shouldAssignObserverCurrentProperties(this,n)){__privateSet(this,W,n);__privateSet(this,K,this.options);__privateSet(this,V,__privateGet(this,D).state)}return n}getCurrentResult(){return __privateGet(this,W)}trackResult(e,t){return new Proxy(e,{get:(e,n)=>{this.trackProp(n);t?.(n);return Reflect.get(e,n)}})}trackProp(e){__privateGet(this,se).add(e)}getCurrentQuery(){return __privateGet(this,D)}refetch({...e}={}){return this.fetch({...e})}fetchOptimistic(e){const t=__privateGet(this,_).defaultQueryOptions(e);const n=__privateGet(this,_).getQueryCache().build(__privateGet(this,_),t);return n.fetch().then(()=>this.createResult(n,t))}fetch(e){return __privateMethod(this,re,oe).call(this,{...e,cancelRefetch:e.cancelRefetch??!0}).then(()=>{this.updateResult();return __privateGet(this,W)})}createResult(e,t){const n=__privateGet(this,D);const s=this.options;const r=__privateGet(this,W);const o=__privateGet(this,V);const a=__privateGet(this,K);const i=e!==n;const c=i?e.state:__privateGet(this,G);const{state:u}=e;let l={...u};let d=!1;let f;if(t._optimisticResults){const r=this.hasListeners();const o=!r&&shouldFetchOnMount(e,t);const a=r&&shouldFetchOptionally(e,n,t,s);(o||a)&&(l={...l,...fetchState(u.data,e.options)});"isRestoring"===t._optimisticResults&&(l.fetchStatus="idle")}let{error:p,errorUpdatedAt:m,status:g}=l;f=l.data;let y=!1;if(void 0!==t.placeholderData&&void 0===f&&"pending"===g){let e;if(r?.isPlaceholderData&&t.placeholderData===a?.placeholderData){e=r.data;y=!0}else e="function"==typeof t.placeholderData?t.placeholderData(__privateGet(this,X)?.state.data,__privateGet(this,X)):t.placeholderData;if(void 0!==e){g="success";f=replaceData(r?.data,e,t);d=!0}}if(t.select&&void 0!==f&&!y)if(r&&f===o?.data&&t.select===__privateGet(this,J))f=__privateGet(this,Y);else try{__privateSet(this,J,t.select);f=t.select(f);f=replaceData(r?.data,f,t);__privateSet(this,Y,f);__privateSet(this,Z,null)}catch(A){__privateSet(this,Z,A)}if(__privateGet(this,Z)){p=__privateGet(this,Z);f=__privateGet(this,Y);m=Date.now();g="error"}const b="fetching"===l.fetchStatus;const w="pending"===g;const v="error"===g;const x=w&&b;const P=void 0!==f;const $={status:g,fetchStatus:l.fetchStatus,isPending:w,isSuccess:"success"===g,isError:v,isInitialLoading:x,isLoading:x,data:f,dataUpdatedAt:l.dataUpdatedAt,error:p,errorUpdatedAt:m,failureCount:l.fetchFailureCount,failureReason:l.fetchFailureReason,errorUpdateCount:l.errorUpdateCount,isFetched:l.dataUpdateCount>0||l.errorUpdateCount>0,isFetchedAfterMount:l.dataUpdateCount>c.dataUpdateCount||l.errorUpdateCount>c.errorUpdateCount,isFetching:b,isRefetching:b&&!w,isLoadingError:v&&!P,isPaused:"paused"===l.fetchStatus,isPlaceholderData:d,isRefetchError:v&&P,isStale:isStale(e,t),refetch:this.refetch,promise:__privateGet(this,Q),isEnabled:!1!==resolveEnabled(t.enabled,e)};const E=$;if(this.options.experimental_prefetchInRender){const finalizeThenableIfPossible=e=>{"error"===E.status?e.reject(E.error):void 0!==E.data&&e.resolve(E.data)};const recreateThenable=()=>{const e=__privateSet(this,Q,E.promise=pendingThenable());finalizeThenableIfPossible(e)};const t=__privateGet(this,Q);switch(t.status){case"pending":e.queryHash===n.queryHash&&finalizeThenableIfPossible(t);break;case"fulfilled":"error"!==E.status&&E.data===t.value||recreateThenable();break;case"rejected":"error"===E.status&&E.error===t.reason||recreateThenable()}}return E}updateResult(){const e=__privateGet(this,W);const t=this.createResult(__privateGet(this,D),this.options);__privateSet(this,V,__privateGet(this,D).state);__privateSet(this,K,this.options);void 0!==__privateGet(this,V).data&&__privateSet(this,X,__privateGet(this,D));if(shallowEqualObjects(t,e))return;__privateSet(this,W,t);const shouldNotifyListeners=()=>{if(!e)return!0;const{notifyOnChangeProps:t}=this.options;const n="function"==typeof t?t():t;if("all"===n||!n&&!__privateGet(this,se).size)return!0;const s=new Set(n??__privateGet(this,se));this.options.throwOnError&&s.add("error");return Object.keys(__privateGet(this,W)).some(t=>{const n=t;const r=__privateGet(this,W)[n]!==e[n];return r&&s.has(n)})};__privateMethod(this,re,fe).call(this,{listeners:shouldNotifyListeners()})}onQueryUpdate(){this.updateResult();this.hasListeners()&&__privateMethod(this,re,ue).call(this)}},_=new WeakMap,D=new WeakMap,G=new WeakMap,W=new WeakMap,V=new WeakMap,K=new WeakMap,Q=new WeakMap,Z=new WeakMap,J=new WeakMap,Y=new WeakMap,X=new WeakMap,ee=new WeakMap,te=new WeakMap,ne=new WeakMap,se=new WeakMap,re=new WeakSet,oe=function(e){__privateMethod(this,re,he).call(this);let t=__privateGet(this,D).fetch(this.options,e);e?.throwOnError||(t=t.catch(noop));return t},ae=function(){__privateMethod(this,re,le).call(this);const e=resolveStaleTime(this.options.staleTime,__privateGet(this,D));if(tc||__privateGet(this,W).isStale||!isValidTimeout(e))return;const t=timeUntilStale(__privateGet(this,W).dataUpdatedAt,e);const n=t+1;__privateSet(this,ee,setTimeout(()=>{__privateGet(this,W).isStale||this.updateResult()},n))},ie=function(){return("function"==typeof this.options.refetchInterval?this.options.refetchInterval(__privateGet(this,D)):this.options.refetchInterval)??!1},ce=function(e){__privateMethod(this,re,de).call(this);__privateSet(this,ne,e);!tc&&!1!==resolveEnabled(this.options.enabled,__privateGet(this,D))&&isValidTimeout(__privateGet(this,ne))&&0!==__privateGet(this,ne)&&__privateSet(this,te,setInterval(()=>{(this.options.refetchIntervalInBackground||rc.isFocused())&&__privateMethod(this,re,oe).call(this)},__privateGet(this,ne)))},ue=function(){__privateMethod(this,re,ae).call(this);__privateMethod(this,re,ce).call(this,__privateMethod(this,re,ie).call(this))},le=function(){if(__privateGet(this,ee)){clearTimeout(__privateGet(this,ee));__privateSet(this,ee,void 0)}},de=function(){if(__privateGet(this,te)){clearInterval(__privateGet(this,te));__privateSet(this,te,void 0)}},he=function(){const e=__privateGet(this,_).getQueryCache().build(__privateGet(this,_),this.options);if(e===__privateGet(this,D))return;const t=__privateGet(this,D);__privateSet(this,D,e);__privateSet(this,G,e.state);if(this.hasListeners()){t?.removeObserver(this);e.addObserver(this)}},fe=function(e){cc.batch(()=>{e.listeners&&this.listeners.forEach(e=>{e(__privateGet(this,W))});__privateGet(this,_).getQueryCache().notify({query:__privateGet(this,D),type:"observerResultsUpdated"})})},pe);function shouldLoadOnMount(e,t){return!1!==resolveEnabled(t.enabled,e)&&void 0===e.state.data&&!("error"===e.state.status&&!1===t.retryOnMount)}function shouldFetchOnMount(e,t){return shouldLoadOnMount(e,t)||void 0!==e.state.data&&shouldFetchOn(e,t,t.refetchOnMount)}function shouldFetchOn(e,t,n){if(!1!==resolveEnabled(t.enabled,e)&&"static"!==resolveStaleTime(t.staleTime,e)){const s="function"==typeof n?n(e):n;return"always"===s||!1!==s&&isStale(e,t)}return!1}function shouldFetchOptionally(e,t,n,s){return(e!==t||!1===resolveEnabled(s.enabled,e))&&(!n.suspense||"error"!==e.state.status)&&isStale(e,n)}function isStale(e,t){return!1!==resolveEnabled(t.enabled,e)&&e.isStaleByTime(resolveStaleTime(t.staleTime,e))}function shouldAssignObserverCurrentProperties(e,t){return!shallowEqualObjects(e.getCurrentResult(),t)}var gc=(Pe=class extends ec{constructor(e,t){super();__privateAdd(this,we);__privateAdd(this,me);__privateAdd(this,ge);__privateAdd(this,ye);__privateAdd(this,be);__privateSet(this,me,e);this.setOptions(t);this.bindMethods();__privateMethod(this,we,ve).call(this)}bindMethods(){this.mutate=this.mutate.bind(this);this.reset=this.reset.bind(this)}setOptions(e){const t=this.options;this.options=__privateGet(this,me).defaultMutationOptions(e);shallowEqualObjects(this.options,t)||__privateGet(this,me).getMutationCache().notify({type:"observerOptionsUpdated",mutation:__privateGet(this,ye),observer:this});t?.mutationKey&&this.options.mutationKey&&hashKey(t.mutationKey)!==hashKey(this.options.mutationKey)?this.reset():"pending"===__privateGet(this,ye)?.state.status&&__privateGet(this,ye).setOptions(this.options)}onUnsubscribe(){this.hasListeners()||__privateGet(this,ye)?.removeObserver(this)}onMutationUpdate(e){__privateMethod(this,we,ve).call(this);__privateMethod(this,we,xe).call(this,e)}getCurrentResult(){return __privateGet(this,ge)}reset(){__privateGet(this,ye)?.removeObserver(this);__privateSet(this,ye,void 0);__privateMethod(this,we,ve).call(this);__privateMethod(this,we,xe).call(this)}mutate(e,t){__privateSet(this,be,t);__privateGet(this,ye)?.removeObserver(this);__privateSet(this,ye,__privateGet(this,me).getMutationCache().build(__privateGet(this,me),this.options));__privateGet(this,ye).addObserver(this);return __privateGet(this,ye).execute(e)}},me=new WeakMap,ge=new WeakMap,ye=new WeakMap,be=new WeakMap,we=new WeakSet,ve=function(){const e=__privateGet(this,ye)?.state??getDefaultState();__privateSet(this,ge,{...e,isPending:"pending"===e.status,isSuccess:"success"===e.status,isError:"error"===e.status,isIdle:"idle"===e.status,mutate:this.mutate,reset:this.reset})},xe=function(e){cc.batch(()=>{if(__privateGet(this,be)&&this.hasListeners()){const t=__privateGet(this,ge).variables;const n=__privateGet(this,ge).context;if("success"===e?.type){__privateGet(this,be).onSuccess?.(e.data,t,n);__privateGet(this,be).onSettled?.(e.data,null,t,n)}else if("error"===e?.type){__privateGet(this,be).onError?.(e.error,t,n);__privateGet(this,be).onSettled?.(void 0,e.error,t,n)}}this.listeners.forEach(e=>{e(__privateGet(this,ge))})})},Pe);function hashFn(e){return JSON.stringify(e,(e,t)=>isPlainObject(t)?Object.keys(t).sort().reduce((e,n)=>{e[n]=t[n];return e},{}):"bigint"==typeof t?t.toString():t)}function isPlainObject(e){if(!hasObjectPrototype(e))return!1;const t=e.constructor;if("undefined"==typeof t)return!0;const n=t.prototype;return!!hasObjectPrototype(n)&&!!n.hasOwnProperty("isPrototypeOf")}function hasObjectPrototype(e){return"[object Object]"===Object.prototype.toString.call(e)}function filterQueryOptions(e){const{_defaulted:t,behavior:n,gcTime:s,initialData:r,initialDataUpdatedAt:o,maxPages:a,meta:i,networkMode:c,queryFn:u,queryHash:l,queryKey:d,queryKeyHashFn:f,retry:p,retryDelay:m,structuralSharing:g,getPreviousPageParam:y,getNextPageParam:b,initialPageParam:w,_optimisticResults:v,enabled:x,notifyOnChangeProps:P,placeholderData:$,refetchInterval:E,refetchIntervalInBackground:A,refetchOnMount:T,refetchOnReconnect:I,refetchOnWindowFocus:S,retryOnMount:k,select:B,staleTime:C,suspense:O,throwOnError:F,config:N,connector:R,query:M,...z}=e;return z}function connectMutationOptions(e){return{mutationFn:t=>connect(e,t),mutationKey:["connect"]}}function disconnectMutationOptions(e){return{mutationFn:t=>disconnect(e,t),mutationKey:["disconnect"]}}function getBalanceQueryOptions(e,t={}){return{async queryFn({queryKey:t}){const{address:n,scopeKey:s,...r}=t[1];if(!n)throw new Error("address is required");const o=await getBalance(e,{...r,address:n});return o??null},queryKey:getBalanceQueryKey(t)}}function getBalanceQueryKey(e={}){return["balance",filterQueryOptions(e)]}function switchChainMutationOptions(e){return{mutationFn:t=>switchChain(e,t),mutationKey:["switchChain"]}}var yc=Be.createContext(void 0);var useQueryClient=e=>{const t=Be.useContext(yc);if(!t)throw new Error("No QueryClient set, use QueryClientProvider to set one");return t};var QueryClientProvider=({client:e,children:t})=>{Be.useEffect(()=>{e.mount();return()=>{e.unmount()}},[e]);return ke.jsx(yc.Provider,{value:e,children:t})};var bc=Be.createContext(!1);var useIsRestoring=()=>Be.useContext(bc);bc.Provider;function createValue(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var wc=Be.createContext(createValue());var useQueryErrorResetBoundary=()=>Be.useContext(wc);var ensurePreventErrorBoundaryRetry=(e,t)=>{(e.suspense||e.throwOnError||e.experimental_prefetchInRender)&&(t.isReset()||(e.retryOnMount=!1))};var useClearResetErrorBoundary=e=>{Be.useEffect(()=>{e.clearReset()},[e])};var getHasError=({result:e,errorResetBoundary:t,throwOnError:n,query:s,suspense:r})=>e.isError&&!t.isReset()&&!e.isFetching&&s&&(r&&void 0===e.data||shouldThrowError(n,[e.error,s]));var ensureSuspenseTimers=e=>{if(e.suspense){const clamp=e=>"static"===e?e:Math.max(e??1e3,1e3);const t=e.staleTime;e.staleTime="function"==typeof t?(...e)=>clamp(t(...e)):clamp(t);"number"==typeof e.gcTime&&(e.gcTime=Math.max(e.gcTime,1e3))}};var willFetch=(e,t)=>e.isLoading&&e.isFetching&&!t;var shouldSuspend=(e,t)=>e?.suspense&&t.isPending;var fetchOptimistic=(e,t,n)=>t.fetchOptimistic(e).catch(()=>{n.clearReset()});function useBaseQuery(e,t,n){const s=useIsRestoring();const r=useQueryErrorResetBoundary();const o=useQueryClient();const a=o.defaultQueryOptions(e);o.getDefaultOptions().queries?._experimental_beforeQuery?.(a);a._optimisticResults=s?"isRestoring":"optimistic";ensureSuspenseTimers(a);ensurePreventErrorBoundaryRetry(a,r);useClearResetErrorBoundary(r);const i=!o.getQueryCache().get(a.queryHash);const[c]=Be.useState(()=>new t(o,a));const u=c.getOptimisticResult(a);const l=!s&&!1!==e.subscribed;Be.useSyncExternalStore(Be.useCallback(e=>{const t=l?c.subscribe(cc.batchCalls(e)):noop;c.updateResult();return t},[c,l]),()=>c.getCurrentResult(),()=>c.getCurrentResult());Be.useEffect(()=>{c.setOptions(a)},[a,c]);if(shouldSuspend(a,u))throw fetchOptimistic(a,c,r);if(getHasError({result:u,errorResetBoundary:r,throwOnError:a.throwOnError,query:o.getQueryCache().get(a.queryHash),suspense:a.suspense}))throw u.error;o.getDefaultOptions().queries?._experimental_afterQuery?.(a,u);if(a.experimental_prefetchInRender&&!tc&&willFetch(u,s)){const e=i?fetchOptimistic(a,c,r):o.getQueryCache().get(a.queryHash)?.promise;e?.catch(noop).finally(()=>{c.updateResult()})}return a.notifyOnChangeProps?u:c.trackResult(u)}function useQuery$1(e,t){return useBaseQuery(e,mc)}function useMutation(e,t){const n=useQueryClient();const[s]=Be.useState(()=>new gc(n,e));Be.useEffect(()=>{s.setOptions(e)},[s,e]);const r=Be.useSyncExternalStore(Be.useCallback(e=>s.subscribe(cc.batchCalls(e)),[s]),()=>s.getCurrentResult(),()=>s.getCurrentResult());const o=Be.useCallback((e,t)=>{s.mutate(e,t).catch(noop)},[s]);if(r.error&&shouldThrowError(s.options.throwOnError,[r.error]))throw r.error;return{...r,mutate:o,mutateAsync:r.mutate}}function useQuery(e){const t=useQuery$1({...e,queryKeyHashFn:hashFn});t.queryKey=e.queryKey;return t}function useChainId(e={}){const t=useConfig(e);return Be.useSyncExternalStore(e=>watchChainId(t,{onChange:e}),()=>getChainId(t),()=>getChainId(t))}function useBalance(e={}){const{address:t,query:n={}}=e;const s=useConfig(e);const r=useChainId({config:s});const o=getBalanceQueryOptions(s,{...e,chainId:e.chainId??r});const a=Boolean(t&&(n.enabled??!0));return useQuery({...n,...o,enabled:a})}function useChains(e={}){const t=useConfig(e);return Be.useSyncExternalStore(e=>watchChains(t,{onChange:e}),()=>getChains(t),()=>getChains(t))}function useConnectors(e={}){const t=useConfig(e);return Be.useSyncExternalStore(e=>watchConnectors(t,{onChange:e}),()=>getConnectors(t),()=>getConnectors(t))}function useConnect(e={}){const{mutation:t}=e;const n=useConfig(e);const s=connectMutationOptions(n);const{mutate:r,mutateAsync:o,...a}=useMutation({...t,...s});Be.useEffect(()=>n.subscribe(({status:e})=>e,(e,t)=>{"connected"===t&&"disconnected"===e&&a.reset()}),[n,a.reset]);return{...a,connect:r,connectAsync:o,connectors:useConnectors({config:n})}}function useConnections(e={}){const t=useConfig(e);return Be.useSyncExternalStore(e=>watchConnections(t,{onChange:e}),()=>getConnections(t),()=>getConnections(t))}function useDisconnect(e={}){const{mutation:t}=e;const n=useConfig(e);const s=disconnectMutationOptions(n);const{mutate:r,mutateAsync:o,...a}=useMutation({...t,...s});return{...a,connectors:useConnections({config:n}).map(e=>e.connector),disconnect:r,disconnectAsync:o}}function useSwitchChain(e={}){const{mutation:t}=e;const n=useConfig(e);const s=switchChainMutationOptions(n);const{mutate:r,mutateAsync:o,...a}=useMutation({...t,...s});return{...a,chains:useChains({config:n}),switchChain:r,switchChainAsync:o}}export{getCode as $,parseUnits as A,watchConnectors as B,di as C,getConnections as D,connect as E,switchChain as F,reconnect as G,getBalance as H,disconnect as I,QueryClientProvider as J,Ce as K,withTimeout as L,concat$1 as M,pad$2 as N,hashTypedData as O,Ii as P,pc as Q,Oe as R,es as S,encodeAbiParameters as T,Qn as U,keccak256$1 as V,WagmiProvider as W,createNonceManager as X,serializeErc6492Signature as Y,getAction$1 as Z,__vitePreload as _,useChainId as a,readContract$1 as a0,parseAbi as a1,Re as a2,prettyPrint as a3,formatGwei as a4,decodeErrorResult as a5,zr as a6,Mr as a7,Rr as a8,hexToBigInt as a9,stringToHex as aA,size$4 as aB,parseSignature as aC,encodePacked as aD,hexToString as aE,decodeAbiParameters as aF,Gs as aG,hexToNumber$1 as aH,isAddressEqual as aI,requireEventemitter3 as aJ,Zt as aa,parseAccount as ab,encodeFunctionData as ac,estimateFeesPerGas as ad,prepareAuthorization as ae,getChainId$1 as af,serializeStateOverride as ag,formatLog as ah,formatTransactionReceipt as ai,stringify$1 as aj,observe as ak,poll as al,createClient as am,Ri as an,defineChain as ao,createPublicClient as ap,isAddress as aq,isHex as ar,hashMessage as as,slice$1 as at,toHex as au,waitForCallsStatus as av,stringToBytes as aw,hexToBytes$1 as ax,trim as ay,decodeFunctionData as az,useBalance as b,useDisconnect as c,useConnect as d,useSwitchChain as e,formatUnits as f,fallback as g,http as h,createConnector as i,ke as j,getAddress as k,getAccount as l,createConfig as m,numberToHex as n,watchConnections as o,watchAccount as p,injected as q,Be as r,signMessage as s,prepareTransactionRequest as t,useAccount as u,sendTransaction as v,watchPendingTransactions as w,waitForTransactionReceipt as x,writeContract as y,estimateGas as z};
//# sourceMappingURL=wagmi-MLQ1qm62.js.map
