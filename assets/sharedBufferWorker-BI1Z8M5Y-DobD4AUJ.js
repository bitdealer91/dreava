class e{constructor(){this.worker=null;this.initialized=!1;this.bufferSize=1048576;this.init()}async init(){try{if("undefined"!=typeof SharedArrayBuffer){this.worker=new Worker("/workers/shared-buffer-worker.js");this.worker.onmessage=this.handleMessage.bind(this);this.worker.onerror=this.handleError.bind(this);this.initialized=!0;console.log("‚úÖ Shared Buffer Worker initialized")}else console.warn("‚ö†Ô∏è SharedArrayBuffer not supported")}catch(e){console.warn("‚ö†Ô∏è Shared Buffer Worker initialization failed:",e)}}handleMessage(e){const{type:r,data:s,id:o}=e.data;switch(r){case"PROCESSING_COMPLETE":console.log("‚úÖ Shared buffer processing complete:",s);break;case"PROCESSING_PROGRESS":console.log("üìä Shared buffer progress:",s);break;case"ERROR":console.error("‚ùå Shared buffer error:",s);break;default:console.log("üì® Shared buffer message:",r,s)}}handleError(e){console.error("‚ùå Shared Buffer Worker error:",e)}async processFiles(e){if(!this.initialized){console.warn("‚ö†Ô∏è Shared Buffer Worker not available, using fallback");return await this.fallbackProcessing(e)}return new Promise((r,s)=>{const o=Date.now();const t=setTimeout(()=>{console.error("‚è∞ Shared buffer processing timeout");s(new Error("Processing timeout"))},3e4);const messageHandler=e=>{const{type:a,data:n,id:i}=e.data;if(i===o){clearTimeout(t);this.worker.removeEventListener("message",messageHandler);"PROCESSING_COMPLETE"===a?r(n):"ERROR"===a&&s(new Error(n))}};this.worker.addEventListener("message",messageHandler);const a=e.map(e=>{const r=new SharedArrayBuffer(this.bufferSize);return{file:e,buffer:r}});this.worker.postMessage({type:"PROCESS_FILES",data:{files:a},id:o})})}async fallbackProcessing(e){console.log("üîÑ Using fallback processing for files:",e.length);const r=[];for(const o of e)try{const e=await this.processFileFallback(o);r.push(e)}catch(s){console.error("‚ùå Fallback processing failed for file:",o.name,s);r.push({error:s.message})}return r}async processFileFallback(e){return new Promise(r=>{const s=new FileReader;s.onload=s=>{const o=s.target.result;const t=new Uint8Array(o);let a=0;for(let e=0;e<t.length;e++)a+=t[e];r({file:e.name,size:e.size,checksum:a,processed:!0})};s.onerror=()=>{r({file:e.name,error:"File reading failed",processed:!1})};s.readAsArrayBuffer(e)})}async compressData(e){return this.initialized?new Promise((r,s)=>{const o=Date.now();const t=setTimeout(()=>{console.error("‚è∞ Compression timeout");s(new Error("Compression timeout"))},1e4);const messageHandler=e=>{const{type:a,data:n,id:i}=e.data;if(i===o){clearTimeout(t);this.worker.removeEventListener("message",messageHandler);"COMPRESSION_COMPLETE"===a?r(n):"ERROR"===a&&s(new Error(n))}};this.worker.addEventListener("message",messageHandler);this.worker.postMessage({type:"COMPRESS_DATA",data:{data:e},id:o})}):await this.fallbackCompression(e)}async fallbackCompression(e){try{const r=new CompressionStream("gzip");const s=r.writable.getWriter();const o=r.readable.getReader();const t=new Uint8Array(e);s.write(t);s.close();const a=[];for(;;){const{done:e,value:r}=await o.read();if(e)break;a.push(r)}const n=new Uint8Array(a.reduce((e,r)=>e+r.length,0));let i=0;for(const e of a){n.set(e,i);i+=e.length}return n.buffer}catch(r){console.warn("‚ö†Ô∏è Fallback compression failed:",r);return e}}async decompressData(e){return this.initialized?new Promise((r,s)=>{const o=Date.now();const t=setTimeout(()=>{console.error("‚è∞ Decompression timeout");s(new Error("Decompression timeout"))},1e4);const messageHandler=e=>{const{type:a,data:n,id:i}=e.data;if(i===o){clearTimeout(t);this.worker.removeEventListener("message",messageHandler);"DECOMPRESSION_COMPLETE"===a?r(n):"ERROR"===a&&s(new Error(n))}};this.worker.addEventListener("message",messageHandler);this.worker.postMessage({type:"DECOMPRESS_DATA",data:{data:e},id:o})}):await this.fallbackDecompression(e)}async fallbackDecompression(e){try{const r=new DecompressionStream("gzip");const s=r.writable.getWriter();const o=r.readable.getReader();const t=new Uint8Array(e);s.write(t);s.close();const a=[];for(;;){const{done:e,value:r}=await o.read();if(e)break;a.push(r)}const n=new Uint8Array(a.reduce((e,r)=>e+r.length,0));let i=0;for(const e of a){n.set(e,i);i+=e.length}return n.buffer}catch(r){console.warn("‚ö†Ô∏è Fallback decompression failed:",r);return e}}destroy(){if(this.worker){this.worker.terminate();this.worker=null}this.initialized=!1}}export{e as SharedBufferWorker};
//# sourceMappingURL=sharedBufferWorker-BI1Z8M5Y-DobD4AUJ.js.map
